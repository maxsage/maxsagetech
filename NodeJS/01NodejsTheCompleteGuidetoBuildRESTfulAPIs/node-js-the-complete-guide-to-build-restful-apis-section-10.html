<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>Node:js The Complete Guide to Build RESTful APIs (2018)</title>
  <script src="https://unpkg.com/vue"></script>
  <link crossorigin="anonymous"
        href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
        rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
  </style>
</head>
<body>
<div class="container" id="app">
  <div class="panel-group">
    <div class="panel panel-primary">
      <div class="panel-heading">
                      <h2>Section 10 - Authentication and Authorization</h2>

                      <h3>124 - Introduction</h3>

                      Back to our vidly application. So far we have built these API endpoints so we
                      can manage:

                      /api/genres /api/movies /api/customers /api/rentals

                      Nearly all applications out there require some sort of authentication and
                      authorization. So in this section, we're going to take this application to the
                      next level and implement authentication and authorization.

                      Now before we go any further, I want to make sure we are on the same page.

                      So authentication is the process of identifying if the user is who they claim
                      they are - that's when we login. So we send our username and password to the
                      server, and the server authenticates us.

                      Authorization, is determining if the user has the right permission to perform
                      the given operation.

                      // Authentication // Authorization

                      So in our vidly application, we want to make sure that only authenticated
                      users or logged in users can perform operations that modify data. If the user
                      is anonymous - if they are not logged in they they can only read data from the
                      endpoints.

                      If they want to create a new genre or update a movie, they have to be
                      authenticated first. As an additional security, we want to make sure that only
                      admin users can delete data. So that's a second level of authorization - we're
                      talking about permissions here.

                      These are the requirements we are going to implement in this section. To do
                      this, we are going to add two new endpoints to our application.

                      First, we should be able to register users.

                      // Register: POST /api/users

                      Because we POST we create a new resource, in this case a new user.

                      We should also be able to login a user - that's used for authentication. Now
                      here's a question for you. What http method, should we use to implement login?
                      With login we are not creating a new resource, not updating or removing an
                      existing one, so how can we implement this in RESTful terms? This is a
                      scenario which you may encounter frequently in real-world applications.
                      Sometimes the operation you're dealing with doesn't have that
                      Create/Read/Update/Delete semantic. The way we model this is RESTful terms is
                      by referring to this as a request or command.

                      So we are creating a new login request or command so we use POST

                      // Login: POST /api/logins

                      In your application, you may want to store all the logins into the
                      applications in a separate collection in MongoDB. So, in that context using
                      POST makes perfect sense here. Even if you don't store individual logins and
                      you just want to validate the username and password you can still treat this
                      resource as login resource and use post to create it.

                      Here's an exercise for you. I want you to implement this API:

                      // Register: POST /api/users

                      to register new users. For each user we want the following properties:

                      - name - email - password

                      Also, when defining your schema, for the email property in the Schema type
                      object, set the unique property to true. So when we define the Schema we set
                      the type of email to a Schema type object:

                      email: { type: String, unique: true }

                      This will ensure that we do not store two documents with the same email in
                      MongoDB.

                      <h3>125 - Creating the User Model</h3>

                      First I am going to define a new User model. In the models folder add a new
                      file called user.js

                      To save time we can copy a lot of the code from genre.js:

                      const Joi = require('joi'); const mongoose = require('mongoose');

                      const genreSchema = new mongoose.Schema({ name: { type: String, required:
                      true, minlength: 5, maxlength: 50 } });

                      const Genre = mongoose.model('Genre', genreSchema);

                      function validateGenre(genre) { const schema = { name:
                      Joi.string().min(3).required() };

                      return Joi.validate(genre, schema); }

                      exports.genreSchema = genreSchema; exports.Genre = Genre; exports.validate =
                      validateGenre;

                      So, at the top, we have this Schema. We will define this while calling the
                      model method. There is really no need, in this case, to define this as a
                      separate constant:

                      const Genre = mongoose.model('Genre', new mongoose.Schema({ name: { type:
                      String, required: true, minlength: 5, maxlength: 50 } }));

                      Modify the model and collection name to User:

                      const User = mongoose.model('User', new mongoose.Schema({

                      The name property is a required string that has to be between 5 and 50
                      characters. That sounds good to me. Next, let's add email:

                      email: { type: String, required: true, minlength: 5, maxlength: 255, unique:
                      true }

                      We increas the maximum length and also, as discussed in the last lectue, we
                      should add the unique property to make sure we don't store two users with the
                      same email in MongoDB.

                      The last property is password:

                      password: { type: String, required: true, minlength: 5, maxlength: 1024 }

                      We set the max length to higher value because this password will be hashed. We
                      don't need the unique property.

                      Next is our validate function:

                      function validateUser(user) { const schema = { name:
                      Joi.string().min(5).max(50).required(), email:
                      Joi.string().min(5).max(255).required().email(), password:
                      Joi.string().min(5).max(255).required() };

                      First, we rename to validateUser. We specify name, which is between 5-50
                      characters and required. We have email, which should be between 5-255
                      characters and required. Here, we also call the email method to make sure the
                      email is valid. Finally we have password which is also a string between 5 and
                      255. This is the password that the user sends in plain text. We are going to
                      hash this which will result in a longer string - that's the string we will
                      store in MongoDB.

                      Finally we need to change the call to Joi.validate from genre to user:

                      return Joi.validate(user, schema);

                      So we are done with our validate user function, now we need to export our user
                      model. We can delete our first exports statment - that's for our schema:

                      exports.User = User; exports.validate = validateUser;

                      So we are done with our User model. In the next section we will add a route to
                      register new users.

                      <h3>126 - Registering Users</h3>

                      Alright, now we are going to create a new route to register new users. In the
                      routes folder add a new file, users.js. Once again, to save time, I'm going to
                      go to genres.js and copy the require statement and the new routes into our
                      users.js module:

                      const {Genre, validate} = require('../models/genre'); const mongoose =
                      require('mongoose'); const express = require('express'); const router =
                      express.Router();

                      router.get('/', async (req, res) => { const genres = await
                      Genre.find().sort('name'); res.send(genres); });

                      Now let's make some changes. On the top we need to import the user model
                      instead of the Genre model:

                      const {User, validate} = require('../models/user');

                      So, for models/user, we import the user class as well as the validate
                      function. We also require mongoose, express and router.

                      Next we add our new route which is post:

                      router.post('/', async (req, res) => {

                      For creating, registering new users, and finally we need to export this
                      router:

                      module.exports = router;

                      Now, in index.js, we need to tell express that for any route that starts with
                      /api/users it should use the router we just exported above.

                      const users = require('./routes/users');

                      Then we tell express to use this route:

                      app.use('/api/users', users);

                      So, we have built the big picture. Now let's go back to our users module and
                      implement this new route:

                      router.post('/', async (req, res) => { });

                      So, here we need to validate the request. If it's not valid we have to return
                      a 400 error, which is bad request, otherwise we're going to create a new use
                      object and save it to the database.

                      We can borrow some more code from our genres module. Copy the boddy of the
                      post method onto the users post method and make the following adjustments:

                      router.post('/', async (req, res) => { const { error } = validate(req.body);
                      if (error) return res.status(400).send(error.details[0].message);

                      let user = await User.findOne({ email: req.body.email }); if (user) return
                      res.status(400).send('User already registered.');

                      user = new User({ name: req.body.name, email: req.body.email, password:
                      req.body.password

                      });

                      user = await user.save();

                      res.send(user); });

                      We add some validation to make sure the user is not already registered. We use
                      findOne instead of findById because we are not looking a user up by their id
                      we are looking them up by one of their properties - email:

                      let user = await User.findOne({ email: req.body.email });

                      This returns a promise which we await and assign to a user object. We define a
                      variable instead of a constant because later we will reset this.

                      In this scenario if the user already exists in the database we return a 400
                      bad request to the client:

                      if (user) return status(400).send('User already registered.');

                      Ok so if we have a valid user object that is not registered in the database
                      then we save this user in the database.

                      First we reset the user object (at this point it should be null):

                      user = new User({ name: req.body.name, email: req.body.email, password:
                      req.body.password

                      });

                      And then we save the user and return it to the client:

                      user = await user.save(); res.send(user);

                      Test the application. In postman send a post request to:

                      http://localhost:3000/api/users

                      In the body of the request set the raw property and type to Json
                      (application/json) object and then pass three properties:

                      { "name": "Mosh Hamedani", "email": "1" }

                      So in this request I am sending an invalid email and we are not passing a
                      password.

                      You should receive the following response:

                      "email" length must be at least 5 characters long

                      So change the email to:

                      { "name": "Mosh Hamedani", "email": "123456" }

                      You should receive the following response:

                      "email" must be a valid email

                      So, now, let's change the email to:

                      { "name": "Mosh Hamedani", "email": "programmingwithmosh@gmail.com" }

                      And now you should recieve the following message:

                      "password" is required

                      Finally let's add a password that is 5 characters long:

                      { "name": "Mosh Hamedani", "email": "programmingwithmosh@gmail.com",
                      "password": "12345" }

                      At last you should get a 200 response and the user object that has been stored
                      in the database should be returned to you:

                      { "_id": "5c40ec28c44fce70cc7bf89f", "name": "Mosh Hamedani", "email":
                      "programmingwithmosh@gmail.com", "password": "12345", "__v": 0 }

                      When registering a new user it isn't ideal that we are returning their
                      password in the response above to the client. We will look at that in the next
                      lecture.

                      If we post again with the same values we should receive the following error
                      message (along with 400 bad request):

                      User already registered.

                      <h3>127 - Using Lodash</h3>

                      So, back in our post method, we want to modify the response to our client. So
                      there are two options here. One approach is to send a custom object like this:

                      res.send({ name: user.name, email: user.email });

                      This way we can exclude the password and the version properties. This approach
                      is perfectly fine but in this lecture we will introduce you to a useful
                      library that gives you alot of utility functions for working with objects. If
                      you are an experienced JavaScript developer you'll probably know what I'm
                      talking about - lodash. This is the second option.

                      lo-dash is basically the optimized version of underscore. Underscore has been
                      around for a long time and has a lot of utility functions for working with
                      objects, strings, arrays and so on.

                      If you look in the documentation, you can see all the utility function that we
                      have for working with arrays, numbers, strings, objects and so on. So lodash
                      is extremely powerful and in this lecture we will look at how to use it in
                      your Node applications.

                      Install lodash

                      npm i lodash

                      So in the users module we need to install lodash:

                      const _ = require('lodash');

                      By convention we assign this to a constant called _ because it is short and
                      clean. The underscore object has a utility method called pick:

                      _.pick(user, ['name', 'email']);

                      We pass the pick method an object, user, and then pass an array of properties
                      in the that object that we want to pick. This will return a new object with
                      only those properties.

                      Instead of manually repeating user. when we send the response:

                      res.send({ name: user.name, email: user.email });

                      We can use the pick method:

                      res.send( _.pick(user, ['id', ''name', 'email']) );

                      We have also included the id property in the example above. We can also modify
                      the code when setting up the new user object.

                      user = new User( _.pick(req.body, ['name', 'email', 'password']));

                      Now here we might 50 properties. A malicious user may send us properties to be
                      stored in the database. We only want to hand pick a few of these so in the
                      example above we specify name, email and password.

                      So we create the user, save it, then return it to the client.

                      Test the application in postman. Send a new post request to the server and you
                      should see the following object in the response:

                      { "id": "5c40f89510d6601e481f70c0", "name": "Mosh Hamedani", "email":
                      "programmingwithmosh10@gmail.com" }

                      Which contains only id, name and email. Now in all these requests so far we
                      have sent really simple passwords. If you want to enforce password complexity
                      there is an npm package built on top of Joi called Joi password complexity.

                      You can use this library to configure an object that determins the password
                      complexity in your application:

                      const complexityOptions = { min: 10, max: 30, lowerCase: 1, upperCase: 1,
                      numeric: 1, symbol: 1, requirementCount: 2, }

                      As it stands our new api endpoint is storing passwords in plain text which is
                      very bad. This will be addressed in the next lecture where we will examine
                      password hashing

                      <h3>128 - Hashing Passwords</h3>

                      In this lecture we will look at how to hash passwords using a very popular
                      library called bcrypt:

                      npm i bcrypt

                      Create a playground file to learn how to use the bcrypt library called
                      hash.js. Load bcrypt and store it in a constant:

                      const bcrypt = require('bcrypt');

                      To hash a password we need a salt. What is a salt? Well imagine our password
                      is:

                      1234

                      When we hash that let's imagine we get a string like this:

                      1234 -> abcd

                      The hashing algorithm is one way so if we have abcd we cannot decrypt this and
                      get 1234. From a security point of view that is great. If a hacker looks at
                      out database he or she cannot decrypt these hashed passwords. However they can
                      compile a list of popular passwords and hash them. They can then look at the
                      database of our application, find the hashed password, and then they know that
                      abcd represents 1234. So that's why we need a salt.

                      A salt is basically a random string that is added before or after this
                      password, so the resulting hash password will be different each time based on
                      the salt used. Let's see this in action:

                      bcrypt.genSalt();

                      Note that this method has two version. The first one is asynchronous, the
                      second one is synchronous. As a best practice you should always use
                      asynchronous methods because as I told you at the beginning of the course in
                      Node applications we have a single thread. We don't want to keep that thread
                      busy because then we can't server other clients.

                      So we call genSalt and as an argument we pass the number of rounds that we
                      want to run the algorithm to generate the salt. The higher the number, the
                      longer it's going to take to generate the salt. Also, the salt will be more
                      complex and harder to break. So the default value is 10 we'll use that.

                      bcrypt.genSalt(10);

                      Because this is an asynchronous method, we can either pass a callback here,
                      and that's what you see in the official documentation as well as a lot of
                      tutorial videos on the web. But this method also has an overload that returns
                      a promise. So, instead of passing a callback we get a promise, await it and
                      then get the salt:

                      const salt = await bcrypt.genSalt(10);

                      Now we need to wrap this in an async function like run:

                      async function run() { const salt = await bcrypt.genSalt(10);
                      console.log(salt); }

                      run();

                      We log the salt to the console and finally we call the run function. Run the
                      application:

                      $2b$10$yAVPxjSIzXXNTR8R37CM3O

                      So this is an example of a Salt. We can see the number of rounds we use
                      included in the salt (10):

                      $2b$10$

                      So here we have a long random string that is included as part of hashing our
                      password. With this, every time we hash our password with a new salt, we get a
                      different result.

                      Now that we have a salt we can hash our password:

                      const hashed = await bcrypt.hash('1234', salt);

                      We use the hash method of the bcrypt object, we pass the password 1234 through
                      as the first argument, the second argument is our salt. You can pass a
                      callback through as the third argument but we are not going to use this.
                      Instead we are going to get the promise that is returned.

                      So we await the promise and get the hashed password. So now, let's log this on
                      the console as well:

                      console.log(hashed);

                      Run the application:

                      $2b$10$HiiGktgLBfQe.ZBlzV.Vzu
                      $2b$10$HiiGktgLBfQe.ZBlzV.VzujY/HM0inkT9qHxgUhVFsmp1OV/ALNy6

                      On the first line we have our salt, on the second line we can see the salt as
                      well - so the salt is included in the hashed password. The reason this is
                      included is that later when we want to authenticate the user we want to
                      validate their username and password. So there the user sends the password in
                      plain text, we need to hash it again, but we need to have the original salt
                      that was used to generate this hash. So during comparing the plain text
                      password, with the hashed password, bcrypt needs to know the original salt
                      that was used to hash the password.

                      So now we know how bcrypt works let's put these two lines in our post route
                      handler:

                      const salt = await bcrypt.genSalt(10); user.password = await
                      bcrypt.hash(user.password, salt);

                      Instead of 1234 we use user.password - the plain text password. So we hash it
                      with the salt then reset it by assigning to it. Finally we save the user to
                      the database:

                      await user.save();

                      We also need to import bcrypt:

                      const bcrypt = require('bcrypt');

                      In Compass delete the users collection because all the user documents so far
                      contain plain text passwords. Run the application and send a new post request
                      in postman:

                      { "id": "5c41b11db5aa91409489159f", "name": "Mosh Hamedani", "email":
                      "programmingwithmosh10@gmail.com" }

                      So here we have a new user. Refresh the list in compass and you should see the
                      new user with a hashed password:

                      fig xx-xx

                      So we have now implemented the register new user endpoint.

                      <h3>129 Authenticating Users</h3>

                      In the routes folder add a new file called auth.js. Copy and paste all the
                      code from users.js to auth.js.

                      Go to index.js and import the module:

                      const auth = require('./routes/auth');

                      We tell express to use the new route:

                      app.use('/api/auth', auth);

                      So, if we have any requests for the /api/auth endpoint or any of it's child
                      endpoints we are going to delegate this to the auth router.

                      Now, back in the auth module on the top, first we have to validate the body of
                      the request. But the validate function we have here:

                      const { error } = validate(req.body);

                      This is the one that we imported from our user module:

                      const {User, validate} = require('../models/user');

                      So this is validating that in the body of the request we have three
                      properties: - name - email - password

                      In a real world application you might have other properties as part of
                      registering a user. This validate function is for validating a new user, it's
                      not for validating the email and password that we expect at this endpoint. So
                      here we need a different validate function. So we remove the validate function
                      that we were importing:

                      const {User} = require('../models/user');

                      And define a separate validate function in the auth module. Again, to save
                      time, we can copy our validate function from the user module to the auth
                      module and modify it:

                      function validate(req) { const schema = { email:
                      Joi.string().min(5).max(255).required().email(), password:
                      Joi.string().min(5).max(255).required() };

                      return Joi.validate(req, schema); }

                      We renamed the function to validate and changed the parameter to req. For this
                      schema object we need only two properties - email and password so we also
                      deleted the name.

                      Now, back in our route handler, this is our first validation:

                      const { error } = validate(req.body);

                      Next we need to make sure that we do have a user with a given email so we load
                      the user:

                      let user = await User.findOne({ email: req.body.email });

                      If we don't have the user(we add a NOT ! to the expression) we should return a
                      400 bad request and send a message - "Invalid email or password".

                      if (!user) return res.status(400).send('Invalid email or password.');

                      Note that we don't send a error 404, which means not found, because we don't
                      want to tell the client why the authentication failed. We don't want to tell
                      if the email is incorrect or the password - so we don't want to say "We dont
                      have a user with the given email". We just tell the client that this is a bad
                      request, it doesn't have the right data to be processed. So this is for
                      validating the username or email. Next we need to validate the password. For
                      that we need to use bcrypt.

                      So let's delete all this code here:

                      user = new User(_.pick(req.body, ['name', 'email', 'password'])); const salt =
                      await bcrypt.genSalt(10); user.password = await bcrypt.hash(user.password,
                      salt); await user.save();

                      and add a call to the compare method of the bcrypt object:

                      const validPassword = await bcrypt.compare(req.body.password, user.password);

                      We use the compare method to compare the plain text password with our hashed
                      password. Our plain text password is in req.body.password and our hash
                      password is in user.password. As you saw earlier the hash password does
                      include the salt. So when we call the compare method bcrypt is going to get
                      that salt and use it to rehash this plain text password. If they are equal
                      then this will return true. We await the promise and store the result in
                      validPassword.

                      If the password is not valid:

                      if(!validPassword) return res.status(400).send('Invalid email or password.');

                      We return a 400 error with the deliberately vague message.

                      Finally, if we get to this point, then we have a valid login. So for now, I
                      just want to send a simple true value to the client:

                      res.send(true);

                      <h3>130 - Testing the Authentication</h3>

                      So, for now, let's test this new endpoint back in Postman. We can modify the
                      request we had for creating new users. So to save time we can save it as let's
                      say Register User and Create a new collection to put it in called Vidly. In
                      the future we can use Register User instead of opening a new tab, fill out the
                      details and so on.

                      Open a new tab and create a post request to test our authentication endpoint:

                      http://localhost:3000/api/auth

                      In the body of the request we are going to send a Json object:

                      { "email": "programmingwithmosh10@gmail.com", "password": "12345" }

                      If your application hangs it might be that we forgot to import Joi at the top
                      of our auth module:

                      const Joi = require('joi');

                      Send the request again you get a status 200 with a response of true.

                      If we change the password to an invalid value:

                      { "email": "programmingwithmosh10@gmail.com", "password": "123456" }

                      Send the request and you get a status 400 Bad Request with a message of
                      "Invalid email or password"

                      If we send a valid password but change the email so that it is invalid:

                      { "email": "programmingwithmosh101@gmail.com", "password": "12345" }

                      Again we get a status 400 Bad Request with the same generic message.

                      <h3>131 - Json Web Tokens</h3>

                      So we now have an endpoint for authenticating users. Now we need to modify the
                      response that we return so that instead of returning a true value we return a
                      JSon web token. A Json web token is basically a long string that identifies a
                      user. As a metaphor you can think of it as you drivers license or your
                      passport.

                      So when the user logs in on the server we generate the Json web token:

                      fig xx-xx

                      We give it to the client and then tell them - hey next time you want to come
                      back here and call one of our API endpoints you need to show your passport,
                      you need to show your drivers license. So on the client we need to store this
                      Json web token which is a long string, so we can send it back to the server
                      for future API calls. Now the client can be a web application or a mobile
                      application.

                      If it's a web application, e.g. Angular or React you can use local storage.
                      This is special storage space that is available in every browser. If you're
                      building a mobile app, you have a similar option depending on what platform
                      you use.

                      So now, let me show you an example of a Json web token. Head over to jwt.io.
                      On this website we have a debugger for working with Json web tokens:

                      fig xx-xx

                      In the encoded section you can see a real example of a Json web token. The
                      long string that you see in the encoded section represents a Json object. When
                      this is decoded we will get a Json object. You can see that this string has
                      three parts - each part is color coded.

                      The first part is red, the second purple and the third blue. On the right side
                      you can see the string decoded. The red part is the header of the Json web
                      token. In this header we have two properties. One is alg which is short for
                      algorithm, that determines the algorithm used for encoding this token. The
                      other is type which has a value of JWT - Json Web Token. We never have to
                      worry about this header it's just a standard. What matters to us is the second
                      part - the Payload which is the purple part.

                      So here we have a Json object with three properties:

                      - sub is like a user id - name - admin

                      Now the payload that you see:

                      { "sub": "1234567890", "name": "Mosh Hamedani", "admin": true }

                      is different from the payload I have here, because I modified the Json web
                      token that is on this website. So I generated a custom web token and put it
                      here. What I want to point out here is that this payload:

                      { "sub": "1234567890", "name": "Mosh Hamedani", "admin": true }

                      include public properties about the user just like on your passport you have
                      some properties about yourself like your name, dob, place of birth etc. We
                      have the same exact concept in a Json web token. We can include a few basic
                      public properties about a user and with this every time we send a token from
                      the client to the server we can easily extract the user id from the payload.

                      If we need to know the name of the user then we can simply extract that as
                      well. We don't have to query the database, send the id to get a user object
                      and then extract the name property.

                      By the same token, if you want to know if the user is an admin user or not you
                      can include that here:

                      { "sub": "1234567890", "name": "Mosh Hamedani", "admin": true }

                      Again we don't have to send an extra query to the database, to see if the user
                      with the given id is admin or not.

                      You might be concerned about this approach from a security point of view,
                      because you may think that anyone can simply set this admin property for
                      themselves to true and then they will be treated as admin on the server.
                      That's not how Json web tokens work.

                      The third part of this Json Web Token, in blue, is a digital signature. This
                      digital signature is created based on the content of the Json web token along
                      with the secret or private key. This secret or private key is only available
                      on the server.

                      So if a malicious user gets the Json web token and modifies the admin property
                      the digital signature will be invalid because the content of the Json web
                      token is modified. Now we need a new digital signature but the hacker cannot
                      generate this digital signature because they will need the private key, which
                      is only available on the server. If they don't have access to the server they
                      cannot create a valid digital signature, and when they send this new tampered
                      Json Web Token to the server it will be declined. The server will say this is
                      not a valid Json Web Token.

                      So this is how Json Web Tokens work.

                      <h3>132 - Generating Authentication Tokens</h3>

                      If you look at the libraries on the jwt.io website you can see we have various
                      libraries for working with Json Web Tokens for different platforms - .Net,
                      Python, Node, etc.

                      Back in the terminal install jsonwebtoken:

                      npm i jsonwebtoken

                      In the auth module, before return the response we need to create a new Json
                      Web Token. First we need to import the jsonwebtoken module:

                      const jwt = require('jsonwebtoken');

                      Now, back in our route handler, we call the sign method of the jwt object:

                      const token = jwt.sign({ _id: user._id}, 'jwtPrivateKey');

                      The first argument is a payload which can be a simple string or an object. The
                      properties we add to the object are entirely up to us. So in our application
                      for now, I want the payload of our Json web tokens be an object with only one
                      property: _id.

                      The second argument is a secret or private key. This private key is used to
                      create the digital signature. For now we hard code the private key. You would
                      not do this in a real world application, you should not store your secrets in
                      your source code. Later we're going to extract this and put it in an
                      environment variable. You can use any string here - it doesn't have to be
                      jwtPrivateKey.

                      As a result of calling the sign method we will get a token which we store in a
                      constant called token.

                      Finally we return this token to the client:

                      res.send(token);

                      To test this send a post request with a valid email and password from Postman
                      to our authentication endpoint. You should receive a response containing a
                      Json web token. Copy this and then in jwt.io in the debugger paste it in:

                      fig xx-xx

                      So now you can see the payload of our Json web token:

                      { "_id": "5c4235f7c157933a98284ac4", "iat": 1547850077 }

                      We have our _id property which we set (that's the object id for a MongoDB
                      document). You also have iat, which is the time the token was created. We can
                      use this to determine the age of a JWT.

                      <h3>133 - Storing Secrets in Environment Variables</h3>

                      Earlier in the course, when I was talking about express advanced topics, I
                      introduced you to Node package called config. We use this package to store the
                      configuration files of our application in Json files or environment variables.

                      In this lecture we are going to take this private key out:

                      const token = jwt.sign({ _id: user._id}, 'jwtPrivateKey');

                      and store it in an environment variable because, as I told you before, you
                      should never store secrets in your code base. Otherwise these secrets are
                      visible to anyone who as access to your source code. So, back in the terminal,
                      let's install the config module:

                      npm i config


                      Back in the code create a new folder called config and in that folder create a
                      file called default.json to store the default configuration.

                      Add the following simple Json object to this file:

                      { "jwtPrivateKey": "" }

                      We just add one setting. We set this to an empty string, we don't specify the
                      actual value. Here we're just defining a template for all the settings in our
                      application.

                      Create another file in the config folder called
                      custom-environment-variables.json So, as we discussed before, in this file we
                      specify the mapping between our application settings and our environment
                      variables. So copy the Json object from default.json into
                      custom-environment-variables.json. We also map the setting to an environment
                      variable called jwtPrivateKey:

                      { "jwtPrivateKey": "vidly_jwtPrivateKey" }

                      As a best practice, as discussed before, it is better to prefix this with an
                      application name so you don't end up one application setting overwriting
                      another application setting. So we use vidly_jwtPrivateKey.

                      Go back to auth.js module where we are currently referencing the secret:

                      const token = jwt.sign({ _id: user._id}, 'jwtPrivateKey');

                      We are gong to replace this with a call to config.get method:

                      const config = require('config');

                      Back in the post method we call config.gert and passw the name of our
                      application setting:

                      const token = jwt.sign({ _id: user._id}, config.get('jwtPrivateKey'));

                      That is not a secret it's the name of our application setting. The actual
                      value or secret will be in an environment variable.

                      One last change, in index.js. When the application starts we want to make sure
                      that this environment variable is set. Otherwise we need to terminate the
                      application because our authentication endpoint cannot function properly

                      So, at the top of the file, we load the config module

                      const config = require('config');

                      We use the config.get method again:

                      if(!config.get('jwtPrivateKey')) { console.error('FATAL ERROR: jwtPrivateKey
                      is not defined.'); process.exit(1); }

                      If the environment variable is not defined we log a fatal error and then exit
                      the process. Earlier you learned about the process object. This is one of the
                      global objects in Node. Here we have a method called exit to which we supply a
                      code. 0 indicates success. Anything but 0 indicates failure. Often we use
                      exit(1) if you want to exit the process in case of an error.

                      So, at this point, we have not set the environment variable. Let's run the
                      application and see what happens:

                      FATAL ERROR: jwtPrivateKey is not defined. [nodemon] app crashed - waiting for
                      file changes before starting...

                      You might think the application is still running because nodemon has not
                      terminated. But if you go to postman and send an http request to the
                      application, you will see our application is not responding.

                      If the application crashes nodemon continues to run. To demonstrate use node
                      to run the application instead:

                      node index.js

                      You receive the same error:

                      FATAL ERROR: jwtPrivateKey is not defined.

                      but node terminates and we are back in the terminal.

                      Now let's set the environment variable. As discussed before on Mac you use
                      export on Windows you use set.

                      I set the environment variable on my Windows Machines to the following:
                      vidly_jwtPrivateKey myinSecureKey

                      If you back to postman and send another request to login you should see a
                      valid Json web token that is signed with a private key that is stored in an
                      environment variable:

                      eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YzQyMzVmN2MxNTc5MzNhOTgyODRhYzQiLCJpYXQiOjE1NDc4OTE5NTR9.xROPzBJyEB2VkHTGgzF9lHM-ou0xnSuF0CCt40I-YG8

                      View Environment Variables from the Command Line

                      SET View all. SET prefix View all variables with names starting with prefix.

                      NOTE - doesn't seem to work from terminal in Visual Studio Code

                      <h3>134 - Setting Response Headers</h3>

                      So, in the current implementation when the user logs in we generate a Json web
                      token and return it in the body of the response. Now let's take this
                      application to the next level. Let's imagine when the user registers we want
                      to assume they are logged in, so they don't have to login separately.

                      Of course this requirement does not apply to every application. Sometimes you
                      want to enforce the user to verify their email address, so after this sign off
                      you send them an email and they click a link. So the process is different.

                      However, in this course, let's imagine that vidly is an application that runs
                      locally in a video store. So, people who use this application are people who
                      work in this video store so you don't need to verify their email address. So
                      the first day that they join the store, they need to create an account and
                      boom they're logged in.

                      So let's go to the post method in our users module where we register a new
                      user If you look the response we're returning here, we're returning an object
                      with three properties:

                      res.send(_.pick(user, ['id', 'name', 'email'])

                      Now, we could add the Json web token as another property here, but that's a
                      bit ugly because it's not a property of a user. A better approach is to return
                      the Json web token in an http header.

                      So just like we have headers in our request we also have headers in our
                      response. So I'm going to go back to our Auth module and borrow this line of
                      code:

                      const token = jwt.sign({ _id: user._id}, config.get('jwtPrivateKey'));

                      for generating the token. Back in the users module before we send the response
                      to the client we generate the token then we call response.header:

                      res.header('x-auth-token', token).send(_.pick(user, ['id', 'name', 'email']));

                      The first argument is the name of the header. Because we are sending a custom
                      header, we set the header prefix to x- and then supply an arbitrary name like
                      auth-token. The second argument is our value, which in this case is our token.
                      With this simple change we set the header and then send the response to the
                      client.

                      On the line above we are using jwt:

                      const token = jwt.sign({ _id: user._id}, config.get('jwtPrivateKey'));

                      as well as the config module. So we need to import these at the top of our
                      module:

                      const jwt = require('jsonwebtoken'); const config = require('config');

                      Now let's test this:

                      nodemon

                      In postman find the Register user template and modify the email in the
                      req.body:

                      { "name": "Mosh Hamedani", "email": "notregisteredbefore1@gmail.com",
                      "password": "12345" }

                      Send this and you get the following response as you did before:

                      { "id": "5c43208d29738a3c10b21544", "name": "Mosh Hamedani", "email":
                      "notregisteredbefore1@gmail.com" }

                      Look in the headers tab and you should see a new header:

                      x-auth-token
                      eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YzQzMjI2ZWIwMTE2ZDI2ODA1NmEyMjMiLCJpYXQiOjE1NDc5MDM1OTh9.eRdcIsY-G8bv04NNhhPts0QYmsSHnTAdaKxzSlPG0oE

                      This is set to our Json token. So in our client app, when we register the user
                      we can read this header, we can store this Json web token, on the client, and
                      next time we go to make an API call we can send this to the server.

                      <h3>135 - Encapsulating Logic in Mongoose Modules</h3>

                      Now there is a problem in our current implementation. In the users module this
                      is how we generate a Json web token:

                      const token = jwt.sign({ _id: user._id}, config.get('jwtPrivateKey'));

                      We have the exact same code in the auth module:

                      const token = jwt.sign({ _id: user._id}, config.get('jwtPrivateKey'));

                      Look at the payload of this Json object - currently we only have the id
                      property. Chances are we're going to add another property in this payload -
                      maybe the name of the user, maybe their email address, maybe their role,
                      perhaps you want to know if they are an admin user or not. With the current
                      implementation every time we want to change this payload we have to go to the
                      other module and make the exact same change. In this lecture we will examine
                      how to encapsulate this logic in a single place.

                      Now, where should we move this logic to? An amateur programmer may think okay,
                      I will create a function like this:

                      function generateAuthenticationToken() {

                      }

                      Put this function somewhere that we can reuse, maybe in another module, that
                      we can import in both auth and user modules, and with this we have the logic
                      in a single place. Well, that is true, it works but with this approach you
                      will end up with a lot of functions hanging around all over the place.

                      In object oriented programming we have a principle called information expert
                      principle. That means an object that has enough information and is an expert
                      in a given area should be responsible for making decisions and performing
                      tasks.

                      As a real world example, think of a chef. A chef has the knowledge of cooking.
                      That's why the act of cooking in a restaurant is done by the chef, not by the
                      waiter. The waiter doesn't have the right knowledge or information about
                      cooking at a restaurant. So if chef is an object then we leave the actual
                      cooking to the chef.

                      Take this principle an apply it in this code. So here:

                      const token = jwt.sign({ _id: user._id}, config.get('jwtPrivateKey'));

                      as part of creating the Json web token, in the payload, we need the id of the
                      user. Tomorrow we may need the name of the user or their email. All this
                      information is encapsulated where? In the user object. So it's the user object
                      that should be responsible for generating the authentication token.

                      So the generateAuthenticationToken function we described above should not be
                      hanging somewhere in a module, that should be a method in the user object. So
                      we need to add the generateAuthenticationToken method to the user object that
                      we load from the database:

                      const token = user.generateAuthenticationToken();

                      This will give us our token. How can we add this? We need to go back to our
                      user module where we defined our user model and make a simple change. So
                      here's our user model:

                      const User = mongoose.model('User', new mongoose.Schema({ name: { type:
                      String, required: true, minlength: 5, maxlength: 50 }, email: { type: String,
                      required: true, minlength: 5, maxlength: 255, unique: true }, password: {
                      type: String, required: true, minlength: 5, maxlength: 1024 } }));

                      We need to extract the definition of this schema and put it in a separate
                      constant because we're going to work with that separately. So extract the
                      schema code from the call to mongoose.model:

                      const userSchema = new mongoose.Schema({ name: { type: String, required: true,
                      minlength: 5, maxlength: 50 }, email: { type: String, required: true,
                      minlength: 5, maxlength: 255, unique: true }, password: { type: String,
                      required: true, minlength: 5, maxlength: 1024 } });

                      And now add the following code to create the user model:

                      const User = mongoose.model('User', userSchema);

                      Now we want to add the generateAuthToken method to this schema:

                      userSchema.methods.generateAuthToken = function() {}

                      userSchema.methods returns an object to which you can add additional key value
                      pairs. So we add a key: generateAuthToken which we set to a function.

                      When we do this, our use object will have a method called generateAuthToken.
                      In this function we can have parameters. So if you have a parameter then when
                      calling this method we can pass arguments. In this, we don't need any
                      parameters. So, let's cut the logic for generating the token from auth.js:

                      const token = jwt.sign({ _id: user._id}, config.get('jwtPrivateKey'));

                      and paste it into our generateAuthToken method in the user module. So in the
                      payload:

                      { _id: user._id}

                      we need the id of the user. How do we get that? Well, now our
                      generateAuthToken method is part of the user object so in order to reference
                      the object itself we replace user with this:

                      { _id: this._id}

                      Remember using this means we should use the regular function syntax, you
                      cannot use an arrow function:

                      userSchema.methods.generateAuthToken = () => { const token = jwt.sign({ _id:
                      user._id}, config.get('jwtPrivateKey')); }

                      because, as discussed before, arrow function don't have their own this object.
                      this in an arrow function references the calling function.

                      Typically we use arrow function for standalone function. If you want to create
                      a method that is part of an object you should not use an arrow function.

                      So we have the token, you can finally return the token:

                      userSchema.methods.generateAuthToken = function() { const token = jwt.sign({
                      _id: user._id}, config.get('jwtPrivateKey')); return token; }

                      Back in the auth module we generate the token:

                      const token = user.generateAuthToken();

                      and send it to the user:

                      res.send(token);

                      We need to make the same change in our users module.

                      Remove the require statements for config and jwt from the auth module:

                      const config = require('config'); const jwt = require('jsonwebtoken');

                      and add them to the top of the user module. Test the application by
                      registering a new user in Postman:

                      You should see the following in the body of the response:

                      { "id": "5c434756a5687a327067fc8c", "name": "Mosh Hamedani", "email":
                      "notregisteredbefore6@gmail.com" }

                      and our authentication should be visible in the headers section:

                      x-auth-token
                      eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YzQzNDc1NmE1Njg3YTMyNzA2N2ZjOGMiLCJpYXQiOjE1NDc5MTMwNDd9.O8lzuUh_bNumSsmrRZozQB2zRIazNYRJlgH9ZLCYVng

                      <h3>136 - Authorization Middleware</h3>

                      So at the beginning of this section we decided to protect operations that
                      modify data and only make them available to users that have authenticated.

                      For example, in genres.js the post endpoint that creates a new genre should
                      only be available to authenticated users:

                      router.post('/', async (req, res) => { const { error } = validate(req.body);
                      if (error) return res.status(400).send(error.details[0].message);

                      let genre = new Genre({ name: req.body.name }); genre = await genre.save();

                      res.send(genre); });

                      We can enforce this with some logic that reads the req header:

                      const token = req.header('x-auth-token');

                      The request object has a method called header to which we supply the name of
                      the header (x-auth-token). We expect a JWT stored in this header so we store
                      it in token.

                      Next we validate the token. If the token is valid then we give access to the
                      api endpoint otherwise we return a response code 401 (the client doesnt have
                      the authentcation credentials to access this resource):

                      const token = req.header('x-auth-token'); res.status(401);

                      We don't want to repeat this logic in every route handler that needs to modify
                      data. So we need to put this logic in a middleware function (which we
                      discussed back in the section Express - Advanced Topics)

                      So we put this logic in a middleware function and then we can apply that
                      function in route handlers that need to modify data.

                      First add a new folder called middleware then a file called auth.js

                      Add a function to this file called auth which accepts three parameters:

                      function auth(req, res, next)

                      Next is used to pass control to the next middleware function in the request
                      processing pipeline. If this concept feels unfamiliar to you then go back to
                      the section called express admin topics, because we explored middleware
                      functions in detail.

                      In the body of the function implement logic to attempt to get the token. If we
                      don't have a token then we return a 401 response with a message:

                      function auth(req, res, next) { const token = req.header('x-auth-token');
                      if(!token) res.status(401).send('Access denied. No token provided'); }

                      This helps the client to figure out why they cannot access this resource. If
                      there is a token we need to verify that it is valid using JWT module. On the
                      top of the file import jsonwebtoken:

                      const jwt = require('jsonwebtoken');

                      Next call the verify method passing the token as the first argument and the
                      private key for decoding the token as the second:

                      const decoded = jwt.verify(token, config.get('jwtPrivateKey'));

                      For the above logic to work you will need to import the config module:

                      const config = require('config');

                      Now we call jwt.verify:

                      const decoded = jwt.verify(token, config.get('jwtPrivateKey'));

                      As the first argument we pass a token, and as the second argument we pass the
                      private key for decoding this token. So, because we store that private key in
                      an environment variable, we need to use the config module to read it. Add a
                      require statement for config at the top of the file:

                      const config = require('config');

                      If the supplied token is valid the verify method will return the decoded
                      payload which we assign to const called decoded.

                      However if the token is not valid the verify method will throw an exception.
                      We can catch this exception and return a 400 response - bad request:

                      try { const decoded = jwt.verify(token, config.get('jwtPrivateKey')); }
                      catch(ex) { res.status(400).send('Invalid token.'); }

                      Again, with this error message, we can troubleshoot the authentication issues.
                      So if I'm the client I cannot access a given API endpoint, we look at the
                      error message, okay we realize we sent an invalid token. Then we look at the
                      logic on the client where we get teh token and send it to the server. So this
                      is our catch block.

                      Back in the try block we add our decoded payload to our req:

                      req.user = decoded;

                      We add the user property to our request object and set this to decoded. This
                      is different to earlier when we only put the user _id property in the payload:

                      userSchema.methods.generateAuthToken = function() { const token = jwt.sign({
                      _id: user._id}, config.get('jwtPrivateKey')); return token; }

                      So we added a generateAuthToken method to our userSchema. We created a Json
                      web token and you can see the payload is just the user id. So when we decode
                      the jwt the object we get will just contain the id. We put this in the request
                      ( in auth.js) as a user object.

                      req.user = decoded;

                      So in our route handlers we can access request.user._id and so on.

                      Now in the try block we need to call next() to pass control to the next
                      middleware function in the request processing pipeline - in our case that's
                      our route handler so we call next:

                      next();

                      As we discussed before, in middleware functions, we either terminate the
                      request/ response life cycle or pass control to the next middleware function.

                      There is a small issue with the code. In the case where we don't have a token
                      we send a status 401 to the client but we should also make sure that we exit
                      from the function:

                      if(!token) return res.status(401).send('Access denied. No token provided');

                      The last thing to do is export the auth function:

                      module.exports = auth;

                      Alternatively we can make this code more concise by exporting the function
                      directly instead:

                      module.exports = function (req, res, next) {}

                      <h3>137 - Protecting Routes</h3>

                      So now that we have a middleware function we could either go to index.js where
                      we are already applying middleware functions:

                      app.use(express.json());

                      So could add our middleware function in index.js and then it would be executed
                      before every route handler. However, we don't want to do this because not all
                      api endpoints should be protected.

                      Some of our API endpoints should be public like registering a user or logging
                      in, or getting the list of genres or customers. So in this case we want to
                      apply this middleware function selectively to certain endpoints.

                      So, back to the genres module, here's our post route handler:

                      router.post('/', async (req, res) => {

                      The first argument is the route, the second is optionally middleware and the
                      third will be the actual route handler. So at the top of the genres file let's
                      import the middleware function:

                      const auth = require('../middleware/auth');

                      Now modify the post method to pass auth as a middleware function to be
                      executed before the other middleware function which in this case is our route
                      handler:

                      router.post('/', auth, async (req, res) => { }

                      Now let's test this in Postman by sending a POST request to the genres
                      endpoint (make sure you don't send the authentication token in the header):

                      http://localhost:3000/api/genres

                      You should receive response code 401 Unauthorized and the message:

                      Access denied. Not token provided

                      Now in the Headers tab of Postman provide an invalid token by entering
                      x-auth-token for the key and 1234 for the value.

                      You should receive response code 400 Bad Request and the message:

                      Invalid token.

                      Finally let's supply a valid token (copied from our POST User method that we
                      use to register a new user). Also make sure you supply a valid JSon object in
                      the body of the request.

                      You should receive response code 200 OK and the new JSON genre object in the
                      body of the response.

                      As an exercise apply this middleware function can now be applied to other
                      middleware functions that modify data.

                      <h3>138 - Getting the Current User</h3>

                      In a lot of applications there are times when we want to get information about
                      the currently logged in user.


                      So in this lecture we are going to add a new api endpoint to our users.js
                      module for getting the current user.

                      Currently we only have 1 route handle for creating a new user in the users.js
                      module.

                      We need to add another handler for get methods. Now here as the route or the
                      path we can pass a parameter:

                      router.get('/:id');

                      But this means the client should send the id to the server. Whilst this
                      approach is perfectly fine there are times, perhaps for security reasons, you
                      dont want to have an endpoint like this because then I can send the id of
                      another user and look at their account where there may be some information
                      that should not be visible publicly.

                      An often used approach to get information about the current user is to have an
                      api endpoint like me:

                      router.get('/me');

                      With this the client is not going to send the user id - it will be obtained
                      from the Json Web Token.

                      It is not possible to forge someone else's Json Web Token because in order to
                      do so I would need to create a new digital signature for that Json Web Token.

                      Now let's add the route handler:

                      router.get('/me', auth, async (req, res) => { const user = await
                      User.findById(req.user._id).select('-password'); res.send(user); });

                      The me api endpoint should only be available to authenticated users so we need
                      to import the auth middleware:

                      const auth = require('../middleware/auth');

                      To clarify here auth represents authorization NOT authentication because
                      authentication is about validating the username and password. In this case we
                      want to see if the user has permission to access a resource or not and that is
                      authorization.

                      So the auth middleware will prevent any requests that don't provide a valid
                      Json Web Token from executing the code in the route handler. The route handler
                      has access to the req.user object which means we can access it's _id property:

                      (req.user._id)

                      So instead of passing the _id property in the path or route we get it from
                      req.user._id which actually comes from our Json Web Token which makes it a
                      more secure approach.

                      We call User.findById excluding the password (we don't want to send this back
                      to the client):

                      const user = await User.findById(req.user._id).select('-password');

                      Finally you can send this user object to the client:

                      res.send(user);

                      Let's test in Postman using GET request:

                      http://localhost:3000/api/users/me

                      Initially dont specify a JWT and you will receive a 401 Unauthorized response
                      with the message:

                      Access denied. No token provided.

                      Now add a valid JWT (you can get this from Register User) in the header and
                      click send. You will recieve a 200 OK response and the user account details
                      that match the supplied JWT in the body of the response:

                      { "_id": "5ad5fd6ed4b65e98dee78835", "name": "Mosh Hamedani", "email":
                      "maxsage@gmail.com", "__v": 0 }

                      Note the password has been excluded.

                      <h3>139 - Logging Out Users</h3>

                      In our routes/auth module we defined this route:

                      router.post('/', async (req, res) => { }

                      For authenticating users. What about logging out users? Do we need a separate
                      route for that? No, because we are not storing this token:

                      const token = user.generateAuthToken();

                      anywhere in the server, so we don't need a separate route handler to delete
                      this token. So technically you need to implement the logging out feature on
                      the client not on the server.

                      So on the client application when the user wants to log out you simply delete
                      that token from the client. Now there are courses and tutorials that teach you
                      to store the token on the server in the database - this is very bad practice
                      because these tokens are like keys that give a client access to protected api
                      endpoints. If a hacker can get access to your database they can see all these
                      tokens for authenticated users - they don't even have to know the password for
                      a user. They can simply use one of the stored tokens to execute requests on
                      the behalf of a user.

                      So you should not store tokens in your database. If you really want to store
                      the token in the database make sure you encrypt it.

                      Storing a token in plain text in the database is like getting the passport or
                      drivers licenses of all the users, putting them in a central place, and then
                      anyone malicious or otherwise, who has access to the central place can simply
                      get the passport and drivers licenses and imitate other clients.

                      So, once again, do not store the tokens on the server. Store them on the
                      client. As a security best practice, whenever you are sending the token from
                      the client to the server, make sure to use https. So a hacker, sitting in the
                      middle, sniffing traffic cannot read the token sent from client to the server
                      because the data is encrypted.

                      <h3>140 - Role Based Authorization</h3>

                      So far we have implemented authentication and authorization successfully. Now
                      let's take this application to the next level. Let's imagine certain
                      operations such as deleting data can only be performed by admins.

                      Let's examine how to implement role based authourization.

                      In models/user.js examine the userSchema. Currently we have three properties:

                      - name - email - password

                      We need to add another property to the userSchema called isAdmin of type
                      Boolean:

                      isAdmin: Boolean

                      In MongoDB Compass make one of the users an admin by editing a document and
                      adding a field after password. Don't forget to change the default type from
                      string to Boolean. So, now we have a user that is an admin.

                      When they login we need to include the isAdmin property in the JWT payload so
                      next time the send this JWT to the server we can extract this property
                      directly from the token. We don't have to get the id, go into the database,
                      and see if you're an admin or not. Again, as discussed previously, with a
                      digital signature included in a Json web token, a malicious user cannot change
                      the value of isAdmin for their user account. If they make any changes, they
                      have to regenerate the digital signature - this requires knowing the private
                      key that we stored in an environment variable on the server.

                      Now back in the user model when we generate the token we want to add our new
                      isAdmin property in the payload:

                      const token = jwt.sign({ _id: this._id, isAdmin: this.isAdmin },
                      config.get('jwtPrivateKey'));

                      This is the benefit of encapsulating this logic inside the user object. It
                      means there is a single place that we need to modify. Previously we had this
                      logic in two different places - meaning we would have had to implement this
                      change twice.

                      Now on the server we need a new middleware function to check if the current
                      user is an admin or not. In the middleware folder and a new file called
                      admin.js with the following code:

                      module.exports = function(req, res, next) { }

                      We set module.exports to a middleware function that takes a request, a
                      response and a reference to the next middleware function in the request
                      processing pipeline. So here we're assuming this middleware function will be
                      executed after the authorisation middleware function. Our authorisation
                      middleware function sets req.user which means we can access that in our new
                      function:

                      module.exports = function(req, res, next) { if(!req.user.isAdmin) return
                      res.status(403).send('Access denied.'); }

                      If req.user.isAdmin is false we return response code 403 which means
                      forbidden. This is one of the areas that a lot of developers get wrong. So we
                      have:

                      401 Unauthorized - the user tries to access a protected resource without a
                      valid JWT 403 Forbidden - the user sends a valid JWT but they are not
                      authorized to access the resource (e.g. non-admin)


                      So if the user isAdmin we pass control to the next middleware function:

                      next();

                      Which in this case is the route handler. Now we are going to apply this
                      middleware function on one of our routes. In the delete api endpoint of genres
                      we pass two middleware functions using an array

                      router.delete('/:id', [auth, admin], async (req, res) => { }

                      The first one is auth and the second is admin. These middleware functions will
                      be executed in sequence. First auth - if the client sends a valid Json web
                      token, then we'll get to the second middleware function. If the user is an
                      admin then the third middleware function or route handler will be executed.
                      Import the admin middleware function at the top of genre.js:

                      const admin = require(''../middleware/admin');

                      <h3>141 - Testing the Authorization</h3>

                      So back in MongoDB Compass, go to the genres collection and copy a valid genre
                      id. In Postman send a delete request to:

                      http://localhost:5000/api/genres/5c43a8a94e22960a2c26ef3f

                      So initially I don't have a token.

                      We receive a response status 401 Unauthorized with the message:

                      Access denied. No token provided.

                      Next use Postman to login with a user that is not an admin and copy the
                      resulting JWT. You can verify that the user is not an admin using the debugger
                      at jwt.io - you should only see the _id and _iat properties . Let's verify
                      that this user cant delete genres.

                      You will receive a response status 403 Forbidden with the message:

                      Access denied

                      Now login at the auth endpoint with a user that IS NOT an admin:

                      http://localhost:3000/api/auth

                      In the response body you should receive a JWT:

                      eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE1NDc5OTM3NDd9.LHozVfSKCYNMdXoGnZ_qcDGqbjFjHp8RuSMolDd6Ahc

                      We can verify that this user is not an admin by going to JWT debugger (jwt.io)
                      and pasting the JWT into the encoded section:

                      fig xx-xx

                      If you check the payload you should see only the id property (and iat) we
                      don't have isAdmin. So, this user should not be able to delete a genre. We can
                      verify that by using Postman to send another delete request to the genres
                      endpoint:

                      http://localhost:5000/api/genres/5c43a8a94e22960a2c26ef3f

                      We add the x-auth-token to the headers (make sure you are in headers NOT
                      Params. Send this request and you should get 403 - forbidden with a message in
                      the body:

                      Access denied.

                      Now, in contrast, if we log in with a user that is an admin then we should be
                      able to delete the genre.

                      So now login at the auth endpoint with a user that IS an admin:

                      http://localhost:3000/api/auth

                      Copy the JWT (which is a little bit longer than previous JWT's) into JWT
                      debugger. If you check the payload then isAdmin should be set to true.

                      { "_id": "5c445adddfbdc04b04613d8a", "isAdmin": true, "iat": 1547994978 }

                      Next, copy and paste this JWT in the DELETE Genre request in Postman, hit Send
                      and you will receive a response status 200 OK and the deleted Genre object in
                      the body of the response:

                      { "_id": "5c43a8a94e22960a2c26ef3f", "name": "Griller", "__v": 0 }


                      One last thing before we finish the lecture. In this simple application we
                      have a single isAdmin property to determine if the user is an admin or not. In
                      your application you might have multiple roles:

                      admin moderator etc.

                      In that case you would need a property like roles:

                      isAdmin: Boolean, roles: []

                      This would be an array. This could contain strings or complex objects, that
                      really depends on the scope of your application. In a more advanced
                      application instead of managing roles you would manage operations, that is the
                      operations that the user is allowed to perform:

                      isAdmin: Boolean, roles: [], operations []

                      operations would be an array of complex objects. For example, for a given
                      user, we would say this user is allowed to delete genres, or create genres. So
                      you would control access at a more granular level. Now, irrespective or which
                      approach you choose, the big picture is still the same. You pass something
                      that determines the level of access of the user in the JWT that is generated
                      as part of authenticating the user. Then you would add middleware, where
                      currently we are just checking the value of this boolean property:

                      if(!req.user.isAdmin) return res.status(403).send('Access denied.');

                      In a more complex application we can look at the roles array or the operations
                      array. Based on that, you make a decision, you either decline access:

                      return res.status(403)

                      or grant it:

                      next();

                      <h3>142 - Recap</h3>

                      Authentication and Authorization ---------------------------------

                      So, in this section, you learned that:

                      - Authentication is the process of determining if the user is who he/she
                      claims to be. It involves validating their email/password. - Authorization is
                      the process of determining if the user has permission to perform a given
                      operation. - To hash passwords, use bcrypt:

                      Hashing passwords -----------------

                      const salt = await bcrypt.genSalt(10); const hashed = await
                      bcrypt.hash(1234, salt);

                      // Validating passwords const isValid = await bcrypt.compare(1234, hashed);

                      A JSON Web Token (JWT) is a JSON object encoded as a long string. We use them
                      to identify users. Its similar to a passport or drivers license. It includes
                      a few public properties about a user in its payload. These properties cannot
                      be tampered because doing so requires re-generating the digital signature.

                      When the user logs in, we generate a JWT on the server and return it to the
                      client. We store this token on the client and send it to the server every time
                      we need to call an API endpoint that is only accessible to authenticated
                      users.

                      To generate JSON Web Tokens in an Express app use jsonwebtoken package.

                      Generating a JWT ----------------

                      const jwt = require(jsonwebtoken); const token = jwt.sign({ _id: user._id},
                      privateKey);

                      Never store private keys and other secrets in your codebase. Store them in
                      environment variables. Use the config package to read application settings
                      stored in environment variables.

                      When appropriate, encapsulate logic in Mongoose models:

                      Adding a method to a Mongoose model ---------------------------=-------

                      userSchema.methods.generateAuthToken = function() { } const token =
                      user.generateAuthToken();

                      Implement authorization using a middleware function. Return a 401 error
                      (unauthorized) if the client doesnt send a valid token. Return 403
                      (forbidden) if the user provided a valid token but is not allowed to perform
                      the given operation.

                      You dont need to implement logging out on the server. Implement it on the
                      client by simply removing the JWT from the client.

                      Do not store a JWT in plain text in a database. This is similar to storing
                      users passports or drivers license in a room. Anyone who has access to that
                      room can steal these passports. Store JWTs on the client. If you have a strong
                      reason for storing them on the server, make sure to encrypt them before
                      storing them in a database.

                      <h3>143 - Introduction</h3>

                      In our current implementation of Vidly app, we have assumed an ideal world
                      where everything works successfully. However, in the real world, there are
                      always unexpected errors. For example, it is possible that our connection to
                      MongoDB drops out for whatever reason. So, as a best practice we should count
                      on these unexpected situations and handle them properly. This means we should:

                      - send a proper error message to the client - log the exception on the server

                      This means later we can look at the log, and see what the frequent issues are
                      and how we can improve the application.

                      Let's demonstrate with a real world scenario where the MongoDB server dies.
                      So, here in the terminal, we are running the application with nodemon:

                      [nodemon] 1.17.1 [nodemon] to restart at any time, enter `rs` [nodemon]
                      watching: *.* [nodemon] starting `node index.js` Listening on port 5000...
                      Connected to MongoDB...

                      and we also have another terminal window open running the Mongo Daemon:

                      2019-01-20T10:24:09.236-0800 I CONTROL [initandlisten] MongoDB starting :
                      pid=3236 port=27017 dbpath=C:\data\db\ 64-bit host=XPS15
                      2019-01-20T10:24:09.236-0800 I CONTROL [initandlisten] targetMinOS: Windows
                      7/Windows Server 2008 R2 2019-01-20T10:24:09.237-0800 I CONTROL
                      [initandlisten] db version v3.6.3

                      This is the background service that is running on port 27017:

                      2019-01-20T18:24:10.138+0000 I NETWORK [initandlisten] waiting for connections
                      on port 27017

                      In Postman we have a tab open to send a get request to api/genres:

                      http://localhost:3000/api/genres

                      Currently if we send this request we get a 200 response and some result(s)
                      displayed in the body of the response:

                      [ { "_id": "5c43a7aa7e7aa5349c1ca9f5", "name": "Griller", "__v": 0 }, { "_id":
                      "5c43a8f94e22960a2c26ef40", "name": "Griller", "__v": 0 }, { "_id":
                      "5c43a9e3a342de3bfc0b33a8", "name": "Griller", "__v": 0 } ]

                      Stop the process in mongoDB using Ctrl+C.

                      2019-01-20T19:02:09.938+0000 I CONTROL [consoleTerminate] shutting down with
                      code:12

                      Now, let's see what happens when we use postman to send the request one more
                      time. the Send button in postman should change to Sending... and after approx
                      30 seconds (although I got a message immediately saying "mongoError: Topology
                      was destroyed" meaning the connection was interrupted whilst MongoDB was being
                      written to) you will receive an error message in the terminal where your Node
                      application is running:

                      (node:1084) UnhandledPromiseRejectionWarning: MongoError: MongoNetworkError:
                      failed to reconnect after 30 attempts with interval 1000ms

                      By default, when you connect to MongoDB, if the connection cannot be
                      established, MongoDB driver will attempt to reconnect 30 times in 1 second
                      intervals. Look at the warning in the terminal:

                      DeprecationWarning: Unhandled promise rejections are deprecated. In the future
                      promise rejections that are not handled will terminate the Node.js process
                      with a non-zero exit code.

                      This means in future versions of Node the application will stop running if it
                      encounters an error like this and no further clients will be served. Now in
                      this particular demonstration, yes, I shut down our MongoDB server so it
                      wouldn't really matter if this process is live or not. But let's imagine in a
                      real world scenario is going down for, let's say, 1 minute. Then is

                      Imagine a scenario where our mongodb server is going to be shutdown for one
                      minute. With the current implementation our node process will terminate and
                      will not be able to server any other client even after mongodb restarts.

                      We need to properly hand these scenarios, and that's what you're going to
                      learn in this section.

                      <h3>144 - Handling Rejected Promises</h3>

                      Whenever you see unhandled promise rejection that means your using a promise
                      which means your dealing with asynchronous code that has thrown an error that
                      hasn't been handled properly In genres.js in the get route you can see the
                      find promise:

                      router.get('/', async (req, res) => { const genres = await
                      Genre.find().sort('name'); res.send(genres); });

                      Here we have a promise:

                      Genre.find().sort('name');

                      That is awaited here:

                      await Genre.find().sort('name');

                      There is currently no try/catch block in the code to handle rejected promises.

                      This implementation is the same as getting a promise, calling then but not
                      calling catch to handle rejections:

                      Genre.find() .then() .catch()

                      So if your using the promise syntax with then you should always call catch to
                      handle exceptions. If your using async and await you should always have
                      try/catch blocks.

                      So add a try catch block that responds with status 500 internal server error
                      and send a message:

                      try { const genres = await Genre.find().sort('name'); res.send(genres); }
                      catch (ex) { // Log the exception res.status(500).send('Something failed'); }

                      We will add logging later in this section. Start the mongo demon and then run
                      the vidly application, stop the mongo demon and then submit a get genres
                      request from postman

                      Now in Postman after about 30 seconds you should see a response status 500 and
                      the message:

                      Something failed.

                      Importantly if you look at the terminal window that you used to launch the
                      vidly application you should no longer see the
                      UnhandledPromiseRejectionWarning which will result in the termination of this
                      process in future version of node.

                      <h3>145 - Express Error Middleware</h3>

                      So, in the last lecture, we took the first step to handle errors properly. But
                      there is a problem in the current implementation. Let's say, tommorow, we need
                      to change the message sent to the client:

                      res.status(500).send('Something failed');

                      With the current implementation you have to go to every route handler where we
                      have used a try/catch block to modify the message. Also if you are performing
                      logging and further down the line you want to implement it slightly
                      differently again you will need to visit every route handler.

                      We want to move the error handling logic to somewhere central. Goto index.js
                      where the middleware is being registered. In express there is a special kind
                      of middleware function called error middleware. We register that middleware
                      function after all the existing middleware functions. So, after the other
                      app.use statements, we call app.use:

                      app.use(function(err, req, res,next){

                      });

                      Pass a middleware function with 3 parameters - request, response and next. We
                      also add the fourth argument here at the front. That's the exception or error
                      that we catch somewhere in the application.

                      Now, in this function, we add all the logic for handling errors in our
                      application Cut the logic from genres.js and paste it into the error
                      middleware function:

                      app.use(function(err, req, res, next){ // Log the exception
                      res.status(500).send('Something failed.'); })

                      Now back in the catch block in genres.js add the next parameter to pass
                      control to the next middleware function in the request processing pipeline. In
                      the catch block we also call next passing the exception as an argument:

                      router.get('/', async (req, res, next) => { try { const genres = await
                      Genre.find().sort('name'); res.send(genres); } catch(ex) { next(ex); } });

                      Now because in index.js we register the error middleware function AFTER all
                      the other middleware functions when we call next we will end up here:

                      function(err, req, res, next)

                      The first argument passed to this function will be the exception. This new
                      implementation gives us a single place to handle errors.

                      In a real world example the logic for logging an exception might be several
                      lines long. We don't really want to put this code in index.js which is really
                      for orchestration and high level arrangement. The details should be
                      encapsulated in a different modules. For this reason we will move this
                      middleware function to a separate module. We will add a new file called
                      error.js to the middleware folder and move the error handling and logging
                      function there:

                      module.exports = function(err, req, res, next) { // Log the exception
                      res.status(500).send('Something failed.'); }

                      Import the module in index.js

                      const error = require('./middleware/error');

                      Now modify the app.use statement to pass in the error function.

                      app.use(error);

                      NOTE that we don't call the function, we just pass a reference to it. Whilst
                      we have achieved a better design it is still necessary for us to wrap the
                      other endpoints in try/catch blocks. This is repetitive. In the next lecture
                      we will look at how to improve this implementation.

                      <h3>146 - Removing try/catch Blocks</h3>

                      So we still have a try/catch block in the genres get route handler. The
                      problem with this implementation is that we have to repeat this try/catch
                      block in every route handler. Also the try catch logic is adding noise to the
                      code which is distracting us from the logic that belongs to this route
                      handler.

                      Ideally we should move this high-level code somewhere else to a single
                      function:

                      function asyncMiddleware() { try { // ... } catch(ex) { next(ex); } }

                      So we define a function called asyncMiddleware with a try block that executes
                      some code which will vary depending on the route handler. Then we have the
                      catch block that takes an exception where we simply call next passing in the
                      exception.

                      Now what if we pass a function (our route handler function) as an argument to
                      the asyncMiddleware function? It means we can call the function in the try
                      block:

                      function asyncMiddleware (handler) { try { handler(); } catch(ex) { next(ex);
                      } }

                      This means we can simplify the code in the genres get route handler - we no
                      longer need the try block, the catch block and the next parameter:

                      router.get('/', async (req, res) => { const genres = await
                      Genre.find().sort('name'); res.send(genres); });

                      Look at the anonymous async function that you are passing in the code above.
                      Eventually we want to pass this function as an argument to the asyncMiddleware
                      function.

                      Because handler is an async function we should await it and mark the function
                      as async:

                      async function asyncMiddleware (handler) { try { await handler(); } catch(ex)
                      { next(ex); } }

                      Now modify the get route handler in genres so that for the second method we
                      call the asyncMiddleware function and pass the anonymous function that is
                      currently in the get route as an argument that we call handler:

                      router.get('/', auth, asyncMiddleware(async (req, res) => { const genres =
                      await Genre.find().sort('name'); res.send(genres); }));

                      There is a slight issue here - in the asyncMiddleware function the handler
                      function:

                      await handler();

                      That we are calling needs access to 2 arguments - the request and response.
                      You can see the anonymous function in the get route uses these parameters:

                      async(req, res)

                      So when calling it (as we do in asyncMiddleware) we should pass the req and
                      res objects:

                      await handler(req, res);

                      The issue we have here is that nowhere in the asyncMiddleware function have we
                      defined req, res and next. The only parameter in asyncMiddleware is a
                      parameter to another function which we call handler.

                      So the question remains - how do we get access to these three objects? Before
                      we discuss that question we need to investigate a deeper issue. In the current
                      implementation we are calling the asyncMiddleware function and passing the
                      handler as an argument:

                      asyncMiddleware(...handler code...)

                      So we are CALLING the function. However when defining an express route we are
                      not going to call our middleware or route handler functions - we simply pass a
                      reference to a function.

                      To clarify we will define another temporary route as an example(delete it
                      later):

                      router.get('/another', (req, res, next)) => { });

                      Here we are passing a route handler function that takes two arguments - req,
                      res and potentially next as well.

                      Note that in the code above we are passing a function reference. In other
                      words we are not calling the function and passing in arguments like this:

                      router.get('/another', (req, res, next)) => { }(arg1, arg2));

                      It's the express framework that calls the function and passes the arguments at
                      runtime. So the problem we have is that in the current implementation we are
                      calling asyncMiddleware we are not passing a reference to a function that
                      takes the req, res and next parameters. To overcome this issue we need to make
                      a small change to the asyncMiddleware function.

                      When we call the asyncMiddleware function we can return a route handler
                      function that looks like this:

                      (req, res, next) => {});

                      This will make the asyncMiddleware function like a factory function. We call
                      it and get a new function that is a route handler that looks like this:

                      (req, res, next) => {});

                      Express can call that and pass the req, res and next arguments at runtime. So
                      in the asynMiddleware function we need to return a route handler function:

                      async function asyncMiddleware(handler) { return (req, res, next) => {

                      }; }

                      Now we have access to the req, res and next arguments (Express is going to
                      pass this for us) So we can move the existing code inside the code block we
                      just created:

                      async function asynMiddleware(handler) { return (req, res, next) => { try {
                      await handler(req,res); } catch(ex) { next(ex); } }; }

                      Now in this function we are awaiting the call to the handler so we need to
                      mark the calling function as async:

                      return async (req, res, next) => {}

                      This means the asyncMiddleware function no longer needs to be marked as async
                      because nowhere in the asyncMiddleware are we awaiting a promise we are simply
                      returning a function.

                      To review - with this new implementation we have moved the try/catch block to
                      a single place. We no longer need to repeat it in each route handler.This
                      means the code in our route handlers will be more focused. We can see the
                      actual logic that belongs to the route handler.

                      We achieved this be defining the asyncMiddleware function that takes a
                      function reference called handler. When we call this function:

                      return async (req, res, next) => {}

                      So when we pass our original route handler here:

                      router.get('/', auth, asyncMiddleware(async (req, res) => { const genres =
                      await Genre.find().sort('name'); res.send(genres); }));

                      We are passing a function reference. We call that handler:

                      async function asyncMiddleware(handler)

                      When we call this function we return a standard express route handler:

                      return (req, res, next) => {

                      This route handler is an async function with three parameters in the body of
                      the function we have a try/catch block:

                      try { await handler(req,res); } catch(ex) { next(ex); }

                      In the try block we simply call the handler that we passed as an argument:

                      await handler(req, res)

                      Finally the asyncMiddleware function doesn't belong in the genres module so we
                      move it to a new file in the middleware folder called async.js and export the
                      function.

                      module.exports = function (handler) { return async (req, res, next) => { try {
                      await handler(req, res); } catch(ex) { next(ex); } }; }


                      Now in genre.js you will need to import the module:

                      const asyncMiddleware = require('../middleware/async');

                      Now with this new implementation we simply wrap each route handler with the
                      asyncMiddleware:

                      router.post('/', auth, asyncMiddleware(async (req, res) => { const { error } =
                      validate(req.body); if (error) return
                      res.status(400).send(error.details[0].message);

                      let genre = new Genre({ name: req.body.name }); genre = await genre.save();

                      res.send(genre); }));

                      So we call asyncMiddleware and pass the existing route handler code as an
                      argument.

                      <h3>147 - Express Async Errors</h3>

                      In the last lecture we defined the async middleware function. While the async
                      middleware function solves the problem of repetitive try/catch blocks the
                      issue we have is that we have to remember to call the asyncMiddleware function
                      every time. This also makes our code a little bit noisy.

                      In this lecture we will use an npm module to monkey patch (A monkey patch is a
                      way for a program to extend or modify supporting system software locally
                      (affecting only the running instance of the program) our route handlers at
                      runtime. So when we send a request to an endpoint that module will wrap our
                      route handler code inside something similar to the async function we created
                      in the last lecture.

                      So from the terminal in the vidly application run:

                      npm i express-async-errors@2.1.0

                      Next import the express-async-errors module into index.js:

                      require('express-async-errors');

                      That's all we have to do. We don't have to get the result and store it in a
                      constant.

                      Remove the call to asyncMiddleware from the route handlers that are currently
                      using it (genre GET and POST) and remove the require statement for
                      asyncMiddleware from the top of genres.js as well.

                      Now test by running mongod in the terminal, start the vidly application and
                      get all the genres in postman to check that endpoint is working.

                      Now stop mongodb and retry the get genres request in postman. After a fairly
                      long period of time you should receive a status 500 internal server error
                      along with the message:

                      Something failed

                      This verifies that the module we installed properly moved control from our
                      route handler to our error handling function.

                      Using express async error handling module is very easy and for this reason it
                      is my suggested approach for handling async errors in express route handlers.
                      However if this approach doesn't work for your application you can switch back
                      and use the asyncMiddleware function from the previous lecture.

                      <h3>148 - Logging Errors</h3>

                      So error.js is our current error middleware. Now, as discussed before, in
                      every enterprise application we need to log the exceptions that are thrown in
                      the application. Later on we can examine the log to see which areas of the
                      application can be improved.

                      In this lecture we will introduce a very popular logging library called
                      winston currently on version 2.4. Install winston in the vidly application:

                      npm i winston@2.4.0

                      In index.js load winston:

                      const winston = require('winston');

                      The constant winston is the default logger that is exported from this module.
                      We can also create a logger manually but using the default logger will be
                      sufficient for our application.

                      The logger object has what is known as a transport. A transport is essentially
                      a storage device for our logs and winston comes with several transports
                      built-in:

                      console - for logging messages to the console file - for logging to a file
                      http - for calling an http endpoint to log messages

                      There are also plugin npm modules to log messages in both MongoDB and CouchDB
                      as well as Redis and Loggly (a popular log analysis and monitoring service for
                      enterprise applications).

                      So this default logger that is exported from the winston module comes with a
                      transport for logging messages to the console but in this lecture we will add
                      another transport for logging messages to a file.

                      In index.js after the require statements add the following code:

                      winston.add(winston.transports.File, { filename: 'logfile.log' });

                      Now back in our error middleware we can log errors using winston. First import
                      winston:

                      const winston = require('winston');

                      In the error function add the following code:

                      winston.error(err.message, err);

                      The first argument is the logging level which determines the importance of the
                      error we are going to log - error The most severe logging message - warn A
                      warning - info For information (e.g. Connected to MongoDB) - verbose - debug -
                      silly

                      You can write the syntax differently to indicate the logging level with a
                      helper message:

                      winston.error(err.message, err);

                      The second parameter is optional metadata, so we can pass the err object and
                      every property in the err object will be available in the log. To demonstrate
                      let's throw an error in the get genres route handler:

                      throw new Error('Could not get the genres.');

                      So now in our current implementation the error middleware will catch that
                      error, log it using winston and return the response code 500 to the client.

                      So let's run the application and get genres in postman - you should see the
                      response code 500 - internal server error.

                      In the console you will see the error: Could not get the genres. You will also
                      see the stack trace below (which is part of the err object). So this is the
                      console transport which is configured on the default logger.

                      Now in our project explorer we should see a new file logfile.log which
                      contains a Json object with several properties:

                      {"level":"error","message":"Could not get the
                      genres.","timestamp":"2019-01-22T15:03:51.344Z"}

                      Message - Could not get the genres Stack - Represents the stack trace Level -
                      Set to error Timestapm - When the error occurred

                      So using the level property you could query the logfiles and extract only the
                      errors or only the information.

                      So this is the big picture. We simply call winston.error or one of the other
                      helper methods and, depending on the transports which we have configured,
                      winston will log the given message.

                      <h3>149 - Logging to MongoDB</h3>

                      Now let's look at how to log messages to mongodb. Install another winston
                      package:

                      npm i winston-mongodb@3.0.0

                      Back in index.js in the last version we added a file transport, this time
                      round we will add a mongodb transport.

                      After we load winston we need to load winston-mongodb:

                      require('winston-mongodb');

                      Here we don't care about what is exported from this module - we just need to
                      require it. Next add another transport for winston under the code for the file
                      transport:

                      winston.add(winston.transports.MongoDB, {db: 'mongodb://localhost/vidly'});

                      We pass an options object. There are a few properties here that you can see in
                      the documentation but we just set db: It is possible to seperate your logging
                      database and your application database but in this example we will keep
                      logging in the application database.

                      Next time there is another error in the application because we have added
                      another transport Winston will automatically store our error in mongoDB. So
                      let's run the application again and submit a get genres request in postman. If
                      you now look in MongoDBCompass if you refresh you should see a log collection
                      with one object:

                      _id: ObjectId("5c475a4128cb491d6c9ac25d") timestamp: 2019-01-22 18:00:33.365
                      level: "error" message:"Could not get the genres" meta: Object

                      You can see a timestamp, an error level, a message and a meta object. The meta
                      property is the second argument that we passed to the winston.error call in
                      error.js which was the err object.

                      The err object has a few properties (message, name, stacktrace) all of which
                      get stored in MongoDB.

                      So, in compass, if you expand the meta object you can see message, name, stack
                      etc. These are all the properties of the standard error object in JavaScript.

                      In the last lecture we talked about logging levels. When adding a transport we
                      can also set the logging levels on a per transport basis. For example, maybe
                      you only want to log errors to MongoDB and exclude info, verbose and all the
                      other logging levels.

                      To achieve this you would modify the options object in the call to winston.add
                      for the MongoDB transport by adding in a level property

                      winston.add(winston.transports.MongoDB, { db: 'mongodb://localhost/vidly',
                      level: 'error' });

                      If you were to set the level property to info you would receive info, warn and
                      error messages because warn and error are more severe than info:

                      error warn info verbose debug silly

                      Nothing beyond info will be logged in MongoDB

                      <h3>150 - Uncaught Exceptions</h3>

                      The error middleware that we have added only catches errors that happen as
                      part of the request processing pipeline. So this is particular to express. If
                      an error occurs outside of the context of express the error middleware will
                      not pick it up.

                      To demonstrate let's go back to index.js and after the code to for winston add
                      the the following code:

                      throw new Error('Something failed during startup.');

                      So the above error is thrown outside the context of processing a request -
                      outside the context of express. The process will crash and winston wont log
                      anything. To verify this, you can delete everything in logfile.log, save, and
                      run the application:

                      node index.js

                      In the terminal we see our error:

                      throw new Error('Something failed during startup');

                      If you check the logfile.log it will still be empty. So if you deployed this
                      application to production, it would fail and there is no way for you to know
                      what went wrong unless you have access to the console on the server. So in
                      this lecture we will examine how to properly handle unhandled exceptions in
                      node process. So, this is at a higher level, it is not tied to express.

                      Back in index.js earlier in the course you learned about the process object.
                      process is an event emitter which is an object which can emit or publish
                      events. It gives a method called on which you can use to subscribe or listen
                      to events.

                      In node there is a standard event called uncaughtException. This event is
                      raised when we have an exception in the node process which hasn't been handled
                      using a catch block:

                      process.on('uncaughtException');

                      If we have an uncaughtException event then wse can supply a function to handle
                      it:

                      process.on('uncaughtException', (ex) => { console.log('WE GOT AN UNCAUGHT
                      EXCEPTION'); winston.error(ex.message, ex); });

                      Back in the terminal run the application again:

                      WE GOT AN UNCAUGHT EXCEPTION

                      Notice this time the process doesn't terminate because we caught the
                      exception. The process terminates if we don't catch our exception. Check the
                      logfile.log:

                      {"message":"Something failed during startup","stack":"Error: Something failed
                      during startup\n at Object.
                      <anonymous> (C:\\DevelopmentTutorials\\TheCompleteNodeJSCourse\\
                        11-handling-and-logging-errors\\150-uncaught-exceptions\\vidly\\index.js:30:7)\n
                        at Module._compile (module.js:653:30)\n at Object.Module._extensions..js
                        (module.js:664:10)\n at Module.load (module.js:566:32)\n at tryModuleLoad
                        (module.js:506:12)\n at Function.Module._load (module.js:498:3)\n at
                        Function.Module.runMain (module.js:694:10)\n at startup
                        (bootstrap_node.js:204:16)\n at
                        bootstrap_node.js:625:3","level":"error","timestamp":"2019-01-22T18:58:54.281Z"}

                        We can see our error message. This is how we handle uncaught exceptions In
                        the next lecture we will look at unhandled promise rejections.

                        <h3>151 - Unhandled Promise Rejections</h3>

                        In the last lecture we learnt how to handle uncaught exceptions. So if there
                        is an exception in your application and you have not caught that exception
                        using a catch block you can subscribe to the on uncaughtException of the
                        process object and log the error using winston.

                        However this approach only works with synchronous code which means if you
                        have a promise somewhere that is rejected the function you provide to
                        uncaughtException will not be executed.

                        Let's replace the exception we threw in the previous lecture with a rejected
                        promise:

                        const p = Promise.reject(new Error('Something failed miserably!'));

                        So imagine this promise represents the result of an asynchronous operation
                        such as a call to the database or a remote http service and so on.

                        So as discussed previously with promises we should either call .then()
                        followed by .catch() to handle rejections:

                        p.then().catch();

                        Or if we are using the async and await syntax we await the promise but we
                        wrap it in a try/catch block.

                        In the code we just added to index:

                        const p = Promise.reject(new Error('Something failed miserably!'));

                        we have a promise so I can call then():

                        p.then(() => console.log('Done'));

                        but I wont call catch() So we will have an unhandled rejection.

                        So if we run the application again we will get an
                        UnhandledPromiseRejectionWarning. Currently the application will continue to
                        run but remember that Unhandled promise rejections are deprecated - so this
                        won't be the case in the future.

                        So to deal with unhandled promise rejections we need to subscribe to the
                        unhandledRejection event of the process object (index.js):

                        process.on('unhandledRejection', (ex) => { console.log('WE GOT AN UNHANDLED
                        REJECTION'); winston.error(ex.message, ex); });

                        If we run the application again and then view logfile.log we will see the
                        unhandled promise rejection.

                        As a best practice whether you are dealing with an uncaught exception or an
                        unhandled rejection you should exit the process because at that point your
                        process could be in an unclean state.

                        So if we exit the process how can we restart it in production. Well there
                        are tools for that are called process managers which we will look at later
                        in the course. So modify the code to exit the process in both code blocks:

                        process.on('uncaughtException', (ex) => { winston.error(ex.message, ex);
                        process.exit(1); });

                        process.on('unhandledRejection', (ex) => { winston.error(ex.message, ex);
                        process.exit(1); });

                        You can write this code in a different way by using the
                        winston.handleExceptions method:

                        winston.handleExceptions(new winston.transports.File({ filename:
                        'uncaughtExceptions.log' }));

                        Note that when we call handleExceptions we are specifying a different
                        transport than the one we have configured with our default logger:

                        winston.add(winston.transports.File, { filename: 'logfile.log' });

                        You can use the same filename or a different filename that is your choice.
                        We can also have multiple transports. One question you might have is whether
                        you should log to a file or to a database. My opinion is that you should use
                        both transports (databases are good for querying, filesystem is always
                        available (as opposed to database server which might go down))

                        At the time of writing winston.handleExceptions only works for uncaught
                        exceptions, if you have unhandled rejections they wont get logged.

                        I will show you a trick to get this working. First remove
                        process.on('uncaughtException') and we will just rely on
                        winston.handleExceptions.

                        Next when we have an unhandledRejection we can simply throw the exception:

                        process.on('unhandledRejection', (ex) => { throw ex; });

                        which will raise an unhandled exception that is then dealt with by
                        winston.handleExceptions that will log it in the file and terminate the
                        process.

                        <h3>152 - Error Handling Recap</h3>

                        To summarize. In express we have error middleware that is basically a
                        function with four arguments:

                        err req res next

                        This function catches any errors in the request processing pipeline. So we
                        use winston to log the error then return a response status 500 to the
                        client. As discussed, this only works for errors that occur in the request
                        processing pipeline. Any errors that occur outside the context of express
                        will be ignored. If something goes wrong during application startup this
                        function is not going to be executed. That's why we call
                        winston.handleExceptions in index.js to get any uncaught exceptions and log
                        them to a file.

                        Currently this only works with uncaught exceptions, it wont work with
                        unhandled promise rejections - hopefully this will be available in the
                        future. In the meantime you can use the workaround described at the end of
                        the previous lecture. So as a best practice when you are dealing with these
                        kind of exceptions, you should terminate the node process because the
                        process can be in an unclean state. So you should restart it in a clean
                        state. In production we use tools that we call process managers, which are
                        responsible for automatically restarting a node process.

                        Now if you look at code in index.js you can see it is starting to get a bit
                        out of hand. In the next few lectures we will look at how to refactor this
                        code and tidy it up to make it clean and maintainable.

                        <h3>153 - Refactoring index.js Extracting the Routes</h3>
                        The main issue with the code as it currently stands in index.js is lack of
                        separation of concerns. There are lots of things happening here which is why
                        we need so many require statements at the top of the file. Below that we
                        have some for handling and logging errors, then some configuration code,
                        then the mongodb database connection logic, then we setup our api endpoints
                        and various middleware - these are all separate concerns. They should not be
                        mixed up in one module. In this module we should only orchestrate our
                        concerns.

                        The details of setting up routes or the details of connecting to the
                        database should be separated. So in this lecture we will focus on extracting
                        our routes into a separate module.

                        So create a new folder called startup with a new file called routes.js In
                        this file we should export a function:

                        module.exports = function() {}

                        In this function we will add all the code for setting up our routes and
                        other middleware:

                        module.exports = function() { // app.use(at); // If everything required
                        authentication app.use(express.json()); app.use('/api/genres', genres);
                        app.use('/api/customers', customers); app.use('/api/movies', movies);
                        app.use('/api/rentals', rentals); app.use('/api/users', users);
                        app.use('/api/auth', auth); app.use(error); }

                        So look at the dependencies here. We have a dependency to app object,
                        express all these routes etc. So in index.js on the top we create the app
                        object like this:

                        const app = express();

                        We should have a single instance of app in the entire application. We don't
                        want to load express then call it to create an app object in our new module.
                        So we want to send a reference to our app as an argument to the new module:

                        module.exports = function(app)

                        Back in index.js we can load our new module:

                        require('./startup/routes')(app);

                        this returns a function which we call it and pass the app object:

                        Now we can move all the routes that we have setup in index.js to our new
                        module:

                        const genres = require('./routes/genres'); const customers =
                        require('./routes/customers'); const movies = require('./routes/movies');
                        const rentals = require('./routes/rentals'); const users =
                        require('./routes/users'); const auth = require('./routes/auth');

                        We also need express:

                        const express = require('express');

                        Now we will take the error middleware out of index.js:

                        const error = require('./middleware/error');

                        index.js is starting to look a bit tidier with less require statements and a
                        cleaner implementation.

                        Back in routes.js we need to change the route definitions because their
                        paths are incorrect. In Visual Studio Code you can multi select by selecting
                        some text (./) and then using ctrl+d to select the additional desired
                        instances. replace the existing text ./ with ../ to fix up the route paths.

                        Now, as an exercise, I want you to back to index.js and move all the
                        database initialization code to a different module. You will see the
                        solution the next lecture.

                        <h3>154 - Extracting the DB logic</h3>

                        Here in index.js we only have a small amount of code for database
                        initialization. Add a new file to startup called db.js. Export the function
                        and move the database connection logic to that file:

                        const mongoose = require('mongoose'); const winston = require('winston');

                        module.exports = function() { mongoose.connect('mongodb://localhost/vidly')
                        .then(() => winston.info('Connected to MongoDB...')); }

                        We also loaded winston and used it to log info messages instead of
                        console.log.

                        We remove the catch method that writes to the console:

                        .catch(err=> console.error('Could not conntect to MongoDB...'))

                        because if we can't connect to MongoDB we want to log that exception and
                        terminate the process but the catch statement handles the rejected promise
                        and just displays a message on the console - so we are not logging this and
                        it is not terminating the process. We just added this earlier purely for
                        demonstration purposes. With the new implementation we don't need this.

                        Finally We also added code to import mongoose. We can cut this from
                        index.js:

                        const mongoose = require('mongoose');

                        So that is our database module. You can see the code is very clean and
                        short, we have a single responsibility. We don't have too many things mixed
                        up together.

                        Now back in index.js we load the db module and call the function that is
                        returned:

                        require('./startup/db')();

                        Here we get a function which we call.

                        Let's verify with our current implementation that if we can't connect to the
                        database during the application startup that the exception will be logged
                        and the process will be terminated.

                        So stop mongod and then run the application you should see an exception
                        thrown in the console window where the app was started:

                        winston-mongodb: error initialising logger { MongoError: failed to connect
                        to server [localhost:27017] on first connect [MongoError: connect
                        ECONNREFUSED 127.0.0.1:27017]

                        You should also see that the exception has been logged in the
                        uncaughtExceptions file. This is why we needed to delete the catch logic in
                        the database connection function to let our global error handler deal with
                        the rejected promise.

                        You're next exercise is to go back to index.js and extract all the code for
                        logging errors into a separate module called logging.js We will cover the
                        solution in the next lecture.

                        <h3>155 - Extracting the Logging Logic</h3>

                        In this lecture we are going to move all the code for setting up logging to
                        a different module. So anything that is related to winston and handling
                        rejected promises.

                        So back in the startup folder let's add a new file logging.js and export a
                        function:

                        module.exports = function() {}

                        Now in index.js take the code for setting up winston and move it to
                        logging.js within the function.

                        We need to import winston and winston-mongodb so move those require
                        statements from index.js as well:

                        const winston = require('winston'); require('winston-mongodb');

                        We can also move the require statement for logging express-async-errors to
                        our new logging module:

                        require('express-async-errors');

                        Finally we need to go back to index.js and load the logging module. Put it
                        before the other require statements just in case they generate errors:

                        require('./startup/logging');

                        That completes the logging refactoring.

                        In the next lecture we will move all the code for dealing with configuration
                        to a separate module.

                        <h3>156 - Extracting the config Logic</h3>

                        Let's add a config.js file in the startup folder that exports a function.
                        Now move all the code related to configuration settings into this new
                        module:

                        module.exports = function() { if(!config.get('jwtPrivateKey')) {
                        console.error('FATAL ERROR: jwtPrivateKey is not defined.');
                        process.exit(1); } }

                        This code contains a dependency for config. We can move the require
                        statement from index.js:

                        const config = require('config');

                        Now if we don't have the jwtPrivateKey config setting we no longer want to
                        log this to the console and exit the process. Instead we should store this
                        as a fatal error in our log by throwing an exception:

                        throw new Error('FATAL ERROR: jwtPrivateKey is not defined.');

                        Our current infrastructure will catch the exception, log it and terminate
                        the process. Note it is best practice to throw error objects instead of
                        strings because when you throw an Error object the stack trace will be
                        available for you to view later. If, instead, you throw a string with the
                        error message the stack trace will not be available.

                        Finally in index.js load the config module:

                        require('./startup/config')();

                        and it's a function so we call it.

                        Now, if you look at the code in index.js, you only have 12 lines of code.
                        The last thing we can move here is the configuration of Joi:

                        const Joi = require('joi'); Joi.objectId = require('joi-objectid')(Joi);

                        We could move this to a module like validation.js or we could call that
                        module api.js. We are using Joi on the api layer. We use it to validate the
                        input to our api. For this application, honestly, I don't have a strong
                        opinion of what we should call that module. We'll call it validation.js -
                        and cover the refactoring in the next lecture.

                        <h3>157 - Extracting the Validation Logic</h3>

                        Create a new file called validation.js and export a function then move the
                        require statement that adds object id validation to Joi:

                        module.exports = function() { Joi.objectId = require('joi-objectid')(Joi); }

                        Also at the top of validation.js add the require statement for Joi (you can
                        move this from index.js):

                        const Joi = require('joi');

                        Next add a require statement for the validation module in index.js:

                        require('./startup/validation.js')();

                        The code in index.js is much cleaner. Remember what we had before. There
                        were about 60 or 70 lines of code with really poor separation of concerns.
                        Now with this refactoring we are doing only one thing - setting up the
                        application. The details of logging, of routes, of databases are delegate to
                        other modules. This is single responsibility principle in practice.

                        Finally replace the console.log statement in index.js where we configure app
                        to listen on port 3000 with winston:

                        app.listen(port, () => winston.info(`Listening on port ${port}...`));

                        Don't forget to require winston:

                        const winston = require('winston');

                        Run the application:

                        info: Listening on port 5000... info: Connected to MongoDB...

                        These are the two info messages coming from winston.

                        <h3>158 - Showing Unhandled Exceptions on the Console</h3>

                        I notice a tiny problem in the current implementation. If you take this
                        application on a different machine and run:

                        node index.js

                        It terminates without telling us what happened. In the current
                        implementation we are using winston to handle exceptions with only a file
                        transport. So if you look at uncaughtExceptions.log you will see the
                        exception detail. However if you didn't know this you would have no idea
                        what was going on.

                        For this reason we should add a console transport to display exceptions on
                        the console as well. So in logging.js in the winston.handleExceptions method
                        we add a new transport:

                        new winston.transports.Console({ colorize: true, prettyPrint: true});

                        Now if you run the application again on the new machine you will see the
                        exception on the console (in this case jwtPrivateKey is not defined)

                        <h3>159 - Recap</h3>

</body>
</html>
