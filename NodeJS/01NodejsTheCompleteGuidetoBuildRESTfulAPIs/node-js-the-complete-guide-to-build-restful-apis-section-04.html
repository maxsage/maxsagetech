<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>Node:js The Complete Guide to Build RESTful APIs (2018)</title>
  <script src="https://unpkg.com/vue"></script>
  <link crossorigin="anonymous"
        href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
        rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
  </style>
</head>
<body>
<div class="container" id="app">
  <div class="panel-group">
    <div class="panel panel-primary">
      <div class="panel-heading">
        <h2>Section 4 - Building RESTful API's Using Express</h2>
      </div>
      <div class="panel-body">
        <div>
          <h3>41 Introduction</h3>
          <p>Earlier in the course we covered the HTTP module. We used this to create a web server
            that listens on port 3000 and responds to requests made on the /api/courses endpoint.
            While this approach is fine, it is not suitable for building a large complex application
            because you will more than likely end up adding a lot of endpoints. So in this section
            we will look at express which is a fast and lightweight framework for building web
            applications.
          </p>
          <h3>42 RESTful Services</h3>
          <p>Most applications follow the Client/Server architecture Communication between the
            Client and Server occurs over HTTP.
          </p>
          <p>We expose services on the Server that are available to the client via HTTP
            requests.</p>
          <figure>
            <img src="./images/Fig04-001.png"/>
            <figcaption>Fig 04-001</figcaption>
          </figure>
          <p>This process uses REST (REpresentational State Transfer) - REST is basically a
            principle for building these HTTP services We use simple HTTP protocol principles to
            provide support to Create, Read, Update and Delete data - referred to as CRUD
          </p>
          <p>We expose endpoints like this:</p>
          <figure>
            <pre><code class="language-command">http://vidly.com/api/customers</code></pre>
            <figcaption>Fig 04-002</figcaption>
          </figure>
          <p>The client can send http requests to this endpoint to talk to our service.</p>
          <p>The type of the http request determines the operation. Every http request has a verb or
            method that determines it's intention:
          </p>
          <table class="table">
            <tbody>
            <tr>
              <td>GET</td>
              <td>Get /api/customers, /api/customers/1</td>
            </tr>
            <tr>
              <td>PUT</td>
              <td>Update /api/customers/1 Include customer object in the body of the request</td>
            </tr>
            <tr>
              <td>DELETE</td>
              <td>Delete /api/customers/1</td>
            </tr>
            <tr>
              <td>POST</td>
              <td>Create /api/customers/ Include customer object in the body of the request</td>
            </tr>
            </tbody>
          </table>
          <h3>43 Introducing Express</h3>
          <p>As we define more routes for our application it will become necessary to use a
            framework to give our application a proper structure. This means we can easily add more
            routes whilst keeping our application code maintainable.
          </p>
          <p>There are various frameworks out there for building web applications and web servers on
            top of node. express is one of the most popular frameworks for this purpose. It can be
            installed using npm:
          </p>
          <figure>
            <pre><code class="language-command">npm i express</code></pre>
            <figcaption>Fig 04-003</figcaption>
          </figure>
          <h3>44 Building Your First Web Server</h3>
          <p>We will add a new file called index.js (it could also be called app.js). First we load
            the express module:</p>
          <figure>
              <pre><code class="language-javascript">const express = require('express');
const app = express();</code></pre>
            <figcaption>Fig 04-004</figcaption>
          </figure>
          <p>It is convention to store the express object in a constant called app. The app object
            exposes several useful methods:</p>
          <figure>
              <pre><code class="language-javascript">app.get();
app.post();
app.put();
app.delete();</code></pre>
            <figcaption>Fig 04-005</figcaption>
          </figure>
          <p>All these methods correspond to the http verbs discussed earlier. So we could do the
            following:</p>

          <figure>
              <pre><code class="language-javascript">app.get('/', (req, res) =&gt;
{
  res.send('Hello World');
});

app.listen(3000, () =&gt;
  console.log('Listening on port 3000...'));</code></pre>
            <figcaption>Fig 04-006</figcaption>
          </figure>
          <p>So this is how we specify a route. We specify the path in the first parameter passed to
            the get method. The second parameter is a callback method (also known as a route handler
            in this context).</p>
          <p>In the app.listen method we tell express to listen on port 3000. We also pass a
            callback function that will be called when the application starts listening on the given
            port. We use the arrow function syntax to write a message out to the console.</p>
          <p>Check out the express documentation at <a href="expressjs..com">expressjs.com</a> to
            learn about all the available properties: baseUrl, body, cookies, fresh, hostname etc.
          </p>
          <p>In the terminal issue the following command:</p>
          <figure>
            <pre><code class="language-command">node index.js</code></pre>
            <figcaption>Fig 04-007</figcaption>
          </figure>
          <p>Now in chrome browse to localhost:3000 and you should see the "Hello World"
            message.</p>
          <p>Now let's define another route:</p>
          <figure>
              <pre><code class="language-javascript">app.get('/api/courses', (req, res) =&gt;
{
  res.send([1, 2, 3]);
});</code></pre>
            <figcaption>Fig 04-008</figcaption>
          </figure>
          <p>Again, we call api.get but with an endpoint of /api/course. The callback or route
            handler is a function that accepts two arguments: request and response. This goes to a
            code block. In a real world scenario we would get a list of courses from the database
            and return them. For the moment we will simulate this functionality by returning an
            array of numbers.</p>
          <p>Now we have to restart the process in the terminal using Ctrl+C</p>
          <p>If we run the application and browse to localhost:3000/api/courses you should see the
            following:</p>
          <figure>
            <img src="./images/Fig04-009.png"/>
            <figcaption>Fig 04-009</figcaption>
          </figure>
          <p>So in this implementation we don't have the if blocks we used earlier in the HTTP
            module code. Instead we define new routes by calling app.get. As our application grows
            we are free to move routes to other files (e.g. courses.js for routes related to
            courses).</p>

          <h3>45 Nodemon</h3>
          <p>Up to this point, each time the code is changed we have been required to restart the
            node process in the terminal. We can use the nodemon node package to watch for changes
            and restart our process automatically:</p>
          <figure>
            <pre><code class="language-command">npm i -g nodemon</code></pre>
            <figcaption>Fig 04-010</figcaption>
          </figure>
          <p>now instead of using node to run our application we use nodemon:</p>
          <figure>
            <pre><code class="language-command">nodemon index.js</code></pre>
            <figcaption>Fig 04-011</figcaption>
          </figure>
          <p>Now you can see that nodemon is watching all the files in the folder:</p>
          <figure>
          <pre><code class="language-command">[nodemon] 1.19.4
[nodemon] to restart at any time, enter `rs`
[nodemon] watching dir(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node index.js`
Listening on port 3000...</code></pre>
            <figcaption>Fig 04-012</figcaption>
          </figure>
          <p>If you make a change to one of the routes and refresh the browser you should see the
            change takes effect immediately - there is no need to restart the process manually.
            nodemon also writes to the terminal when it restarts due to changes:</p>
          <figure>
<pre><code class="language-command">[nodemon] restarting due to changes...
[nodemon] starting `node index.js`
Listening on port 3000...
</code></pre>
            <figcaption>Fig 04-013</figcaption>
          </figure>
          <h3>46 Environment Variables</h3>
          <p>One thing we could improve on in the code is switching the hard coded port value of
            3000:</p>
          <figure>
            <pre><code class="language-javascript">app.listen(3000, () =&gt; console.log('Listening on port 3000...'));</code></pre>
            <figcaption>Fig 04-014</figcaption>
          </figure>
          <p>For an environment variable. 3000 is an arbitrary number. While this should work on
            your development machine it is unlikely to work in a development environment. In a
            hosting environment the port will be dynamically assigned.</p>
          <p>We can read the value of an environment variable using the process object:</p>
          <figure>
          <pre><code class="language-javascript">const port = process.env.PORT || 3000;
app.listen(port, () =&gt; console.log(`Listening on port ${port}...`));</code></pre>
            <figcaption>Fig 04-015</figcaption>
          </figure>
          <p>To set an environment variable on Mac use:</p>
          <figure>
            <pre><code class="language-command">export PORT=5000</code></pre>
            <figcaption>Fig 04-016</figcaption>
          </figure>
          <p>On Windows use:</p>
          <figure>
            <pre><code class="language-command">setx PORT &quot;5000&quot;</code></pre>
            <figcaption>Fig 04-017</figcaption>
          </figure>
          <p>You should receive the following message:</p>
          <figure>
            <pre><code class="language-command">SUCCESS: Specified value was saved.</code></pre>
            <figcaption>Fig 04-018</figcaption>
          </figure>
          <p>You will also need to restart Webstorm to pickup the changes.</p>
          <p>Now if we run the application using nodemon:</p>
          <figure>
            <pre><code class="language-command">nodemon index.js</code></pre>
            <figcaption>Fig 04-019</figcaption>
          </figure>
          <p>You should see something similar to this:</p>
          <figure>
<pre><code class="language-command">[nodemon] 1.17.1 [nodemon] to restart at any time, enter `rs` [nodemon] watching: *.* [nodemon] starting `node
index.js` Listening on port 5000...
</code></pre>
            <figcaption>Fig 04-020</figcaption>
          </figure>
          <h3>47 Route Parameters</h3>
          <p>Currently we have a route for getting the list of courses:</p>
          <figure>
          <pre><code class="language-javascript">app.get('/api/courses', (req, res) =&gt;
{
  res.send([1, 2, 3]);
});</code></pre>
            <figcaption>Fig 04-021</figcaption>
          </figure>
          <p>In this section we will demonstrate how to create a route that gets a single course. In
            the discussion earlier on RESTful services we said that in order to retrieve a single
            course we include the id of the course in the url:</p>
          <figure>
            <pre><code class="language-command">// /api/courses/1</code></pre>
            <figcaption>Fig 04-022</figcaption>
          </figure>
          <p>To implement a route like this use the following:</p>
          <figure>
          <pre><code class="language-javascript">app.get('/api/courses/:id', (req, res) =&gt;
{
  res.send(req.params.id);
});</code></pre>
            <figcaption>Fig 04-023</figcaption>
          </figure>
          <p>the :id defines a parameter named id. To read the parameter we use req.params.id</p>
          <p>Now in chrome if you browse to localhost:3000/api/courses/1 you should see the course
            id of "1" is displayed:</p>
          <figure>
            <img src="./images/Fig04-024.PNG"/>
            <figcaption>Fig 04-024</figcaption>
          </figure>
          <p>It is possible to have multiple parameters in a route. Imagine a route for managing
            blog posts:</p>
          <figure>
          <pre><code class="language-javascript">app.get('/api/posts/:year/:month', (req, res) =&gt;
{
  res.send(req.params);
});</code></pre>
            <figcaption>Fig 04-025</figcaption>
          </figure>
          <p>If you browse to localhost:5000/api/posts/2018/1 you should see the following:</p>
          <figure>
          <pre><code class="language-json">{
  &quot;year&quot;: &quot;2018&quot;,
  &quot;month&quot;: &quot;1&quot;
}</code></pre>
            <figcaption>Fig 04-026</figcaption>
          </figure>
          <p>This is the req.params object. With express we can retrieve querystring parameters as
            well as route parameters. These are parameters that appear in the Url after a question
            mark. For example we can get all the posts for January 2018 and sort by name using the
            following:</p>
          <figure>
            <pre><code
              class="language-command">http://localhost:5000/api/posts/2018/1?sortBy=name</code></pre>
            <figcaption>Fig 04-028</figcaption>
          </figure>
          <p>By convention, route parameters are used for mandatory values whereas query parameters
            are used for optional values. We can read a url parameter like so:</p>
          <figure>
            <pre><code class="language-javascript">req.query;</code></pre>
            <figcaption>Fig 04-029</figcaption>
          </figure>
          <p>If we use this with one of our existing endpoints we should see the following output in
            the browser:</p>
          <figure>
<pre><code class="language-json">{
  sortBy = &quot;name&quot;
}</code></pre>
            <figcaption>Fig 04-030</figcaption>
          </figure>
          <p>Query parameters are stored in an object with key value pairs.</p>
          <h3>48 Handling HTTP GET Requests</h3>
          <p>Now let's implement a new endpoint to get a single course from the server. Define an
            array called courses:</p>
          <figure>
            <pre><code class="language-javascript">const courses = [
  { id: 1, name: 'course1' },
  { id: 2, name: 'course2' },
  { id: 3, name: 'course3' },
];</code></pre>
            <figcaption>Fig 04-031</figcaption>
          </figure>
          <p>So now we have two endpoints - one to get all the courses and the other to get a single
            course. In the endpoint to get all the courses we will return our courses array:</p>
          <figure>
            <pre><code class="language-javascript">app.get('/api/courses', (req, res) =&gt; {
  res.send(courses);
})</code></pre>
            <figcaption>Fig 04-032</figcaption>
          </figure>
          <p>In the second one we will write some logic to look for the course with the given
            id:</p>
          <figure>
            <pre><code class="language-javascript">app.get('/api/courses/:id', (req, res) => {
  const course = courses.find(c =&gt; c.id === parseInt(req.params.id));
});</code></pre>
            <figcaption>Fig 04-033</figcaption>
          </figure>
          <p>find is a method on every array in Javascript. As an argument we pass the method a
            function using the arrow function syntax. We write some logic that returns a boolean
            value that determines if this course is the one we are looking for or not. We use the
            parseInt global Javascript function to parse the string into an integer.</p>
          <p>
            We store the result in a const called course. You might ask why I didn't use var here.
            var is perfectly fine but going forward best practice states to either use the let or
            const keywords. We use let to define a variable that we can reset later. We use const
            when defining a constant. This prevents the variable from being overwritten elsewhere in
            the code.</p>
          <p>If we don't find a course with the given id the convention (with RESTful apis) is to
            return a status code of 404:</p>
          <figure>
            <pre><code class="language-javascript">if (!course)
  res.status(404).send('The course with the given id was not found');</code></pre>
            <figcaption>Fig 04-034</figcaption>
          </figure>
          <p>In the code above we also send the optional message. If we do find a course with that
            id then we will just return it to the client: </p>
          <figure>
            <pre><code class="language-javascript">res.send(course);</code></pre>
            <figcaption>Fig 04-035</figcaption>
          </figure>
          <p>If we browse to a course that does exist:</p>
          <figure>
            <pre><code class="language-command">localhost:5000/api/courses/10</code></pre>
            <figcaption>Fig 04-036</figcaption>
          </figure>
          <p>We get receive the Json object in the browser:</p>
          <figure>
<pre><code class="language-json">{
  id: 1,
  name: &quot;course1&quot;
}</code></pre>
            <figcaption>Fig 04-037</figcaption>
          </figure>
          <p>If we browse to a course that doesn't exist:</p>
          <figure>
            <pre><code class="language-command">localhost:5000/api/courses/10</code></pre>
            <figcaption>Fig 04-037</figcaption>
          </figure>
          <p>We will receive the message saying the course was not found. If you open chrome
            developer tools and click on the Network tab refresh the page and you will see the
            status 404.</p>
          <figure>
            <img src="./images/Fig04-038.PNG"/>
            <figcaption>Fig 04-038</figcaption>
          </figure>
          <h3>49 Handling HTTP POST Requests</h3>
          <p>So far the routes we have created all response to HTTP GET requests. In this lecture we
            will learn how to respond to HTTP POST requests. We use an HTTP POST request to create a
            new course:</p>
          <figure>
          <pre><code class="language-javascript">app.post('/api/courses', (req, res) =&gt; {

});</code></pre>
            <figcaption>Fig 04-039</figcaption>
          </figure>
          <p>Similar to the get method we need to specify a path: /api/courses because we are going
            to POST to the collection of courses. That's why we use the plural name. Next we add our
            route handler using the arrow function.</p>
          <p>In this route handler we need to read the course object which should be in the body of
            the request and use it's properties to create a new course object and then add that
            object to our courses array:</p>
          <figure>
          <pre><code class="language-javascript">const course =
{ id: courses.length + 1,
  name: req.body.name
};</code></pre>
            <figcaption>Fig 04-040</figcaption>
          </figure>
          <p>Again, we use a const here because we are not going to reset this course object later.
            In this demo, to keep things simple, we are not working with a database so we just add
            one to the length of our courses array.</p>
          <p>Next we need to read the name property from the body of the request. We assume that in
            the request body we have an object and that object has a name property. In order for
            this line to work we need to enable parsing of JSON objects in the body of the request
            because by default this feature is not enabled in express. So at the top of the file
            after we get the app object:</p>
          <figure>
            <pre><code class="language-javascript">app.use(express.json());</code></pre>
            <figcaption>Fig 04-041</figcaption>
          </figure>
          <p>This may look a bit strange at this point in time but we will cover this in detail
            later in the course. Basically, here, we are adding a piece of middleware. When we call
            express.json() this method returns a piece of middleware and then we call app.use to use
            that middleware in the request processing pipeline.</p>
          <p>Back in the route handler we push the course into our courses array:</p>
          <figure>
            <pre><code class="language-javascript">courses.push(course);</code></pre>
            <figcaption>Fig 04-042</figcaption>
          </figure>
          <p>Finally, by convention, when we post an object to the server and the server creates a
            new object or resource we should return that object in the body of the response:</p>
          <figure>
            <pre><code class="language-javascript">res.send(course);</code></pre>
            <figcaption>Fig 04-043</figcaption>
          </figure>
          <p>We do this because we are assigning this id on the server and we need to return this
            course object to the client because chances are the client needs to know the id of this
            new object.</p>
          <h3>50 - Calling Endpoints Using Postman</h3>
          <p>To call HTTP services we use an application called Postman.</p>
          <p>See the separate documentation for PostMan</p>
          <h3>51 - Input Validation</h3>
          <p>In this lecture we will look at input validation. Best practice dictates that we should
            never trust information sent by the client. It should always be validated.</p>
          <p>In this example:</p>

          <figure>
          <pre><code class="language-javascript">app.post('/api/courses', (req, res) =&gt; {
  const course = {
    id: courses.length + 1,
    name: req.body.name
  };
  courses.push(course);
  res.send(course);
});</code></pre>
            <figcaption>Fig 04-044</figcaption>
          </figure>
          <p>We are dealing with a simple object with only one property: name we can write some
            validation logic like this:</p>
          <figure>
          <pre><code class="language-javascript">if(!req.body.name || req.body.name.length < 3)
{ // 400 Bad Request
  res.status(400).send('Name is required and should be minimum 3 characters');
  return;
}</code></pre>
            <figcaption>Fig 04-045</figcaption>
          </figure>
          <p>So if the name property doesn't exist or is less than 3 characters in length we set the
            response status to 400 Bad Request. We then send a rather generic error message along
            with setting the status. Finally we return to prevent the rest of the function from
            being executed.</p>
          <p>In a real world application we are likely to be working with more complex objects than
            the one we are using here. We don't want to add too many validation rules in if
            statements at the top of the route handler. We will look at a node package that makes it
            easier to validate input: joi.</p>
          <figure>
            <pre><code class="language-command">npm i joi@13.1.0</code></pre>
            <figcaption>Fig 04-046</figcaption>
          </figure>
          <p>Now, back in the code, at the top of the file we need to load the module:</p>
          <figure>
            <pre><code class="language-javascript">const Joi = require('joi');</code></pre>
            <figcaption>Fig 04-047</figcaption>
          </figure>
          <p>We use a capital for the Joi variable because this module returns a class. As we said
            before we use Pascal naming conventions when we name our classes - so the first letter
            of every word should be uppercase.</p>
          <p>Also as a best practice put all your require calls at the top of the file. This way you
            can easily see what are the dependencies of this module. So our current module is
            dependent on joi and express.</p>
          <p>Go back the route handler. With joi we need to define a schema. A schema defines the
            shape of our objects - what properties do we have in our object, what is the type of
            each property in the object, do we have an email, do we have a string, what are the
            minimum or maximum number of characters, do we have a number, what range should that
            number be in.</p>
          <p>First we define a schema:</p>
          <figure>
          <pre><code class="language-javascript">const schema = {
  name:  Joi.string().min(3).required()
};</code></pre>
            <figcaption>Fig 04-048</figcaption>
          </figure>
          <p>So we set schema to an object with a name property. We tell joi to expect a string with
            a minimum of three characters that is required.</p>
          <p>Next we call the validate method passing in the req.body and schema:</p>
          <figure>
          <pre><code class="language-javascript">const result = Joi.validate(req.body, schema);
console.log(result);</code></pre>
            <figcaption>Fig 04-049</figcaption>
          </figure>
          <p>We store the object returned by the validate method in a const called result. For this
            demo I'm going to log this result on the console.</p>
          <p>Now if we use Postman to create another course object (POST to
            http://localhost:3000/api/courses with the course specified in the body and the object
            sent to JSON(application/json)) in the terminal we should see a result object with two
            properties - error and value. Only one of these can have a value. In this case because
            we sent a valid course object we have this course object here as the value of the value
            property and you can see error is null:</p>
          <figure>
          <pre><code class="language-javascript">{ error: null,
  value: { name: 'new course' },
  then: [Function: then],
  catch: [Function: catch] }</code></pre>
            <figcaption>Fig 04-050</figcaption>
          </figure>
          <p>If we send an invalid object, for example by removing the name property, then value
            will be null and error will be set:</p>
          <figure>
          <pre><code class="language-javascript">{
  ValidationError: child &quot;name&quot; fails because [&quot;name&quot; is required]</code></pre>
            <figcaption>Fig 04-051</figcaption>
          </figure>
          <p>Back in the route handler instead of using the manual validation logic we can check the
            value of the result.error property:</p>
          <figure>
          <pre><code class="language-javascript">if (result.error) {
  res.status(400).send(result.error);
  return;
}</code></pre>
            <figcaption>Fig 04-052</figcaption>
          </figure>
          <p>We also don't need the console.log statement any longer so we can remove that.</p>
          <p>If we use Postman to submit another invalid request and look at the response we get an
            object with properties such as isJoi, name, details etc:</p>
          <figure>
            <img src="./images/Fig04-053.PNG"/>
            <figcaption>Fig 04-053</figcaption>
          </figure>
          <p>details is an array of error messages. The first one should be "name is required". This
            object is too complex to send to the client. If you want to simplify this go back to the
            code and instead of returning the whole result.error object you can drill down to the
            detail arrays first elements message property:</p>
          <figure>
            <pre><code class="language-javascript">result.error.details[0].message</code></pre>
            <figcaption>Fig 04-053</figcaption>
          </figure>
          <p>Now if we re-post our request we get:</p>
          <figure>
            <img src="./images/Fig04-054.PNG"/>
            <figcaption>Fig 04-054</figcaption>
          </figure>
          <p>If we add the name property into request but set it to a string that is only one
            character:</p>
          <figure>
            <img src="./images/Fig04-055.PNG"/>
            <figcaption>Fig 04-055</figcaption>
          </figure>
          <p>We receive a different error:</p>
          <figure>
            <img src="./images/Fig04-056.PNG"/>
            <figcaption>Fig 04-056</figcaption>
          </figure>
          <h3>52 - Handling HTTP PUT Requests</h3>
          <p>Now let's see how we can update a course. Add a new route handler with the PUT
            method:</p>

          <figure>
<pre><code class="language-javascript">app.put('/api/courses/:id', (req, res) =&gt;
{
  // Look up the course // If not existing, return 404
  const course = courses.find(c =&gt; c.id === parseInt(req.params.id));
  if(!course)
    res.status(404).send('The course with the given id was not found');

    // Validate // If invalid, return 400 - Bad request
    const schema = {
      name: Joi.string().min(3).required()
    };

    const result = Joi.validate(req.body, schema);
    if(result.error) {
      res.status(400).send(result.error.details[0].message);
      return;
    }

    // Update course
    course.name = req.body.name;

    // Return the updated course
    res.send(course);

});</code></pre>
            <figcaption>Fig 04-057</figcaption>
          </figure>
          <p>The route handler contains a lot of logic, a good proportion of which we have already
            covered and can pull in from different methods. The code to look up the course and
            return a 404 if it doesn't exist can be found in the route handler to get a single
            course and we get the validation from the post endpoint.</p>
          <p>The problem with this approach is that , although in this example we are dealing with a
            simple schema, real world applications may have much more complex schemas. This would
            mean our validation code was duplicated in two route handlers. We'll resolve this
            shortly.</p>
          <p>Next we update the course.name property. If we had more properties we would update them
            here also. Finally we return the updated course to the client.</p>
          <p>Now we will extract the validation logic into it's own function which can be used in
            both route handlers:</p>
          <figure>
          <pre><code class="language-javascript">function validateCourse(course) { 
  const schema = {    
    name: Joi.string().min(3).required() 
  };
  return Joi.validate(course, schema); 
};</code></pre>
            <figcaption>Fig 04-058</figcaption>
          </figure>
          <p>In the code above, instead of validating the req.body we validate the course object.
            Also we return the result to the caller - there is no need to define a const.</p>
          <p>Now we can reuse this in our PUT endpoint:</p>
          <figure>
            <pre><code
              class="language-javascript">const result = validateCourse(req.body);

if(result.error) {
  res.status(400).send(result.error.details[0].message);
  return;
}</code></pre>
            <figcaption>Fig 04-059</figcaption>
          </figure>
          <p>This code can be made a bit cleaner by using the object destructuring features of
            modern Javascript:</p>
          <figure>
          <pre><code class="language-javascript">const { error } = validateCourse(req.body);

if(error) {
 res.status(400).send(error.details[0].message);
  return;
}</code></pre>
            <figcaption>Fig 04-060</figcaption>
          </figure>

          <p>Currently we get the result object and then we are accessing result.error in two
            different places. Since all we are interested in is the error property we can get this
            using object destructuring. With object destructuring when declaring a variable or
            object we add curly braces and inside we add the property of the target object (in this
            instance error):</p>
          <p>With the above code we don't need to repeat result.error in two seperate places we can
            simply use error.</p>
          <p>We now need to add this new way of validating a course to the HTTP POST request.</p>
          <figure>
<pre><code class="language-javascript">app.post('/api/courses', (req, res) =&gt; {
    const { error } = validateCourse(req.body);
    if(error) {
        res.status(400).send(error.details[0].message);
        return;
    }

    const course = {
        id: courses.length + 1,
        name: req.body.name
    };
    courses.push(course);
    res.send(course);
});
</code></pre>
            <figcaption>Fig 04-061</figcaption>
          </figure>
          <p>Back in POSTMAN test the PUT and POST endpoints with valid and invalid values in the
            data.</p>
          <h3>53 - Handling HTTP Delete Requests</h3>
          <p>Out of all the CRUD operations we have now implemented Create, Read, and Update . In
            this lecture we will look at how to respond to HTTP DELETE requests:</p>
          <figure>
<pre><code class="language-javascript">app.delete('/api/courses/:id', (req, res) =&gt; {
  // Look up the course // If not existing, return 404
  const course = courses.find(c =&gt; c.id === parseInt(req.params.id));
  if (!course)
    res.status(404).send('The course with the given id was not found');

  // Delete
  const index = courses.indexOf(course);
  courses.splice(index, 1);

  // Return the same course
  res.send(course);
});</code></pre>
            <figcaption>Fig 04-062</figcaption>
          </figure>
          <p>Test this in Postman using valid and invalid course ids.</p>
          <p>There are currently three bugs in this code. Currently in the PUT endpoint if we don't
            have a course with a given id we return a 404 to the client. However at this point we
            should exit the route handler otherwise the rest of the code will be executed:</p>
          <figure>
<pre><code class="language-javascript">if (!course)
  return res.status(404).send('The course with the given id was not found');</code></pre>
            <figcaption>Fig 04-063</figcaption>
          </figure>
          <p>To make this code cleaner we can use the same technique to deal with an invalid
            request:</p>
          <figure>
          <pre><code class="language-javascript">if(error)
  return res.status(400).send(error.details[0].message);</code></pre>
            <figcaption>Fig 04-064</figcaption>
          </figure>
          <p>The same issue exists in the DELETE route handler so let's fix that:</p>
          <figure>
          <pre><code class="language-javascript">if (!course)
  return res.status(404).send('The course with the given id was not found');</code></pre>
            <figcaption>Fig 04-064</figcaption>
          </figure>
          <p>and also when GETting a single course:</p>
          <figure>
          <pre><code class="language-javascript">if (!course)
  return res.status(404).send('The course with the given id was not found');</code></pre>
            <figcaption>Fig 04-065</figcaption>
          </figure>
          <p>We can also clean up the code in the POST route handler:</p>
          <figure>
<pre><code class="language-javascript">if(error)
  return res.status(400).send(error.details[0].message);</code></pre>
            <figcaption>Fig 04-066</figcaption>
          </figure>
          <h3>54 - Project - Build the Genres API</h3>
          From this lecture we are going to start building the backend services for our vidly
          application. vidly is an imaginary service for renting out movies. Throughout the course
          we will build the backend of vidly bit by bit.
        </div>
        <p>Your first task is to create a service for managing the list of genres. Each movie has a
          genre like action, horror etc. We should have an endpoint for getting all the genres:</p>
        <figure>
          <pre><code class="language-command">http://vidly.com/api/genres</code></pre>
          <figcaption>Fig 04-067</figcaption>
        </figure>
        <p>We should also have endpoints for creating, updating and deleting genres.</p>
        <h3>55 - Recap</h3>
        <p>So, in this section, you learned that:</p>
        <ul>
          <li>REST defines a set of conventions for creating HTTP services:
          <ul>
            <li>POST: to create a resource</li>
            <li>PUT: to update it</li>
            <li>GET: to read it</li>
            <li>DELETE: to delete it</li>
          </ul>
          </li>
          <li>Express is a simple, minimalistic and lightweight framework for building web servers.</li>
        </ul>
<figure>
<pre><code class="language-javascript">// Build a web server
const express = require(&lsquo;express&rsquo;);
const app = express();

// Creating a course
app.post(&lsquo;/api/courses&rsquo;, (req, res) =&gt; {
  // Create the course and  return the course object
  res.send(course);
});

// Getting all the courses
app.get(&lsquo;/api/courses&rsquo;, (req, res) =&gt; {
  // To read query string parameters (?sortBy=name)
  const sortBy = req.query.sortBy;

  // Return the courses
  res.send(courses);
});

// Getting a single course
app.get(&lsquo;/api/courses/:id&rsquo;, (req, res) =&gt; {
  const courseId = req.params.id;

  // Lookup the course
  // If not found, return 404
  res.status(404).send(&lsquo;Course not found.&rsquo;);

  // Else, return the course object
  res.send(course);
});

// Updating a course
app.put(&lsquo;/api/courses/:id&rsquo;, (req, res) =&gt; {
  // If course not found, return 404, otherwise update it
  // and return the updated  object.
});

// Deleting a course
app.delete(&lsquo;/api/courses/:id&rsquo;, (req, res) =&gt; {
  // If course not found, return 404, otherwise delete it
  // and return the deleted object.
});

// Listen on port 3000
app.listen(3000, () =&gt; console.log(&lsquo;Listening&hellip;&rsquo;)); </code></pre>
<figcaption>Fig 04-068</figcaption>
</figure>
  <ul>
    <li>We use Nodemon to watch for changes  in files and automatically restart the node
      process.</li>
    <li>We can use environment variables to store various settings for an application. To read
      an environment variable, we use process.env.</li>
  </ul>
       <figure>
       <pre><code class="language-javascript"> // Reading the port from an environment variable
        const port = process.env.PORT || 3000;
        app.listen(port);</code></pre>
       <figcaption>Fig 04-069</figcaption>
       </figure>
        <p>You should never trust data sent by the client. Always validate! Use Joi package to
          perform input validation.</p>
      </div>
    </div>
  </div>
</div>
</body>
</html>
