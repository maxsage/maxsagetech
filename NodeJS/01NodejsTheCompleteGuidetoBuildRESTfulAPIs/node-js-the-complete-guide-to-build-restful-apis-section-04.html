<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>Node:js The Complete Guide to Build RESTful APIs (2018)</title>
  <script src="https://unpkg.com/vue"></script>
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
  </style>
</head>
<body>
<div class="container" id="app">
  <div class="panel-group">
    <div class="panel panel-primary">
      <div class="panel-heading">
        <h2>Section 4 - Building RESTful API's Using Express</h2>
      </div>
      <div class="panel-body">
        <div>
          <h3>41 Introduction</h3>
          <p>Earlier in the course we covered the HTTP module. We used this to create a web server that listens on port
            3000 and responds to requests made on the /api/courses endpoint. While this approach is fine, it is not
            suitable for building a large complex application because you will more than likely end up adding a lot of
            endpoints. So in this section we will look at express which is a fast and lightweight framework for building
            web applications.
          </p>
          <h3>42 RESTful Services</h3>
          <p>Most applications follow the Client/Server architecture Communication between the Client and Server occurs
            over HTTP.
          </p>
          <p>We expose services on the Server that are available to the client via HTTP requests.</p>
          <figure>
            <img src="./images/Fig04-001.png"/>
            <figcaption>Fig 04-001</figcaption>
          </figure>
          <p>This process uses REST (REpresentational State Transfer) - REST is basically a principle for building these
            HTTP services We use simple HTTP protocol principles to provide support to Create, Read, Update and Delete
            data - referred to as CRUD
          </p>
          <p>We expose endpoints like this:</p>
          <figure>
            <pre><code class="language-command">http://vidly.com/api/customers</code></pre>
            <figcaption>Fig 04-002</figcaption>
          </figure>
          <p>The client can send http requests to this endpoint to talk to our service.</p>
          <p>The type of the http request determines the operation. Every http request has a verb or method that
            determines it's intention:
          </p>
          <table class="table">
            <tbody>
            <tr>
              <td>GET</td>
              <td>Get /api/customers, /api/customers/1</td>
            </tr>
            <tr>
              <td>PUT</td>
              <td>Update /api/customers/1 Include customer object in the body of the request</td>
            </tr>
            <tr>
              <td>DELETE</td>
              <td>Delete /api/customers/1</td>
            </tr>
            <tr>
              <td>POST</td>
              <td>Create /api/customers/ Include customer object in the body of the request</td>
            </tr>
            </tbody>
          </table>
          <h3>43 Introducing Express</h3>
          <p>As we define more routes for our application it will become necessary to use a framework to give our
            application a proper structure. This means we can easily add more routes whilst keeping our application code
            maintainable.
          </p>
          <p>There are various frameworks out there for building web applications and web servers on top of node.
            express is one of the most popular frameworks for this purpose. It can be installed using npm:
          </p>
          <figure>
            <pre><code class="language-command">npm i express</code></pre>
            <figcaption>Fig 04-003</figcaption>
          </figure>
          <h3>44 Building Your First Web Server</h3>
          <p>We will add a new file called index.js (it could also be called app.js). First we load the express
            module:</p>
          <figure>
              <pre><code class="language-javascript">const express = require('express');
const app = express();</code></pre>
          <figcaption>Fig 04-004</figcaption>
          </figure>
          <p>It is convention to store the express object in a constant called app. The app object exposes several
            useful methods:</p>
          <figure>
              <pre><code class="language-javascript">app.get();
app.post();
app.put();
app.delete();</code></pre>
          <figcaption>Fig 04-005</figcaption>
          </figure>
          <p>All these methods correspond to the http verbs discussed earlier. So we could do the following:</p>

          <figure>
              <pre><code class="language-javascript">app.get('/', (req, res) =&gt;
{
  res.send('Hello World');
});

app.listen(3000, () =&gt;
  console.log('Listening on port 3000...'));</code></pre>
          <figcaption>Fig 04-006</figcaption>
          </figure>
          <p>So this is how we specify a route. We specify the path in the first parameter passed to the get
            method. The second parameter is a callback method (also known as a route handler in this context).</p>
          <p>In the app.listen method we tell express to listen on port 3000. We also pass a callback function that
            will be called when the application starts listening on the given port. We use the arrow function syntax
          to write a message out to the console.</p>
          <p>Check out the express documentation at <a href="expressjs..com">expressjs.com</a> to learn about all
            the available properties: baseUrl, body, cookies, fresh, hostname etc.</p>
          <p>In the terminal issue the following command:</p> 
          <figure>
              <pre><code class="language-command">node index.js</code></pre>
          <figcaption>Fig 04-007</figcaption>
          </figure>
          <p>Now in chrome browse to localhost:3000 and you should see the "Hello World" message.</p>
          <p>Now let's define another route:</p>
          <figure>
              <pre><code class="language-javascript">app.get('/api/courses', (req, res) =&gt;
{
  res.send([1, 2, 3]);
});</code></pre>
          <figcaption>Fig 04-008</figcaption>
          </figure>
          <p>Again, we call api.get but with an endpoint of /api/course. The callback or route handler is a function
          that accepts two arguments: request and response. This goes to a code block. In a real world scenario we
            would get a list of courses from the database and return them. For the moment we will simulate this
            functionality by returning an array of numbers.</p>
          <p>Now we have to restart the process in the terminal using Ctrl+C</p>
          <p>If we run the application and browse to localhost:3000/api/courses you should see the following:</p>
          <figure>
            <img src="./images/Fig04-009.png"/>
            <figcaption>Fig 04-009</figcaption>
          </figure>
          <p>So in this implementation we don't have the if blocks we used earlier in the HTTP module code. Instead we
            define new routes by calling app.get. As our application grows we are free to move routes to other files
            (e.g. courses.js for routes related to courses).</p>

          <h3>45 Nodemon</h3>
          Up to this point, each time the code is changed we have been required to restart the node process in the
          terminal. We can use the nodemon node package to watch for changes and restart our process automatically:

          npm i -g nodemon

          now instead of using node to run our application we use nodemon:

          nodemon index.js

          If you make a change to one of the routes and refresh the browser you should see the change takes effect
          immediately - there is no need to restart the process manually. nodemon also writes "[nodemon] restarting due
          to changes....." to the terminal

          <h3>46 Environment Variables</h3>
          One thing we could improve on in the code is switching the hard coded port value of 3000: app.listen(3000, ()
          => console.log('Listening on port 3000...'));

          For an environment variable. 3000 is an arbitrary number. While this should work on your development machine
          it is unlikely to work in a development environment. In a hosting environment the port will be dynamically
          assigned.

          We can read the value of environment variable using the process object:

          const port = process.env.PORT || 3000; app.listen(port, () => console.log(`Listening on port ${port}...`));

          To set an environment variable on Mac use:

          export PORT=5000

          On Windows use:

          setx PORT "5000"

          You should receive the following message:

          SUCCESS: Specified value was saved.

          You will also need to restart Webstorm to pickup the changes.


          Now if we run the application using nodemon:

          nodemon index.js

          You should see something similar to this:

          [nodemon] 1.17.1 [nodemon] to restart at any time, enter `rs` [nodemon] watching: *.* [nodemon] starting `node
          index.js` Listening on port 5000...

          <h3>47 Route Parameters</h3>
          Currently we have a route for getting the list of courses:

          app.get('/api/courses', (req, res) => { res.send([1, 2, 3]); });

          In this section we will demonstrate how to create a route that gets a single course. In the discussion earlier
          on RESTful services we said that in order to retrieve a single course we include the id of the course in the
          url:

          // /api/courses/1

          To implement a route like this use the following:

          app.get('/api/courses/:id', (req, res) => { res.send(req.params.id); });

          Now in chrome if you browse to localhost:3000/api/courses/1 you should see the course id of "1" displayed.

          It is possible to have multiple parameters in a route. Imagine a route for managing blog posts:

          app.get('/api/posts/:year/:month', (req, res) => { res.send(req.params); });

          If you browse to localhost:5000/api/posts/2018/1 you should see the following:

          // 20181004180450 // http://localhost:5000/api/posts/2018/1

          { "year": "2018", "month": "1" }

          This is the req.params object. With express we can retrieve querystring parameters as well as route
          parameters. These are parameters that appear in the Url after a question mark. For example we can get all the
          posts for January 2018 and sort by name using the following:

          http://localhost:5000/api/posts/2018/1?sortBy=name

          By convention, route parameters are used for mandatory values whereas query parameters are used for optional
          values. We can read a url parameter like so:

          req.query;

          Query parameters are stored in an object with key value pairs.

          <h3>48 Handling HTTP GET Requests</h3>
          Now let's implement a new endpoint to get a single course from the server. Define an array called courses:

          const courses = [ { id: 1, name: 'course1' }, { id: 2, name: 'course2' }, { id: 3, name: 'course3' }, ];

          So now we have two endpoints - one to get all the courses and the other to get a single course. In the
          endpoint to get all the courses we will return our courses array:

          app.get('/api/courses', (req, res) => { res.send(courses); })

          In the second one we will write some logic to look for the course with the given id:

          const course = courses.find(c => c.id === parseInt(req.params.id));

          find is a method on every array in Javascript. As an argument we pass the method a function using the arrow
          function syntax. We write some logic that returns a boolean value that determines if this course is the one we
          are looking for or not. We store the result in a const called course. You might ask why I didn't use var here.
          var is perfectly fine but going forward best practice states to either use the let or const keywords. We use
          let to define a variable that we can reset later. We use const when defining a constant. This prevents the
          variable from being overwritten elsewhere in the code.

          If we don't find a course with the given id the convention (with RESTful apis) is to return a status code of
          404:

          if (!course) res.status(404).send('The course with the given id was not found');

          In the code above we also send the optional message. If we do find a course with that id then we will just
          return it to the client: res.send(course);

          If we browse to a course that does exist:

          localhost:5000/api/courses/10

          then just that course is returned. If we browse to a course that doesn't exist:

          localhost:5000/api/courses/10

          We will receive the message saying the course was not found. If you open chrome developer tools and click on
          the Network tab refresh the page and you will see the status 404.

          <h3>49 Handling HTTP POST Requests</h3>
          So far the routes we have created all response to HTTP GET requests. In this lecture we will learn how to
          respond to HTTP POST requests. We use an HTTP POST request to create a new course:

          app.post('/api/courses', (req, res) => {

          });

          Similar to the get method we need to specify a path: /api/courses because we are going to POST to the
          collection of courses. That's why we use the plural name. Next we add our route handler using the arrow
          function.

          In this route handler we need to read the course object which should be in the body of the request and use
          it's properties to create a new course object and then add that object to our courses array:

          const course = { id: courses.length + 1, name: req.body.name };

          Again, we use a const here because we are not going to reset this course object later. In this demo, to keep
          things simple, we are not working with a database so we just add one to the length of our courses array. Next
          we need to read the name property from the body of the request. We assume that in the request body we have an
          object and that object has a name property. In order for this line to work we need to enable parsing of JSON
          objects in the body of the request because by default this feature is not enabled in express. So at the top of
          the file after we get the app object:

          app.use(express.json());

          This may look a bit strange at this point in time but we will cover this in detail later in the course.
          Basically, here, we are adding a piece of middleware. When we call express.json() this method returns a piece
          of middleware and then we call app.use to use that middleware in the request processing pipeline.

          Back in the route handler we push the course into our courses array:

          courses.push(course);

          Finally, by convention, when we post an object to the server and the server creates a new object or resource
          we should return that object in the body of the response:

          res.send(course);

          We do this because we are assigning this id on the server and we need to return this course object to the
          client because chances are the client needs to know the id of this new object.

          <h3>50 - Calling Endpoints Using Postman</h3>
          To call HTTP services we use an application called Postman.

          CREATE SEPARATE DOCUMENTATION FOR POSTMAN

          <h3>51 - Input Validation</h3>
          In this lecture we will look at input validation. Best practice dictates that we should never trust
          information sent by the client. It should always be validated.

          In this example:

          app.post('/api/courses', (req, res) => { const course = { id: courses.length + 1, name: req.body.name };
          courses.push(course); res.send(course); });

          We are dealing with a simple object with only one property: name we can write some validation logic like this:

          if(!req.body.name || req.body.name.length < 3) { // 400 Bad Request res.status(400).send('Name is required and
          should be minimum 3 characters'); return; }

          So if the name property doesn't exist or is less than 3 characters in length we set the response status to 400
          Bad Request. We then send a rather generic error message along with setting the status. Finally we return to
          prevent the rest of the function from being executed.

          In a real world application we are likely to be working with more complex objects than the one we are using
          here. We don't want to add too many validation rules in if statements at the top of the route handler. We will
          look at a node package that makes it easier to validate input: joi.

          npm i joi@13.1.0

          Now, back in the code, at the top of the file we need to load the module:

          const Joi = require('joi');

          We use a capital for the Joi variable because this module returns a class. As we said before we use Pascal
          naming conventions when we name our classes - so the first letter of every word should be uppercase.

          Also as a best practice put all your require calls at the top of the file. This way you can easily see what
          are the dependencies of this module. So our current module is dependent on joi and express.

          Go back the route handler. With joi we need to define a schema. A schema defines the shape of our objects -
          what properties do we have in our object, what is the type of each property in the object, do we have an
          email, do we have a string, what are the minimum or maximum number of characters, do we have a number, what
          range should that number be in.

          First we define a schema:

          const schema = { name: Joi.string().min(3).required() };

          So we set schema to an object with a name property. We tell joi to expect a string with a minimum of three
          characters that is required.

          Next we call the validate method passing in the req.body and schema:

          const result = Joi.validate(req.body, schema); console.log(result);

          We store the object returned by the validate method in a const called result. For this demo I'm going to log
          this result on the console.

          Now if we use Postman to create another course object (POST to http://localhost:3000/api/courses with the
          course specified in the body and the object sent to JSON(application/json)) in the terminal we should see a
          result object with two properties - error and value. Only one of these can have a value. In this case because
          we sent a valid course object we have this course object here as the value of the value property and you can
          see error is null:

          { error: null, value: { name: 'new course' }, then: [Function: then], catch: [Function: catch] }

          If we send an invalid object, for example by removing the name property, then value will be null and error
          will be set:

          { ValidationError: child "name" fails because ["name" is required]

          Back in the route handler instead of using the manual validation logic we can check the value of the
          result.error property:

          if(result.error) { res.status(400).send(result.error); return; }

          We also don't need the console.log statement any longer so we can remove that.

          If we use Postman to submit another invalid request and look at the response we get an object with properties
          such as isJoi, name, details etc. details is an array of error messages. The first one should be "name is
          required". This object is too complex to send to the client. If you want to simplify this go back to the code
          and instead of returning the whole result.error object you can drill down to the detail arrays first elements
          message property:

          result.error.details[0].message

          <h3>52 - Handling HTTP PUT Requests</h3>
          Now let's see how we can update a course. Add a new route handler with the PUT method:

          app.put('/api/courses/:id', (req, res) => { // Look up the course // If not existing, return 404 const course
          = courses.find(c => c.id === parseInt(req.params.id)); if (!course) res.status(404).send('The course with the
          given id was not found');

          // Validate // If invalid, return 400 - Bad request const schema = { name: Joi.string().min(3).required() };

          const result = Joi.validate(req.body, schema); if(result.error) {
          res.status(400).send(result.error.details[0].message); return; }

          // Update course course.name = req.body.name;

          // Return the updated course res.send(course);

          });


          The route handler contains a lot of logic, a good proportion of which we have already covered and can pull in
          from different methods. The code to look up the course and return a 404 if it doesn't exist can be found in
          the route handler to get a single course We can get the validation from the post endpoint. The problem with
          this approach is that , although in this example we are dealing with a simple schema, real world applications
          may have much more complex schemas. This would mean our validation code was duplicated in two route handlers.
          We'll resolve this shortly. Next we update the course.name property. If we had more properties we would update
          them here also. Finally we need to return the updated course to the client.

          Now we will extract the validation logic into it's own function which can be used in both route handlers:

          function validateCourse(course) { const schema = { name: Joi.string().min(3).required() };

          return Joi.validate(course, schema); };

          In the code above, instead of validating the req.body we validate the course object. Also we return the result
          to the caller - there is no need to define a const.

          New we can reuse this in our PUT endpoint:

          const result = validateCourse(req.body);

          This code can be made a bit cleaner by using the object destructuring features of modern Javascript. Currently
          we get the result object and then we are accessing result.error in two different places. Since all we are
          interested in is the error property we can get this using object destructuring. With object destructuring when
          declaring a variable or object we add curly braces and inside we add the property of the target object (in
          this instance error):

          const { error } = validateCourse(req.body); if(error) { res.status(400).send(error.details[0].message);
          return; }

          With the above code we don't need to repeat result.error in two seperate places we can simply use error.

          We now need to add this new way of validating a course to the HTTP POST request.

          Back in POSTMAN test the PUT and POST endpoints with valid and invalid values in the data.

          <h3>53 - Handling HTTP Delete Requests</h3>
          Out of all the CRUD operations we have now implemented Read, Update and Delete. In this lecture we will look
          at how to respond to HTTP DELETE requests:

          app.delete('/api/courses/:id', (req, res) => { // Look up the course // If not existing, return 404 const
          course = courses.find(c => c.id === parseInt(req.params.id)); if (!course) res.status(404).send('The course
          with the given id was not found');

          // Delete const index = courses.indexOf(course); courses.splice(index, 1);

          // Return the same course res.send(course);

          });

          Test this in Postman using valid and invalid course ids.

          There are currently three bugs in this code. Currently in the PUT endpoint if we don't have a course with a
          given id we return a 404 to the client. However at this point we should exit the route handler otherwise the
          rest of the code will be executed:

          if (!course) return res.status(404).send('The course with the given id was not found');

          To make this code cleaner we can use the same technique to deal with an invalid request:

          if(error) return res.status(400).send(error.details[0].message);

          The same issue exists in the DELETE route handler so let's fix that:

          if (!course) return res.status(404).send('The course with the given id was not found');

          and also when GETting a single course:

          if (!course) return res.status(404).send('The course with the given id was not found');

          We can also clean up the code in the POST route handler:

          if(error) return res.status(400).send(error.details[0].message);

          <h3>54 - Project - Build the Genres API</h3>
          From this lecture we are going to start building the backend services for our vidly application. vidly is an
          imaginary service for renting out movies. Throughout the course we will build the backend of vidly bit by bit.
          Your first task is to create a service for managing the list of genres. Each movie has a genre like action,
          horror etc. We should have an endpoint for getting all the genres. We should also have endpoints for creating,
          updating and deleting genres.

          <h3>55 - Recap</h3>
          Building RESTful APIs with Express So, in this section, you learned that: - REST defines a set of conventions
          for creating HTTP services: - POST: to create a resource - PUT: to update it - GET: to read it - DELETE: to
          delete it - Express is a simple, minimalistic and lightweight framework for building web servers. // Build a
          web server const express = require(‘express’); const app = express(); // Creating a course
          app.post(‘/api/courses’, (req, res) => { // Create the course and return the course object res.send(course);
          }); // Getting all the courses app.get(‘/api/courses’, (req, res) => { // To read query string parameters
          (?sortBy=name) const sortBy = req.query.sortBy; // Return the courses res.send(courses); }); // Getting a
          single course app.get(‘/api/courses/:id’, (req, res) => { const courseId = req.params.id;

          // Lookup the course // If not found, return 404 res.status(404).send(‘Course not found.’); // Else, return
          the course object res.send(course); }); // Updating a course app.put(‘/api/courses/:id’, (req, res) => { // If
          course not found, return 404, otherwise update it // and return the updated object. }); // Deleting a course
          app.delete(‘/api/courses/:id’, (req, res) => { // If course not found, return 404, otherwise delete it // and
          return the deleted object. }); // Listen on port 3000 app.listen(3000, () => console.log(‘Listening…’)); - We
          use Nodemon to watch for changes in files and automatically restart the node process. - We can use environment
          variables to store various settings for an application. To read an environment variable, we use process.env.
          // Reading the port from an environment variable const port = process.env.PORT || 3000; app.listen(port); -
          You should never trust data sent by the client. Always validate! Use Joi package to perform input validation.

        </div>
      </div>
    </div>
  </div>
</div>
</body>
</html>
