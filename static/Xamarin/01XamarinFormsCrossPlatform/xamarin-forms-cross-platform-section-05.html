<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>maxsagetech - Xamarin Forms: Build Native Cross-platform Apps with C#</title>
  <script src="https://unpkg.com/vue"></script>
  <!--<link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"-->
  <!--integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" rel="stylesheet">-->
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>

    img {
      max-width: 100%;
     
    }
  </style>
</head>
<body>
    <div class="container">
        <div class="panel-group">
            <div class="panel panel-primary">
                <div class="panel-heading">
                    <h2>Lists</h2>
                </div>
                <div class="panel-body">
                    <h3>Introduction</h3>
                    <p>In a lot of applications we have some kind of list. So in this lecture we are going to learn how to
                        present data in beautiful interactive lists. You will learn how to handle selections, how to display
                        context actions, how to implement pull to refresh and how to add a search bar on top of your list.
                    </p>
                    <h3>Populating a Basic List</h3>
                    <p>Let's start with a very simple list. Create a new Content Page called BasicListPage.xaml. In the Xaml
                        add a ListView element:
                    </p>
                    <figure>
                <pre><code class="language-csharp">&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot; ?&amp;gt;
&amp;lt;ContentPage xmlns=&amp;quot;http://xamarin.com/schemas/2014/forms&amp;quot;
             xmlns:x=&amp;quot;http://schemas.microsoft.com/winfx/2009/xaml&amp;quot;
             x:Class=&amp;quot;UdemyXamarinForms.BasicListPage&amp;quot;&amp;gt;
    &amp;lt;ListView x:Name=&amp;quot;listView&amp;quot;/&amp;gt;
&amp;lt;/ContentPage&amp;gt;</pre></code>
                        <figcaption>Fig 05-001</figcaption>
                    </figure>
                    <p>To populate this list with data we are going to go in the code-behind and create a list of names then
                        set the ItemsSource of the listView:
                    </p>
                    <figure>
<pre><code class="language-csharp">public BasicListPage ()
{
    InitializeComponent ();

    var names = new List&lt;string&gt;
    {
        &quot;Mosh&quot;,
        &quot;John&quot;,
        &quot;Bob&quot;
    };

    listView.ItemsSource = names;
}</pre></code>
                        <figcaption>Fig 05-002</figcaption>
                    </figure>
                    <p>If we run the app we can see our list populated with three names:</p>
                    <figure>
                        <img src="./images/05/Fig05-003.png"/>
                        <figcaption>Fig 05-003</figcaption>
                    </figure>
                    <p>If you look closely you can see we have a feint border below each item - this is a separator. We can
                        hide this:
                    </p>
                    <figure>
                        <pre><code class="language-csharp">&lt;ListView x:Name=&quot;listView&quot; SeparatorVisibility=&quot;None&quot; /&gt;</pre></code>
                        <figcaption>Fig 05-003</figcaption>
                    </figure>
                    <p>or change it's colour:</p>
                    <figure>
                        <pre><code class="language-csharp">&lt;ListView x:Name=&quot;listView&quot; SeparatorColor=&quot;Blue&quot; /&gt;</pre></code>
                        <figcaption>Fig 05-004</figcaption>
                    </figure>
                    <p>This is a pretty basic list but in most real world applications you want to display complex objects.
                        That is the topic of the next lecture.
                    </p>
                    <h3>Cell Appearance</h3>
                    <p>Let's say we want to display a list of contacts. Each contact can have a name, a status and an image.
                    </p>
                    <p>First create a new Content Page called ContactListPage.xaml and add a ListView element:</p>
                    <figure>
                <pre><code class="language-csharp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;UdemyXamarinForms.ContactListPage&quot;&gt;
    &lt;ListView x:Name=&quot;listView&quot; SeparatorColor=&quot;Blue&quot; /&gt;
&lt;/ContentPage&gt;</pre></code>
                        <figcaption>Fig 05-005</figcaption>
                    </figure>
                    <p>Next create a new folder in our shared project called Models - this is where we will store all our
                        domain classes (e.g. Contact class).
                    </p>
                    <p>Add a new public class to the Models folder called Contact.cs with three properties - Name, Status
                        and ImageUrl:
                    </p>
                    <figure>
                <pre><code class="language-csharp">public class Contact
{
    public string Name { get; set; }
    public string Status { get; set; }
    public string ImageUrl { get; set; }
}</pre></code>
                        <figcaption>Fig 05-006</figcaption>
                    </figure>
                    <p>Let's go to the code-behind for ContactListPage.xaml and initialize the listView:</p>
                    <figure>
                <pre><code class="language-csharp">public ContactListPage ()
{
    InitializeComponent ();

    listView.ItemsSource = new List&lt;Contact&gt;
    {
        new Contact { Name = &quot;Mosh&quot;, ImageUrl = &quot;http://lorempixel.com/100/100/people/1&quot; },
        new Contact { Name = &quot;John&quot;, ImageUrl = &quot;http://lorempixel.com/100/100/people/2&quot;, Status=&quot;Hey let's talk!&quot; }
    };
}</pre></code>
                        <figcaption>Fig 05-007</figcaption>
                    </figure>
                    <p>If we run the application now we see the following:</p>
                    <figure>
                        <img src="./images/05/Fig05-008.png"/>
                        <figcaption>Fig 05-008</figcaption>
                    </figure>
                    <p>Each item appears as UdemyXamarinForms.Models.Contact. This is because by default the ListView calls
                        the ToString() method on each item in the list. The default implementation of the ToString() method
                        returns the fully qualified name of our class. We actually want to render the Name and Status
                        properties for each Contact.
                    </p>
                    <p>Back in the Xaml edit the ListView to add an ItemTemplate:</p>
                    <figure>
                <pre><code class="language-csharp">&lt;ListView x:Name=&quot;listView&quot;&gt;
    &lt;ListView.ItemTemplate&gt;
        &lt;DataTemplate&gt;
            &lt;TextCell Text=&quot;{Binding Name}&quot; Detail=&quot;{Binding Status}&quot; /&gt;
        &lt;/DataTemplate&gt;
    &lt;/ListView.ItemTemplate&gt;
&lt;/ListView&gt;</pre></code>
                        <figcaption>Fig 05-009</figcaption>
                    </figure>
                    <p>ListView has a property called ItemTemplate. Just like we have ItemsSource we have ItemTemplate -
                        which is the Template for each item. Inside ItemTemplate we add a DataTemplate element. Inside
                        DataTemplate we use the built-in TextCell template. If you want to have more control over the
                        appearance of each item you can create a custom template which is the topic of the next lecture. The
                        two built-in templates that we often use with ListView are TextCell and ImageCell.
                    </p>
                    <p>
                        TextCell has a Text property which we supply with a Binding Expression. Notice we don't set the
                        Source in this Binding Expression because when we initialize ItemsSource each Contact object will be
                        the Binding Context for each item in the ListView. Remember Binding Context - we covered that in
                        Chapter 02 - Xaml Essentials. I explained that if you have multiple elements that have reference the
                        same object as their Binding Source you can clean up the code by setting the Binding Context on the
                        Container.
                    </p>
                    <p>In this example each Contact will be the Binding Context for each item in the ListView. So in our
                        Binding Expression we simply use the name of the target property - in this case Name.
                    </p>
                    <p>TextCell has another property called Detail which we supply with another Binding Expression this time
                        binding to Status
                    </p>
                    <p>TextCell also has TextColor and DetailColor properties.</p>
                    <p></p>
                    <p>Let's run the application:</p>
                    <figure>
                        <img src="./images/05/Fig05-010.png"/>
                        <figcaption>Fig 05-010</figcaption>
                    </figure>
                    <p>You can see each item has text and detail (where available).</p>
                    <p>Now if you want to add an image here we can use the other built-in template called ImageCell:</p>
                    <figure>
                        <pre><code class="language-csharp">&lt;ImageCell Text=&quot;{Binding Name}&quot; Detail=&quot;{Binding Status}&quot; ImageSource=&quot;{Binding ImageUrl}&quot;  /&gt;</pre></code>
                        <figcaption>Fig 05-011</figcaption>
                    </figure>
                    <p>Let's look at the result:</p>
                    <figure>
                        <img src="./images/05/Fig05-012.png"/>
                        <figcaption>Fig 05-012</figcaption>
                    </figure>
                    <p>Now in the next lecture we are going to look at creating a Custom Cell to have full control over the
                        appearance of each item.
                    </p>
                    <h3>Custom Cells</h3>
                    <p>Alright, let's imagine you want to add a follow button to the right side of each element:</p>
                    <figure>
                        <img src="./images/05/Fig05-013.png"/>
                        <figcaption>Fig 05-013</figcaption>
                    </figure>
                    <p>For this scenario we would need a Custom Template. Create a new Content Page called
                        CustomTemplateContactListPage.xaml and add the following Xaml:
                    </p>
                    <figure>
                <pre><code class="language-csharp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;UdemyXamarinForms.CustomTemplateContactListPage&quot;&gt;
    &lt;ListView x:Name=&quot;listView&quot;&gt;
        &lt;ListView.ItemTemplate&gt;
            &lt;DataTemplate&gt;
                &lt;ViewCell&gt;
                    &lt;StackLayout Orientation=&quot;Horizontal&quot;&gt;
                        &lt;Image Source=&quot;{Binding ImageUrl}&quot;/&gt;
                        &lt;StackLayout&gt;
                            &lt;Label Text=&quot;{Binding Name}&quot; /&gt;
                            &lt;Label Text=&quot;{Binding status}&quot; TextColor=&quot;Gray&quot; /&gt;
                        &lt;/StackLayout&gt;
                        &lt;Button Text=&quot;Follow&quot; /&gt;
                    &lt;/StackLayout&gt;
                &lt;/ViewCell&gt;
            &lt;/DataTemplate&gt;
        &lt;/ListView.ItemTemplate&gt;
    &lt;/ListView&gt;
&lt;/ContentPage&gt;</pre></code>
                        <figcaption>Fig 05-014</figcaption>
                    </figure>
                    <p>Now let's run the application and see what happens:</p>
                    <figure>
                        <img src="./images/05/Fig05-015.png"/>
                        <figcaption>Fig 05-015</figcaption>
                    </figure>
                    <p>It looks pretty messy. Let's try an workout what's going on here. First of all I'm going to apply a
                        BackgroundColor to the outer StackLayout:
                    </p>
                    <figure>
                        <img src="./images/05/Fig05-016.png"/>
                        <figcaption>Fig 05-016</figcaption>
                    </figure>
                    <p>So for each item we can see that the StackLayout stretches to fill it's container and each item
                        contains plenty of unused space. What we want to do is allocate that unused space to this vertical
                        StackLayout:
                    </p>
                    <figure>
                        <img src="./images/05/Fig05-017.png"/>
                        <figcaption>Fig 05-017</figcaption>
                    </figure>
                    <p>This will push the Follow buttons to the right side of the screen. To achieve this set the inner
                        StackLayout's HorizontalOptions to StartAndExpand (because I want this StackLayout to be
                        horizontally on the left):
                    </p>
                    <figure>
                        <pre><code class="language-csharp">&lt;StackLayout HorizontalOptions=&quot;StartAndExpand&quot;&gt;</pre></code>
                        <figcaption>Fig 05-018</figcaption>
                    </figure>
                    <p>Any option that ends with AndExpand means that any available space should be allocated to this
                        element.
                    </p>
                    <p>Let's run the application again:</p>
                    <figure>
                        <img src="./images/05/Fig05-019.png"/>
                        <figcaption>Fig 05-019</figcaption>
                    </figure>
                    <p>Ok, that's better! So we can see that any extra space is now allocated to our inner StackLayout.
                        Another thing that will improve the UI is some padding because currently the image and the follow
                        button are very close to the edges of the page.
                    </p>
                    <p>Remove the BackgroundColor from the outer StackLayout and instead apply Padding of 5 units:</p>
                    <figure>
                        <img src="./images/05/Fig05-020.png"/>
                        <figcaption>Fig 05-020</figcaption>
                    </figure>
                    <p>Ok so we have some padding around the items but we have introduced another issue - the detail for the
                        second item is leaking into the third item. The reason for this is that, by default, all rows in a
                        ListView have the same height. We can easily fix this problem by setting the HasUnevenRows property
                        on the ListView to true:
                    </p>
                    <figure>
                    <pre><code class="language-csharp">&lt;ListView x:Name=&quot;listView&quot; HasUnevenRows=&quot;True&quot;&gt;</pre></code>
                        <figcaption>Fig 05-021</figcaption>
                    </figure>
                    <p>With this change the height of each item will be based on it's content. Let's take a look at the
                        result:
                    </p>
                    <figure>
                        <img src="./images/05/Fig05-022.png"/>
                        <figcaption>Fig 05-022</figcaption>
                    </figure>
                    <h3>Grouping Items</h3>
                    <p>Now let's see how to group items in a ListView. For example here I've grouped the contacts based on
                        their first letter:
                    </p>
                    <figure>
                        <img src="./images/05/Fig05-023.png"/>
                        <figcaption>Fig 05-023</figcaption>
                    </figure>
                    <p>So currently we two groups - M & J. In iOS we also have an index on the right side of the screen:</p>
                    <figure>
                        <img src="./images/05/Fig05-024.png"/>
                        <figcaption>Fig 05-024</figcaption>
                    </figure>
                    <p>This can be handy when going through a list with a lot of items.</p>
                    <p>Add a Content Page called GroupingItemsPage.xaml</p>
                    <p>Add another class to the Models folders called ContactGroup.cs</p>
                    <figure>
                <pre><code class="language-csharp">public class ContactGroup : List&lt;Contact&gt;
{
    public string Title { get; set; }
    public string ShortTitle { get; set; }

    public ContactGroup(string title, string shortTitle)
    {
        Title = title;
        ShortTitle = shortTitle;
    }
}</pre></code>
                        <figcaption>Fig 05-025</figcaption>
                    </figure>
                    <p>We derived the class from List of Contact so it's a List by nature. Next I'm going to define a couple
                        of properties - Title and ShortTitle. The ShortTitle will be used to render the index on iOS.
                    </p>
                    <p>Next we initialize the properties in the Constructor.</p>
                    <p>Back in the code-behind for GroupingItemsPage.xaml instead of setting the listView.ItemsSource to a
                        List of Contacts I want to set it to a list of ContactGroups:
                    </p>
                    <figure>
                <pre><code class="language-csharp">public GroupingItemsPage ()
{
    InitializeComponent ();

    listView.ItemsSource = new List&lt;ContactGroup&gt;
    {
        new ContactGroup(&quot;M&quot;, &quot;M&quot;)
        {
            new Contact { Name = &quot;Mosh&quot;, ImageUrl = &quot;http://lorempixel.com/100/100/people/1&quot; },

        },
        new ContactGroup(&quot;J&quot;, &quot;J&quot;)
        {
            new Contact { Name = &quot;John&quot;, ImageUrl = &quot;http://lorempixel.com/100/100/people/2&quot;, Status=&quot;Hey let's talk!&quot; }
        }
    };
}</pre></code>
                        <figcaption>Fig 05-026</figcaption>
                    </figure>
                    <p>We initialize the ContactGroup List with two new ContactGroups - one for M and one for J. Now because
                        these ContactGroups are a List of Contacts we initialize them with Contact objects. We don't
                        necessarily have to use single letters for the ContactGroup Titles. For example in another
                        application you might have groups like Friends, Family, Colleagues, Acquaintances etc. However in
                        this app because I am grouping Contacts by the first letter of their name I am using a single letter
                        as the Group Title.
                    </p>
                    <p>In the Xaml file we need to set a couple properites in our ListView:</p>
                    <figure>
                <pre><code class="language-csharp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;UdemyXamarinForms.GroupingItemsPage&quot;&gt;
    &lt;ListView x:Name=&quot;listView&quot; HasUnevenRows=&quot;True&quot;
              IsGroupingEnabled=&quot;true&quot;
              GroupDisplayBinding=&quot;{Binding Title}&quot;
              GroupShortNameBinding=&quot;{Binding ShortTitle}&quot;&gt;
        &lt;ListView.ItemTemplate&gt;
            &lt;DataTemplate&gt;
                &lt;TextCell Text=&quot;{Binding Name}&quot; Detail=&quot;{Binding Status}&quot; /&gt;
            &lt;/DataTemplate&gt;
        &lt;/ListView.ItemTemplate&gt;
    &lt;/ListView&gt;
&lt;/ContentPage&gt;</pre></code>
                        <figcaption>Fig 05-027</figcaption>
                    </figure>
                    <p>For the ListView we add a property called IsGroupingEnabled and set it to true. The other property we
                        set is called GroupDisplayBinding which we set to a Binding Expression that binds to the Title
                        property of ContactGroup. The last property - GroupShortNameBinding provides the index functionality
                        we discussed for iOS. We bind this property to ShortTitle of ContactGroup
                    </p>
                    <p>Let's look at the result:</p>
                    <figure>
                        <img src="./images/05/Fig05-028.png"/>
                        <figcaption>Fig 05-028</figcaption>
                    </figure>
                    <p>Here is our grouped contacts. Next we will discuss working with selections.</p>
                    <h3>Handling Selections</h3>
                    <p>Now let's see how we can work with Selections. Add another Content Page called
                        HandlingSelectionsPage.xaml and add the following Xaml:
                    </p>
                    <figure>
                <pre><code class="language-csharp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;UdemyXamarinForms.HandlingSelectionsPage&quot;&gt;
    &lt;ListView x:Name=&quot;listView&quot;
              ItemTapped=&quot;listView_ItemTapped&quot;
              ItemSelected=&quot;listView_ItemSelected&quot;
              IsGroupingEnabled=&quot;True&quot;
              GroupDisplayBinding=&quot;{Binding Title}&quot;
              GroupShortNameBinding=&quot;{Binding ShortTitle}&quot;&gt;
        &lt;ListView.ItemTemplate&gt;
            &lt;DataTemplate&gt;
                &lt;TextCell Text=&quot;{Binding Name}&quot; Detail=&quot;{Binding Status}&quot; /&gt;
            &lt;/DataTemplate&gt;
        &lt;/ListView.ItemTemplate&gt;
    &lt;/ListView&gt;
&lt;/ContentPage&gt;</pre></code>
                        <figcaption>Fig 05-029</figcaption>
                    </figure>
                    <p>The Udemy video lecture shows a Xaml file withouth the Grouping attributes but if you miss these out
                        you will see an error in the Output window saying that Name and Status were not found.
                    </p>
                    <p>We added a couple of events. The first is ItemTapped and we let Visual Studio create the default
                        event handler.
                    </p>
                    <p>The other event we implement is called ItemSelected and again we let Visual Studio create the default
                        event handler for us.
                    </p>
                    <p>ItemSelected has an argument called e which gives us information about the SelectedItem. e is of type
                        object. Because we have bound our ListView to List of Contacts each item in the list is a Contact
                        object. Which means I can get the Selected Item and cast it as a Contact storing the result in a
                        variable called contact:
                    </p>
                    <figure>
                        <pre><code class="language-csharp">var contact = e.SelectedItem as Contact;</pre></code>
                        <figcaption>Fig 05-030</figcaption>
                    </figure>
                    <p>Next in this method we display an alert with the Name of the selected Contact:</p>
                    <figure>
                    <pre><code class="language-csharp">DisplayAlert(&quot;Selected&quot;, contact.Name, &quot;OK&quot;);</pre></code>
                        <figcaption>Fig 05-031</figcaption>
                    </figure>
                    <p>For the Tapped event the e argument has a property called Item which gives us access to the item that
                        has been tapped. So first we cast to a Contact and store the result in a variable called contact:
                    </p>
                    <figure>
                        <pre><code class="language-csharp">var contact = e.Item as Contact;</pre></code>
                        <figcaption>Fig 05-032</figcaption>
                    </figure>
                    <p>Then we call DisplayAlert with the Name of the tapped Contact:</p>
                    <figure>
                        <pre><code class="language-csharp">var contact = e.Item as Contact;</pre></code>
                        <figcaption>Fig 05-033</figcaption>
                    </figure>
                    <p>Now if you run the application and tap a Contact you will get the Tapped alert then when you click ok
                        you will get the Selected alert the first time you tap each Contact.
                    </p>
                    <p>Subsequent taps will only fire the Tapped event until you tap on another contact.</p>
                    <p>This differs to the behaviour specified in the video which says when we select a Contact we get the
                        Selected event but not the Tapped event and then subsequent taps result in the Tapped event firing.
                    </p>
                    <p>Which event you want to work with depends on your application but quite often we use the Selected
                        event. A real world example of this is where a user taps an item to select it perhaps we want to
                        navigate them to a second page where we can see more detail about an item.
                    </p>
                    <p>If you want to disable Selection in the ItemSelected handler simply set listView.SelectedItem to
                        null:
                    </p>
                    <figure>
                <pre><code class="language-csharp">private void listView_ItemSelected(object sender, SelectedItemChangedEventArgs e)
{
    var contact = e.SelectedItem as Contact;
    DisplayAlert(&quot;Selected&quot;, contact.Name, &quot;OK&quot;);
}</pre></code>
                        <figcaption>Fig 05-034</figcaption>
                    </figure>
                    <p>Now you will only see the Tapped event and the item will not be Selected (no grey background).</p>
                    <p>If we didn't handle the Tapped event either basically by commenting out the two lines inside the
                        ItemTapped event handler:
                    </p>
                    <figure>
                <pre><code class="language-csharp">private void listView_ItemTapped(object sender, ItemTappedEventArgs e)
{
    //var contact = e.Item as Contact;
    //DisplayAlert(&quot;Tapped&quot;, contact.Name, &quot;OK&quot;);
}</pre></code>
                        <figcaption>Fig 05-035</figcaption>
                    </figure>
                    <p>The list wouldn't respond to the Tap or Selected events at all.</p>
                    <p>Next we are going to discuss context actions.</p>
                    <h3>Context Actions</h3>
                    <p>Alright - now let's take our ListView to the next level. If I put my finger to the right of an item
                        and drag it to the left I get two options - Call and Delete:
                    </p>
                    <figure>
                        <img src="./images/05/Fig05-036.png"/>
                        <figcaption>Fig 05-036</figcaption>
                    </figure>
                    <p>These are known as Context Actions. Let's see how to implement these Context Actions. Add another
                        Content Page called ContextActionsPage.xaml:
                    </p>
                    <figure>
<pre><code class="language-csharp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage
        Padding=&quot;0, 20, 0, 0&quot;
        xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
        x:Class=&quot;UdemyXamarinForms.ContextActionsPage&quot;&gt;
    &lt;ListView x:Name=&quot;listView&quot;&gt;
        &lt;ListView.ItemTemplate&gt;
            &lt;DataTemplate&gt;
                &lt;TextCell Text=&quot;{Binding Name}&quot; Detail=&quot;{Binding Status}&quot; &gt;
                    &lt;TextCell.ContextActions&gt;
                        &lt;MenuItem Text=&quot;Call&quot; Clicked=&quot;Call_Clicked&quot; CommandParameter=&quot;{Binding .}&quot; /&gt;
                        &lt;MenuItem Text=&quot;Delete&quot; Clicked=&quot;Delete_Clicked&quot; CommandParameter=&quot;{Binding .}&quot;  IsDestructive=&quot;True&quot;/&gt;
                    &lt;/TextCell.ContextActions&gt;
                &lt;/TextCell&gt;
            &lt;/DataTemplate&gt;
        &lt;/ListView.ItemTemplate&gt;
    &lt;/ListView&gt;
&lt;/ContentPage&gt;</pre></code>
                        <figcaption>Fig 05-037</figcaption>
                    </figure>
                    <p>We use Property Element Syntax to initialize the ContextAction property of TextCell. Inside the
                        element we add two MenuItems - Call and Delete. We add an event handler for the Click event for each
                        MenuItem.
                    </p>
                    <p>For the Delete MenuItem we set another property called IsDestructive to true - this applies different
                        styling to the item (it turns the background Red).
                    </p>
                    <p>If we were to use a custom ViewCell or an ImageCell instead of the TextCell we are using here the
                        implementation would be exactly the same.
                    </p>
                    <p>Next we implement the event handlers in the code-behind First of all Call_Clicked:</p>
                    <figure>
                <pre><code class="language-csharp">private void Call_Clicked(object sender, EventArgs e)
        {
            var menuItem = sender as MenuItem;
            var contact = menuItem.CommandParameter as Contact;

            DisplayAlert(&quot;Call&quot;, contact.Name, &quot;OK&quot;);

        }</pre></code>
                        <figcaption>Fig 05-038</figcaption>
                    </figure>
                    <p>If we look at the signature of the method we will see that unlike the Selected event our EventArgs
                        here do not carry any information about the current item - so how do we get a reference to that
                        item? We can use sender which is actually a MenuItem because this is the item the triggers the
                        event. So the first thing we do is cast sender to MenuItem. How do we get from a MenuItem to a
                        Contact? MenuItem has a property called CommandParameter. In the Xaml we bound the parameter to a
                        contact object:
                    </p>
                    <figure>
                        <pre><code class="language-csharp">CommandParameter=&quot;{Binding .}&quot;</pre></code>
                        <figcaption>Fig 05-039</figcaption>
                    </figure>
                    <p>We bind the CommandParameter to any property of the Contact (Name, Id etc.) but in this example we
                        use the . (period) syntax to bind it to the whole Contact object which will give us access to all
                        properties. We do the same with the Delete MenuItem.
                    </p>
                    <p>Next we assign a new variable called contact to the CommandParameter property:</p>
                    <figure>
                        <pre><code class="language-csharp">var contact = menuItem.CommandParameter as Contact;</pre></code>
                        <figcaption>Fig 05-040</figcaption>
                    </figure>
                    <p>Then we just display an alert:</p>
                    <figure>
                    <pre><code class="language-csharp"> DisplayAlert(&quot;Call&quot;, contact.Name, &quot;OK&quot;);</pre></code>
                        <figcaption>Fig 05-041</figcaption>
                    </figure>
                    <p>In the delete handler we again use the CommandParameter to get access to the Contact object. This
                        time we will combine the casting into one line:
                    </p>
                    <figure>
                    <pre><code class="language-csharp">var contact = (sender as MenuItem).CommandParameter as Contact;</pre></code>
                        <figcaption>Fig 05-042</figcaption>
                    </figure>
                    <p>We want to remove the item from the list when the Delete MenuItem is clicked. If we scroll to the
                        constructor and have a look at the ItemsSource:
                    </p>
                    <figure>
                        <img src="./images/05/Fig05-043.png"/>
                        <figcaption>Fig 05-043</figcaption>
                    </figure>
                    <p>We will see it is of type IEnumerable which is the interface implemented by almost all Collections.
                        IEnumerable is a very lightweight interface. It only allows us to iterate the collection - it
                        doesn't have methods to add or remove items from a Collection. So how do we remove a Contact from
                        our List? Well if we declare a private field:
                    </p>
                    <figure>
                        <pre><code class="language-csharp">private List&lt;Contact&gt; _contacts;</pre></code>
                        <figcaption>Fig 05-044</figcaption>
                    </figure>
                    <p>Back in the constructor instead of directly setting the ItemsSource we assign our list to the
                        _contacts variable and then separately assign the list.ItemsSource to our _contacts variable (of
                        type List&lt;Contact&gt;):
                    </p>
                    <figure>
                <pre><code class="language-csharp">public ContextActionsPage ()
{
    InitializeComponent ();

    _contacts = new List&lt;Contact&gt;
    {
            new Contact { Name = &quot;Mosh&quot;, ImageUrl = &quot;http://lorempixel.com/100/100/people/1&quot; },
            new Contact { Name = &quot;John&quot;, ImageUrl = &quot;http://lorempixel.com/100/100/people/2&quot;, Status=&quot;Hey let's talk!&quot; }
    };

    listView.ItemsSource = _contacts;
}</pre></code>
                        <figcaption>Fig 05-045</figcaption>
                    </figure>
                    <p>We also have access to the _contacts field from our Delete handler. So we can now use the Remove
                        method of the List type to remove the Contact:
                    </p>
                    <figure>
                        <pre><code class="language-csharp">_contacts.Remove(contact);</pre></code>
                        <figcaption>Fig 05-046</figcaption>
                    </figure>
                    <p>If we run the application and click delete on a Contact the contact still remains in the List. If we
                        we debut the application and look at the _contacts List after the Remove method runs you will see
                        that the Contact is in fact removed successfully from the List - the object in memory is updated.
                        The problem is that the ListView is unaware of this because when we remove an item from a List it
                        does not fire an event and notify other objects about the removal. To solve this problem we need to
                        use a special collection type called ObservableCollection. So let's change the _contacts field from
                        List&lt;Contact&gt; to ObservableCollection&lt;Contact&gt;:
                    </p>
                    <figure>
                        <pre><code class="language-csharp">private ObservableCollection&lt;Contact&gt; _contacts;</pre></code>
                        <figcaption>Fig 05-047</figcaption>
                    </figure>
                    <p>Also, you will need to change the list initialization in the Constructor from List to
                        ObservableCollection.</p>
                    <p>You will need to resolve the System.Collections.ObjectModel namespace. Now, when we add or remove
                        an item from this collection it will fire an event notifying any subscribers interested in this
                        event. The ListView class in XamarinForms is able to work with this ObservableCollection - we don't
                        have to write any code for it. So if we use an ObservableCollection under the hood ListView will
                        be notified and refresh itself.
                    </p>
                    <p>Now if you run the application the item should be removed from the UI as well as the object in
                        memory.</p>
                    <p>Next we will look at how to refresh a list by pulling it down.</p>
                    <h3>Pull to Refresh</h3>
                    <p>In many applications we can refresh a list by swiping (usually with the thumb) from the top of
                        the screen to the bottom. Let's discuss how to implement this in XamarinForms. First create a new
                        Content Page called PullToRefreshPage.xaml:
                    </p>
                    <figure>
                <pre><code class="language-csharp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
    &lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
                 xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
                 x:Class=&quot;UdemyXamarinForms.PullToRefreshPage&quot;&gt;
    &lt;ListView x:Name=&quot;listView&quot; IsPullToRefreshEnabled=&quot;True&quot; Refreshing=&quot;listView_Refreshing&quot;&gt;
        &lt;ListView.ItemTemplate&gt;
            &lt;DataTemplate&gt;
                &lt;TextCell Text=&quot;{Binding Name}&quot; Detail=&quot;{Binding Status}&quot; /&gt;
            &lt;/DataTemplate&gt;
        &lt;/ListView.ItemTemplate&gt;
    &lt;/ListView&gt;
&lt;/ContentPage&gt;</pre></code>
                        <figcaption>Fig 05-048</figcaption>
                    </figure>
                    <p>With the following code-behind:</p>
                    <figure>
                <pre><code class="language-csharp">public partial class PullToRefreshPage : ContentPage
{
    public PullToRefreshPage ()
    {
        InitializeComponent ();

        listView.ItemsSource = GetContacts();
    }

    private void listView_Refreshing(object sender, EventArgs e)
    {
        listView.ItemsSource = GetContacts();
    }

    List&lt;Contact&gt; GetContacts()
    {
        return new List&lt;Contact&gt; {
            new Contact { Name = &quot;Mosh&quot;, ImageUrl = &quot;http://lorempixel.com/100/100/people/1&quot; },
            new Contact { Name = &quot;John&quot;, ImageUrl = &quot;http://lorempixel.com/100/100/people/2&quot;, Status = &quot;Hey let's talk!&quot; }
        };
    }
}</pre></code>
                        <figcaption>Fig 05-049</figcaption>
                    </figure>
                    <p>The first thing we do in the Xaml is set the IsPullToRefresh attribute to true. Next we add the
                        Refreshing event and point to an event handler.</p>
                    <p>In the code-behind we refactor the code in the Constructor which initializes the list out into a
                        method called GetContacts().</p>
                    <p>We call the GetContacts method again in the Refreshing event handler.</p>
                    <p>If we run the application at this stage and pull down the list we just get an activity indicator
                        which just sits  there.</p>
                    <p>To make the activity indicator dissapear once we have refreshed the list we should either set
                        listView.IsRefreshing to false or call the listView.EndRefresh() method. The EndRefresh method
                        internally sets IsRefreshing to false. Which option you choose is down to personal preference.</p>
                    <p>If we run the application again now and pull down the list to refresh - the list refreshes and
                        the activity indicator disappears.</p>
                    <p>Next we will look at how to add a search bar to the top of the list.</p>
                    <h3>Search Bar</h3>
                    <p>Finally we will look at how to add a search bar to the top of the list that will filter the list
                        based on the search criteria we add.</p>
                    <p>Add a new Content Page called SearchBarPage:</p>
                    <figure>
                <pre><code class="language-csharp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage
    Padding=&quot;0, 20, 0, 0&quot;
    xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;UdemyXamarinForms.SearchBarPage&quot;&gt;
    &lt;StackLayout&gt;
        &lt;SearchBar Placeholder=&quot;Search...&quot; TextChanged=&quot;SearchBar_TextChanged&quot; x:Name=&quot;searchBar&quot;/&gt;
        &lt;ListView x:Name=&quot;listView&quot;&gt;
            &lt;ListView.ItemTemplate&gt;
                &lt;DataTemplate&gt;
                    &lt;TextCell Text=&quot;{Binding Name}&quot; Detail=&quot;{Binding Status}&quot; /&gt;
                &lt;/DataTemplate&gt;
            &lt;/ListView.ItemTemplate&gt;
        &lt;/ListView&gt;
    &lt;/StackLayout&gt;
&lt;/ContentPage&gt;</pre></code>
                        <figcaption>Fig 05-050</figcaption>
                    </figure>
                    <p>With the following code-behind:</p>
                    <figure>
                <pre><code class="language-csharp">public partial class SearchBarPage : ContentPage
{
    public SearchBarPage ()
    {
        InitializeComponent ();

        listView.ItemsSource = GetContacts();
        searchBar.HeightRequest = 25;
    }

    IEnumerable&amp;lt;Contact&amp;gt; GetContacts(string searchText = null)
    {
        var contacts = new List&amp;lt;Contact&amp;gt; {
            new Contact { Name = &amp;quot;Mosh&amp;quot;, ImageUrl = &amp;quot;http://lorempixel.com/100/100/people/1&amp;quot; },
            new Contact { Name = &amp;quot;John&amp;quot;, ImageUrl = &amp;quot;http://lorempixel.com/100/100/people/2&amp;quot;, Status = &amp;quot;Hey let's talk!&amp;quot; }
        };

        if (String.IsNullOrWhiteSpace(searchText))
        {
            return contacts;
        }
        else
        {
            return contacts.Where(c =&amp;gt; c.Name.StartsWith(searchText));
        }
    }

    private void SearchBar_TextChanged(object sender, TextChangedEventArgs e)
    {
        listView.ItemsSource = GetContacts(e.NewTextValue);
    }
}</pre></code>
                        <figcaption>Fig 05-051</figcaption>
                    </figure>
                    <p>Firstly, in the Xaml, we added a SearchBar element. Now because we have multiple elements on this
                        page we need to wrap them in a StackLayout so we do that next.</p>
                    <p>The SearchBar as several properties that may be of interest:</p>
                    <ul>
                        <li>Placecholder (which in this example we set to &quot;Search...&quot;)</li>
                        <li>PlaceholderColor</li>
                        <li>TextColor</li>
                        <li>FontSize</li>
                        <li>FontFamily</li>
                    </ul>
                    <p>Next we add the TextChanged event to implement searching.</p>
                    <p>In the code-behind we call GetContacts in the Constructor (as in previous demos) to initialize
                        the listView.</p>
                    <p>To implement searching we added a searchString parameter to the GetContacts method (we make it
                        optional by setting it to null in the method definition). Next we check if the searchText is
                        EmptyOrWhitespace - in this case we return all contacts.
                    </p>
                    <p>If a searchText has been specified then we use LINQ to filter our List. The Where method returns
                        an IEnumerable. This is why we have changed our GetContacts method to return an IEnumerable where it
                        previously returned a List. We could have added ToList onto the end of our LINQ statement - however
                        in this instance we don't really need the List functionality. In the constructor we simply call
                        GetContacts() to get an IEnumerable of Contact. That's the data type for ItemsSource.</p>
                    <p>One more thing to note is that in this demo you are hard coding a list of Contacts as part of the
                        class. In a real world application that's rarely the case. Usually the Contact data would be stored
                        locally on the mobile device or somewhere else that we can access using a remote service.</p>
                    <p>In our TextChanged event handler we have an argument - TextChangedEventArgs e. From this we can
                        access the NewTextValue and OldTextValue of the searchBar. We get the NewTextValue and pass it
                        to our GetContacts method as the searchText. Remember, this returns an IEnumerable of Contact
                        which we can assign to our listView.ItemsSource.
                    </p>
                    <p>Now run the application and you should see the application filtering when you type text into the
                        SearchBar.</p>
                    <p>There is another event on the SearchBar - SearchButtonPressed which will fire when the Search
                        button is clicked to filter the records. These days the TextChanged event is generally the
                        preferred method.</p>
                    <p>There is currently a known bug in XamarinForms that affects Android devices running Nougat 7.0 which
                        you can find details of <a
                                href="https://forums.xamarin.com/discussion/79446/is-there-support-for-searchbar-on-nougat-7-0" >
                            here</a>. To workaround this I added a HeightRequest for the SearchBar - without this the
                        SearchBar was not visible on my Motorola G4.</p>
                    <h3>Cheat Sheet</h3>
                    <p></p>
                    <h3>Exercise - Airbnb's Recent Searches</h3>
                    <p></p>
                </div>
            </div>
        </div>
    </div>
</body>
</html>