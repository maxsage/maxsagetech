<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>maxsagetech - Vue JS Fundamentals</title>
  <script src="https://unpkg.com/vue"></script>
  <!--<link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"-->
  <!--integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" rel="stylesheet">-->
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>

    img {
      max-width: 100%;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="panel-group">
      <div class="panel panel-primary">
        <div class="panel-heading">
          <h2>View/ViewModel Communication in WPF</h2>
        </div>
        <div class="panel-body">
          <h3>Introduction</h3>
          <p>Hi and welcome back to this fourth module in WPF MVVM in Depth. The focus in this module will be on how to
            add interactivity to your MVVM apps, how to cleanly call logic that is implemented in the ViewModel when
            something happens in the View as well as letting the View know when something happens behind the scenes in
            your ViewModel, Model Objects or Client Services. And you'll see that all of this is done maintaining that
            loose coupling and good structuring that's at the heart of the MVVM pattern.
          </p>
          <p>
            First up we'll talk about Commands a bit more. You saw a quick example of using a Command to invoke some
            logic in the ViewModel object in the demos of the second module. In this module I'll go a bit deeper looking
            at how things get hooked up, what happens under the covers during that hook-up, how to use Command Enabling
            and Keyboard Shortcuts.
          </p>
          <p>
            Next we will look at Attached Properties and Behaviors covering what the relationship between them is, what
            their general capabilities are and how to use them in the context of MVVM as another means of setting up
            communication paths between the View elements and View Model logic or vice a versa.
          </p>
          <p>
            We will finish the module with a review of how Property Change Notifications work with Data Binding in WPF
            and show how they can be used as a signalling mechanism from the ViewModel to make things happen in the View
            at the appropriate time.
          </p>
          <h3>Commands for View to ViewModel Communication</h3>
          <p>
            The Command pattern has been a well-documented and frequently used design pattern for a couple of decades’
            now and is especially prevalent in UI frameworks. In that pattern there are two main actors - the invoker
            and the receiver:
          </p>
          <figure>
            <img src="./images/Fig04-001.png"/>
            <figcaption>Fig 04-001</figcaption>
          </figure>
          <ul>
            <li>Invoker – whatever piece of code wants to cause some imperative logic to be executed. Typically, the
              Invoker is a UI element that the user interacts with in the context of the UI framework. It could also
              just be another chunk of logic code somewhere in the application.
            </li>
            <li>Receiver – the logic that is intended for execution when the Invoker fires. In the context of MVVM the
              Receiver is typically a method in your ViewModel or in a Client Service that needs to be called.
            </li>
          </ul>
          <p>
            In between the Invoker and Receiver, you have an abstraction layer that makes it so the Invoker and Receiver
            do not have to explicitly know about each other. This is typically represented as an Interface abstraction
            exposed to the Invoker and a concrete implementation of that interface is capable of calling the Receiver in
            the delegating fashion.
          </p>
          <p>In XAML frameworks like WPF ICommand is a built-in Interface of the platform and while WPF does have some
            built-in implementations of concrete Commands called Routed Commands they are not designed with the
            delegating capability needed to be used cleanly with MVVM. What you will typically use in MVVM is a Command
            Type that uses .NET delegates to be able to point to the handling method that resides in your ViewModel.
            Depending on whether you write your own or use a popular MVVM framework these are typically named either
            DelegateCommand or RelayCommand.
          </p>
          <p>
            The key thing about Commands is that they support a decoupled way of calling from the View to the ViewModel.
            As a side benefit the implementation in XAML also supports driving whether the associated Control is enabled
            or disabled through the same decoupled interface.
          </p>
          <p>Let's take a deeper look at Commands through a demo.</p>

          <h3>Demo: Commands for View to ViewModel Communication</h3>
          <div class="example">
            <div class="input-group">
              <input id="Ex04-001" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 4\MVVMCommsDemo-Commands-Start\MVVMCommsDemo.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex04-001"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <div class="example">
            <div class="input-group">
              <input id="Ex04-002" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 4\MVVMCommsDemo-Commands-End\MVVMCommsDemo.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex04-002"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <p>
            In this demo I'm going to do a deep dive into Commands and demonstrate how to use them to communicate from
            the View down to the ViewModel in a loosely coupled way.
          </p>
          <p>
            The starting point for this demo is the ending point of the demo from the last module where we had our
            CustomerListView hooked up with a DataGrid and a ListBox presenting Customer data from a ViewModel that just
            exposed that Customer data.
          </p>
          <p>
            In the CustomerListView add a Button to delete a Customer. Working with Commands on Buttons is very easy
            because they have a Command Property to hook-up to an ICommand. This means we can expose a property on our
            ViewModel that is an ICommand and bind to it from the Buttons Command Property:
          </p>
          <figure>
            <pre class="prettyprint">Command="Binding DeleteCommand"</pre>
            <figcaption>Fig 04-002</figcaption>
          </figure>
          <p>With this definition we expect to have a DeleteCommand property of type ICommand exposed from our ViewModel
            and as the XAML gets parsed here several things are going to happen.
          </p>
          <ul>
            <li>First it's going to call the get block on that ICommand Property to get a reference to the Command
              object.
            </li>
            <li>Then it's going to call CanExecute() on that Command to determine the initial enabled or disabled state
              of the Command and it will enable or disable the Button as a result.
            </li>
            <li> Then it will subscribe to CanExecuteChanged on that ICommand. This will allow us to be notified in the
              future if the enabled or disabled state of the Command changes.
            </li>
          </ul>
          <p>Next add a Delete Command to the CustomerListViewModel. Add a public property of type ICommand:</p>
          <figure>
            <pre class="prettyprint">public ICommand DeleteCommand { get; private set; }</pre>
            <figcaption>Fig 04-003</figcaption>
          </figure>
          <p>It has a private setter because the Property should only be set one time inside the ViewModel upon
            construction.
          </p>
          <p>
            We need a concrete type that implements ICommand to put into that property. The one we will use in the demo
            is already in the project in the download code and is called RelayCommand:
          </p>
          <figure>
                <pre class="prettyprint">public class RelayCommand : ICommand
{
    Action _TargetExecuteMethod;
    Func&lt;bool&amp;gt; _TargetCanExecuteMethod;

                  public RelayCommand(Action executeMethod) { _TargetExecuteMethod=executeMethod; }

                  public RelayCommand(Action executeMethod, Func&amp;lt;bool&amp;gt; canExecuteMethod) {
                  _TargetExecuteMethod=executeMethod; _TargetCanExecuteMethod=canExecuteMethod; }

                  public void RaiseCanExecuteChanged() { CanExecuteChanged(this, EventArgs.Empty); }
    // ICommand Members
}

public class RelayCommand&amp;lt;T&amp;gt; : ICommand
{</pre>
            <figcaption>Fig 04-004</figcaption>
          </figure>
          <p>
            This is a simple delegating implementation of ICommand where we have two delegates – one for the Execute
            method and one for the CanExecute method. Those can be passed through on construction and you can see there
            are two overloaded constructors – one for only an Execute method and one for an Execute method and a
            CanExecute method.
          </p>
          <p>The implementation of ICommand is fairly straightforward:</p>
          <figure>
                <pre class="prettyprint">bool ICommand.CanExecute(object parameter)
{
    if (_TargetCanExecuteMethod != null)
    {
        return _TargetCanExecuteMethod();
    }
    if (_TargetExecuteMethod != null)
    {
        return true;
    }
    return false;
}

// Beware - should use weak references if command instance lifetime is longer than lifetime of UI objects that get hooked up to command
// Prism commands solve this in their implementation
public event EventHandler CanExecuteChanged = delegate { };

void ICommand.Execute(object parameter)
{
    if (_TargetExecuteMethod != null)
    {
        _TargetExecuteMethod();
    }
}</pre>
            <figcaption>Fig 04-005</figcaption>
          </figure>
          <p>
            When either of the methods are invoked it just checks to see if there is a method for that delegate and
            invokes it. And in the case of the CanExecute method if there is no delegate for that it will return true
            meaning that it’s always enabled.
          </p>
          <p>
            Back in CustomerListViewModel change the DeleteCommand to be of type RelayCommand instead of just ICommand:
          </p>
          <figure>
            <pre class="prettyprint">public RelayCommand DeleteCommand { get; private set; }</pre>
            <figcaption>Fig 05-005A</figcaption>
          </figure>
          <p>Now we need to construct an instance and put it into that property; we will do this in the constructor.
          </p>
          <figure>
                <pre class="prettyprint">public CustomerListViewModel()
{
    if (DesignerProperties.GetIsInDesignMode(
        new System.Windows.DependencyObject())) return;

    Customers = new ObservableCollection&lt;Customer&gt;( _repository.GetCustomersAsync().Result);
    DeleteCommand = new RelayCommand(OnDelete,CanDelete);

}</pre>
            <figcaption>Fig 04-006</figcaption>
          </figure>
          <p>
            We could just use the constructor that only takes an Execute method (which we will call OnDelete) and the
            Command would then always be enabled. However, because we are going to hook-up enable/disable logic shortly
            we will also supply a CanExecute method called CanDelete.
          </p>
          <p>Now we can stub the methods out:</p>
          <figure>
                <pre class="prettyprint">private void OnDelete()
{
    Customers.Remove(SelectedCustomer);
}

private bool CanDelete()
{
    return true;
}</pre>
            <figcaption>Fig 04-007</figcaption>
          </figure>
          <p>For the moment we will just return true from CanDelete.</p>
          <p>
            The ViewModel will need some context of what Customer is it supposed to be deleting from the Collection. A
            Command can take an argument, the signature of the CanExecute and Execute methods on ICommand have a single
            argument of type object. We could pass down an argument using the Command parameter property of the Button.
            However, we will take a different approach which is more in tune with the way MVVM works.
          </p>
          <p>
            We are going to expose another property (called SelectedCustomer) from our ViewModel that our View can bind
            to. That way the ViewModel will always know what the current context is in terms of selection:
          </p>
          <figure>
                <pre class="prettyprint">private Customer _selectedCustomer;
public Customer SelectedCustomer
{
    get
    {
        return _selectedCustomer;
    }
    set
    {
        _selectedCustomer = value;
    }
}</pre>
            <figcaption>Fig 04-008</figcaption>
          </figure>
          <p>So I've added a new SelectedCustomer property and we can go over to the View now and set it up so it's
            always being populated when selections are made in the DataGrid. To do that I just drop over to my View, go
            to my DataGrid and set the SelectedItem property bound to the SelectedCustomer Property on my ViewModel.
          </p>
          <figure>
                <pre class="prettyprint"> &lt;DataGrid x:Name=&quot;customerDataGrid&quot;
          AutoGenerateColumns=&quot;False&quot;
          ItemsSource=&quot;{Binding Customers}&quot;
          SelectedItem=&quot;{Binding SelectedCustomer}&quot;
          Grid.Row=&quot;1&quot;&gt;
    &lt;DataGrid.Columns&gt;
        &lt;DataGridTextColumn Binding=&quot;{Binding FirstName}&quot;
                            Header=&quot;First Name&quot;
                            Width=&quot;SizeToHeader&quot; /&gt;
        &lt;DataGridTextColumn Binding=&quot;{Binding LastName}&quot;
                            Header=&quot;Last Name&quot;
                            Width=&quot;SizeToHeader&quot; /&gt;</pre>
            <figcaption>Fig 04-009</figcaption>
          </figure>
          <p>Now the ViewModel will always be in tune with what the selection is and it can use that as the context for
            the Command.
          </p>
          <p>So now I can drop back over to the ViewModel to the OnDelete method and simply remove the SelectedCustomer
            from the Customer Collection when the Delete button is pressed and the Command fires.
          </p>
          <figure>
                <pre class="prettyprint"> private void OnDelete()
{
    Customers.Remove(SelectedCustomer);
}

private bool CanDelete()
{
    return SelectedCustomer != null;
}</pre>
            <figcaption>Fig 04-010</figcaption>
          </figure>
          <p>
            Now if you run the application, select a Customer and click Delete it is removed from both the DataGrid and
            ListBox since both controls are both bound to the same collection – which is an Observable Collection so it
            will raise collection changed events whenever an item is added or removed from the Collection. However, one
            problem with our current implementation is that the Delete button is always enabled (even if no Customer is
            selected). We will address that now.
          </p>
          <p>
            We need to make it so the CanDelete logic is driven by whether a Customer is selected or not. Since we
            already have that context through our SelectedCustomer property we should be able to check that property for
            null and return true or false accordingly:
          </p>
          <figure>
                <pre class="prettyprint">private bool CanDelete()
{
    return SelectedCustomer != null;
}</pre>
            <figcaption>Fig 04-011</figcaption>
          </figure>
          <p>
            However, if we run the application now and select a customer the button remains disabled. This is because
            CanExecute is called when the binding is first evaluated as the XAML is being parsed and it subscribes to
            the CanExecuteChanged event. However, this won’t be checked again unless you call the CanExecuteChanged
            event.
          </p>
          <p>In the ViewModel we know that the SelectedCustomer is going to be set through our other binding so if we
            just drop in here to the set block inside the SelectedCustomer property and call RaiseCanExecuteChanged on
            the Command we'll be good to go:
          </p>
          <figure>
                <pre class="prettyprint">set
{
    _selectedCustomer = value;
    DeleteCommand.RaiseCanExecuteChanged();
}</pre>
            <figcaption>Fig 04-012</figcaption>
          </figure>
          <p>
            Now if you run the application again the button will be initially disabled, then when a selection is made
            the button becomes enabled, if you click delete the button becomes disabled.
          </p>
          <p>Lastly we will hook-up input gestures to trigger your bindings such as keyboard shortcuts. In the View add
            InputBindings as a collection on the Root element.
          </p>
          <figure>
                <pre class="prettyprint">&lt;UserControl.InputBindings&gt;
    &lt;KeyBinding Key=&quot;D&quot;
                Modifiers=&quot;Control&quot;
                Command=&quot;{Binding DeleteCommand}&quot; /&gt;
&lt;/UserControl.InputBindings&gt;</pre>
            <figcaption>Fig 04-013</figcaption>
          </figure>
          <p>
            The primary type of InputBinding you will use will probably be a KeyBinding which is a keyboard shortcut.
            Those are called key bindings and you can see you can set the Key and Modifiers (in this case Control D) as
            the keystroke that's gonna trigger our delete Command and then we just point to same Command property that
            we did with the Button making it an alternate invoker of that command.
          </p>
          <p>
            With that in place, we can run, I can make a selection, hit Ctrl + D and it deletes the same as clicking the
            button does. So that's how you use Commands to communicate from your View to your ViewModel to invoke some
            logic down in the ViewModel.
          </p>
          <h3>Attached Properties and Behaviors</h3>
          <p>
            Now let’s talk about Attached Properties and Behaviors and how they form a communication path between Views
            and ViewModels for scenario’s where Commands and Property Change Notifications are not sufficient. Attached
            Properties are a special kind of Dependency Property and are a fundamental part of all XAML platforms. They
            can be defined in any class and then applied to any object that derives from Dependency Object (which all UI
            elements do). Attached Properties are used for a lot of things in XAML including:
          </p>
          <ul>
            <li>Grid Layout</li>
            <li>Tool Tip Behaviors</li>
            <li>Text Formatting</li>
          </ul>
          <p>
            They also form the basis for Custom Behaviors because when an Attached Property is set on some element you
            can wire up a change handler that can make programmatic calls against the exposed API of the control it’s
            being attached to doing things like subscribing to events or setting properties on the control.
          </p>
          <p>
            As a result, you can create what is called a Behavior with just a custom Attached Property but the more
            common way is to leverage the Blend SDK to create them. Even when you use the Blend SDK Blend Behaviors get
            attached to UI elements through Attached Properties which are defined in the SDK. Behaviors can expose their
            own Dependency Properties and thus form a communication bridge between Views and ViewModels because the
            Behavior can subscribe to events on the element it’s attached to or monitor property changes on it and can
            despatch calls into the ViewModel as a result either through Commands by setting a data-bound property on
            the Behavior that points to the ViewModel or by directly invoking a method on the ViewModel.
          </p>
          <p>
            In the other direction the Behavior can be bound to a Property exposed by the ViewModel that is either an
            interface with events on it or just a data property that raises property or collection changed events. Code
            in the Behavior can use that as a trigger to go do something on the element on which the Behavior is
            attached or some other element or elements in the UI that are reachable through the Visual tree of that
            Behaviours element.
          </p>
          <p>
            I'm sure thats all a little abstract if you have never worked with or implemented behaviours before. So
            let's take a look at a couple of demos that will make this all a bit more concrete.
          </p>
          <h3>Demo: Custom Attached Behavior</h3>
          <div class="example">
            <div class="input-group">
              <input id="Ex04-003" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 4\MVVMCommsDemo-Behaviors-Start\MVVMCommsDemo.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex04-003"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <div class="example">
            <div class="input-group">
              <input id="Ex04-004" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 4\MVVMCommsDemo-Behaviors-End\MVVMCommsDemo.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex04-004"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <p>
            In this demo we will look at the basis of Behaviors with Attached Properties and how they can be used
            communicate between View and ViewModel. The thing we are going to try and achieve is to make it so the
            ViewModel can handle the Loaded event and defer loading of the data until the loaded event of the View has
            fired. To do that we are going to start off by creating an Attached Property in a separate public static
            class called MvvmBehaviors.
          </p>
          <p>Next use the propa Visual Code snippet that is built into Visual Studio to create an Attached Property
            called LoadedMethodName. Make it of type string:
          </p>
          <figure>
                <pre class="prettyprint">public static class MvvmBehaviors
{
    public static string GetLoadedMethodName(DependencyObject obj)
    {
        return (string)obj.GetValue(LoadedMethodNameProperty);
    }

    public static void SetLoadedMethodName(DependencyObject obj, string value)
    {
        obj.SetValue(LoadedMethodNameProperty, value);
    }

    public static readonly DependencyProperty LoadedMethodNameProperty =
        DependencyProperty.RegisterAttached(&quot;LoadedMethodName&quot;,
        typeof(string), typeof(MvvmBehaviors), new PropertyMetadata(null));</pre>
            <figcaption>Fig 04-014</figcaption>
          </figure>
          <p>
            Now to make this attached property a behaviour we need to wire up a change handler. So we'll go into the
            Property meta data and say my change handler is going to be named OnLoadedMethodNameChanged.
          </p>
          <figure>
                <pre class="prettyprint"> public static readonly DependencyProperty LoadedMethodNameProperty =
    DependencyProperty.RegisterAttached(&quot;LoadedMethodName&quot;,
    typeof(string), typeof(MvvmBehaviors), new PropertyMetadata(null, OnLoadedMethodNameChanged));</pre>
            <figcaption>Fig 04-015</figcaption>
          </figure>
          <p>
            Stub the method out. Now in the new method we expect this Attached Property to be set on our View so we want
            to handle the Views Loaded event inside the change handler. Once we handle the Change event we want to
            invoke a method on the ViewModel. We know that the ViewModel should be the DataContext of that View. So we
            can get that ViewModel and use reflection to invoke a method with the specified method name on it:
          </p>
          <figure>
                <pre class="prettyprint">private static void OnLoadedMethodNameChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
{
    FrameworkElement element = d as FrameworkElement;
    if (element != null)
    {

        element.Loaded += (s, e2) =&gt;
        {
            var viewModel = element.DataContext;
            if (viewModel == null) return;
            var methodInfo = viewModel.GetType().GetMethod(e.NewValue.ToString());
            if (methodInfo != null) methodInfo.Invoke(viewModel, null);
        };
    }
}</pre>
            <figcaption>Fig 04-016</figcaption>
          </figure>

          <p>
            This code takes the d argument that comes into the change handler which will be the object on which the
            Attached Property was set and tries to cast that to Framework Element. As long as that succeeds we know the
            Framework Element has a Loaded event and it also has a DataContext. We subscribe to the Loaded event and
            when that Loaded event fires we get the DataContext. As long as that isn’t null we use reflection to get a
            reference to the Method of the name that is being set for LoadedMethodName. Once we have that reference we
            can just invoke it through reflection.
          </p>
          <p>To use this we need to go over to the CustomerListView add a namespace for the local namespace wherever we
            put the Behavior definition:
          </p>
          <figure>
            <pre class="prettyprint">xmlns:local=&amp;quot&amp;quot;clr-namespace:MVVMCommsDemo&amp;quot;</pre>
            <figcaption>Fig 04-017</figcaption>
          </figure>
          <p>Then in the root element of the View use the Attached Property (LoadedMethodName) and specify the Method
            name that you expect to find in your ViewModel:
          </p>
          <figure>
            <pre class="prettyprint">local:MvvmBehaviors.LoadMethodName=&quot;LoadCustomers&quot;&gt;</pre>
            <figcaption>Fig 04-018</figcaption>
          </figure>
          <p>
            Now we need to add a LoadCustomers method into our ViewModel. In previous demos we were initializing the
            Customers Collection in the constructor of our ViewModel. We had to force that asynchronous method to
            execute synchronously because you cannot use async and await in a constructor.
          </p>
          <p>Now that we are going to add a method that will fire later after construction when the Loaded event of the
            View fires we can move that initialization logic out to that Loaded handler and do it properly async. So cut
            the code out of the constructor, add a LoadCustomers method and paste the code in. Remove the Result
            property that forced the GetCustomerAsync method to run synchronous, put an await in front of the
            GetCustomerAsync method call and make the LoadCustomers method async:
          </p>
          <figure>
                <pre class="prettyprint">public async void LoadCustomers()
{
    if (DesignerProperties.GetIsInDesignMode(
        new System.Windows.DependencyObject())) return;

    Customers = new ObservableCollection&lt;Customer&gt;(await _repository.GetCustomersAsync());

}</pre>
            <figcaption>Fig 04-019</figcaption>
          </figure>
          <p>
            If you set a breakpoint in the method and run the application, you will see the LoadCustomers method is
            being called when the Loaded event of the View is firing. However, there is a problem: Customers aren’t
            populating:
          </p>
          <figure>
            <img src="./images/Fig04-020.png"/>
            <figcaption>Fig 04-020</figcaption>
          </figure>
          <p>This is related to Property Change Events which we will fix in a later module.</p>
          <h3>Demo: Using Blend Behaviors</h3>
          <div class="example">
            <div class="input-group">
              <input id="Ex04-005" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 4\MVVMCommsDemo-Behaviors-Start\MVVMCommsDemo.sln">
              <span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex04-005"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <div class="example">
            <div class="input-group">
              <input id="Ex04-006" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 4\MVVMCommsDemo-Behaviors-End\MVVMCommsDemo.sln">
              <span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex04-006"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <p>
            In the last demo we created a Behavior through Attached Properties. Now let’s look at how you can achieve
            the same thing quickly using the built-in Behaviors of the Blend SDK. To do that we switch to Blend and open
            the same solution. Go to the Projects tab, expand Customers, find the CustomerListView and open it.
          </p>
          <p>
            Now click on the Assets tab, Behaviors, and after selecting the UserControl in the Object and Timeline
            double click the CallMethodAction to add it as a child. Several steps are completed automatically for you at
            this point – Blend has:
          </p>
          <ul>
            <li>Added references to two libraries that are part of the Blend SDK</li>
            <li>Added a XAML XML namespace to facilitate access to those libraries</li>
            <li>Added the CallMethodAction with several lines of XAML to my UserControl</li>
          </ul>
          <p>
            Now, back in Visual Studio, we will finish filling out the properties of that Behavior. In the References
            list in Solution Explorer you will see that it has added the following references:
          </p>
          <ul>
            <li>Microsoft.Expression.Interactions</li>
            <li>System.Windows.Interactivity</li>
          </ul>
          <p>
            These are from the Blend SDK. In the CustomerListView you can see it added corresponding XML namespaces so
            we can access the stuff that is in those libraries from our XAML.
          </p>
          <figure>
                <pre class="prettyprint">xmlns:i=&quot;http://schemas.microsoft.com/expression/2010/interactivity&quot;
xmlns:ei=&quot;http://schemas.microsoft.com/expression/2010/interactions&quot;</pre>
            <figcaption>Fig 04-021</figcaption>
          </figure>
          <p>Scrolling down you see that Blend has added some more XAML:</p>
          <figure>
                <pre class="prettyprint">&lt;i:Interaction.Triggers&gt;
    &lt;i:EventTrigger EventName=&quot;MouseLeftButtonDown&quot;&gt;
        &lt;ei:CallMethodAction /&gt;
    &lt;/i:EventTrigger&gt;
&lt;/i:Interaction.Triggers&gt;</pre>
            <figcaption>Fig 04-022</figcaption>
          </figure>

          <p>
            It added an Attached Property that is a Triggers collection, it added a Trigger with the MouseLeftButtonDown
            which we need to change to the Loaded event. It also added a CallMethodAction. The CallMethodAction needs to
            know what it is going to call so we need to set the TargetObject property and MethodName property:
          </p>
          <p>
            We set the TargetObject to binding (just setting it to Binding in curly braces means the entire DataContext
            object – our ViewModel in this example). Then we set the MethodName property which we set to the
            LoadCustomers method (achieving the same thing as our Attached Behaviour did):
          </p>
          <figure>
            <pre class="prettyprint">&lt;ei:CallMethodAction TargetObject=&quot;{Binding}&quot; MethodName=&quot;LoadCustomers&quot; /&gt;</pre>
            <figcaption>Fig 04-023</figcaption>
          </figure>
          <p>
            Now remove the Attached Behavior from the root and run the application. We still have the bug where the
            Customers aren’t showing but we will fix that after we talk about Property Change Events a little bit.
          </p>
          <h3>Property Change Notifications</h3>
          <p>
            Property Change Notifications are essential to data-binding because they notify the binding when the
            underlying data has changed so that the binding can refresh and keep the data on screen in sync with the
            underlying data model.
          </p>
          <p>They can also be used to signal the View or a Behavior in the View to make some change not directly related
            to data-binding such as:
          </p>
          <ul>
            <li>Changing the visibility of some element</li>
            <li>Kicking off an animation</li>
            <li>Causing a visual state change</li>
          </ul>
          <p>
            There are two options for raising Property Change Notifications that a binding will automatically monitor.
            First is to make the Property a Dependency Property which has its own internal change notification mechanism
            that bindings are natively aware of. Second is to implement the INotifyPropertyChanged (INPC) Interface
            which requires declaration of a Property Changed event and firing that event in the set block of each
            Property on the object.
          </p>
          <p>
            For your ViewModel and Model objects in MVVM INotifyPropertyChanged is more appropriate because Dependency
            Property declarations are verbose and require your object to inherit from Dependency Object both of which
            make it a heavyweight approach to achieve the goal of change notifications in Model and ViewModel objects.
          </p>
          <h3>Demo: Leveraging INotifyPropertyChanged</h3>
          <div class="example">
            <div class="input-group">
              <input id="Ex04-008" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 4\MVVMCommsDemo-PropertyChanged-Start\MVVMCommsDemo.sln">
              <span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex04-008"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <div class="example">
            <div class="input-group">
              <input id="Ex04-009" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 4\MVVMCommsDemo-PropertyChanged-End\MVVMCommsDemo.sln">
              <span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex04-009"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <p>
            In the last demo we hooked up some Behaviors to populate our Customers OnLoaded instead of in the
            constructor. However, we introduced a bug where the Customers were being retrieved but they are not showing
            up on screen. Usually that means that data binding is not being notified when something happens after the
            initial XAML parsing is done - such as the Loaded event. To fix this issue all we need to do is make it so
            our ViewModel implements INotifyPropertyChanged. So modify CustomerListViewModel so that it implements
            INotifyPropertyChanged:
          </p>
          <figure>
            <pre class="prettyprint">public class CustomerListViewModel : INotifyPropertyChanged</pre>
            <figcaption>Fig 04-024</figcaption>
          </figure>
          <p>
            Stub the method out using the Visual Studio Ctrl +. enter shortcut. This will add the PropertyChanged event
            to the bottom of our class. Next we use a delegate trick where we assign an empty anonymous method in as a
            subscriber. That means that subscriber is always in the list and you never have to worry about property
            change being null:
          </p>
          <figure>
            <pre
              class="prettyprint">public event PropertyChangedEventHandler PropertyChanged = delegate { };</pre>
            <figcaption>Fig 04-025</figcaption>
          </figure>
          <p>
            Now we need to go to the properties of our ViewModel and fire that event when they change. Since you are now
            going to be raising an event when they change you need to make sure the value actually changed:
          </p>
          <figure>
                <pre class="prettyprint">public ObservableCollection&lt;Customer&gt; Customers
{
    get
    {
        return _customers;
    }
    set
    {
        if (_customers != value)
        {
            _customers = value;
            PropertyChanged(this, new PropertyChangedEventArgs(&quot;Customers&quot;));
        }
    }
}</pre>
            <figcaption>Fig 04-026</figcaption>
          </figure>
          <p>
            We compare the value being set to the current value of the underlying member variable as long as it is
            different than we set our member variable and raise the PropertyChanged event signalling that it is for this
            particular property.
          </p>
          <p>
            For completeness, you can do the same thing for the SelectedCustomer. This isn't really necessary since the
            SelectedCustomer is always set by the View but you should really have all the publicly exposed properties on
            your INotifyPropertyChanged object follow the pattern.
          </p>
          <p>
            Now that we raise PropertyChanged when Customers are set after the fact in the Loaded event we can start up
            and see that our problem is fixed. Now our Customers populate, and they do so asynchronously in the Loaded
            event handler showing the data once the Customers property has been set because the binding was notified
            about the event.
          </p>
          <p>
            Another place where you might need to do this is in your Model objects. Let's say we have another button on
            our screen that ends up changing a customer object behind the scenes:
          </p>
          <figure>
                <pre class="prettyprint">&lt;Button Content=&quot;Change Customer&quot;
    HorizontalAlignment=&quot;Left&quot;
    Margin=&quot;80,0,0,0&quot;
    VerticalAlignment=&quot;Top&quot;
    Width=&quot;100&quot;
    Click=&quot;OnChangeCustomer&quot; /&gt;
                </pre>
            <figcaption>Fig 04-027</figcaption>
          </figure>
          <p>For speed (but anti-MVVM) we will hook-up a change event in the code-behind:</p>
          <figure>
                <pre class="prettyprint">private void OnChangeCustomer(object sender, RoutedEventArgs e)
{
    var cust = customerDataGrid.SelectedItem as Customer;
    cust.FirstName = &quot;Changed in background&quot;;
}</pre>
            <figcaption>Fig 04-028</figcaption>
          </figure>
          <p>
            We are really just doing this to emphasize how there are potentially different code paths in your
            application that end up modifying the objects that you are binding to and when that happens those objects
            also need to raise change events or the screen wont update.
          </p>
          <p>
            In the code above we are taking the selected item in the DataGrid, getting a reference to it and
            programmatically setting the FirstName to "Changed in background".
          </p>
          <p>
            If you now run the application and click the Change Customer button the name doesn't change on screen even
            though we know in the background the FirstName property has been changed. We can fix this by going to our
            Customer Model object definition and ensure that it also implements INotifyPropertyChanged, stub the method
            out, and use the delegate trick again:
          </p>
          <figure>
            <pre
              class="prettyprint">public event PropertyChangedEventHandler PropertyChanged = delegate { };</pre>
            <figcaption>Fig 04-029</figcaption>
          </figure>
          <p>
            Now in the FirstName property modify the set block to add the PropertyChanged event. This pattern should
            really be applied to all the properties in the Model but as this is just a demo we will limit our changes to
            the FirstName property.
          </p>
          <p>Now if you run the application, select a customer, and click the Change Customer button you will see the
            screen updates properly.
          </p>
          <h3>Demo: Custom Blend Behavior with INotifyPropertyChanged Trigger</h3>
          <div class="example">
            <div class="input-group">
              <input id="Ex04-010" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 4\MVVMCommsDemo-CustomBehavior-Start\MVVMCommsDemo.sln">
              <span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex04-010"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <div class="example">
            <div class="input-group">
              <input id="Ex04-011" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 4\MVVMCommsDemo-CustomBehavior-End\MVVMCommsDemo.sln">
              <span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex04-011"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <p>
            In this demo we will show the combination of Property Changed Notifications as a communication method from
            ViewModel to View and a Custom Behavior using the Blend SDK. The scenario we are going to address is one
            where we want to send alerts to the screen when stuff happens in the background. To do that we are going to
            need a Custom Behavior that show the alerts as they arrive in a Content Control. To create a Custom Behavior
            using the Blend SDK you have to reference the Blend SDK (which we did in a previous demo).
          </p>
          <p>
            Add a new class called ShowNotificationMessageBehavior. Make the class public and inherit from Behavior of T
            where T is a ContentControl:
          </p>
          <figure>
            <pre
              class="prettyprint">public class ShowNotificationMessageBehavior : Behavior&lt;ContentControl&gt;</pre>
            <figcaption>Fig 04-029A</figcaption>
          </figure>
          <p>Next, using the propp code snippet, expose a property on the Behavior called Message of type string which
            can be set on the ViewModel through data binding (which means it will need to be a Dependency Property):
          </p>
          <figure>
                <pre class="prettyprint">public string Message
{
    get { return (string)GetValue(MessageProperty); }
    set { SetValue(MessageProperty, value); }
}

public static readonly DependencyProperty MessageProperty =
    DependencyProperty.Register(&quot;Message&quot;, typeof(string),
    typeof(ShowNotificationMessageBehavior), new PropertyMetadata(null, OnMessageChanged));</pre>
            <figcaption>Fig 04-029B</figcaption>
          </figure>
          <p>
            Now we want to add a change handler called OnMessageChanged so that we can monitor changes on this property
            and make the appropriate changes in the View when it happens.
          </p>
          <figure>
                <pre class="prettyprint">private static void OnMessageChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
{
    var behavior = ((ShowNotificationMessageBehavior)d);</pre>
            <figcaption>Fig 04-030</figcaption>
          </figure>
          <p>
            We take the incoming d object which will be the class on which this Dependency Property is defined – which
            is our Behavior and cast it to that. That lets us get to a property on our base class called
            AssociatedObject which will be a strongly typed reference to the ContentControl that you use this Behavior
            on.
          </p>
          <figure>
                <pre class="prettyprint">var behavior = ((ShowNotificationMessageBehavior)d);
behavior.AssociatedObject.Content = e.NewValue;
behavior.AssociatedObject.Visibility = Visibility.Visible;</pre>
            <figcaption>Fig 04-030A</figcaption>
          </figure>
          <p>
            Using that we can set the content to the value of the Message that was set and we can change its visibility
            to visible making it pop open in the UI. We also want to make our notification click dismissible so we are
            going to add another handler - an override of the base class OnAttached() method. In the OnAttached method
            we can subscribe to events on the element to which we attached this Behavior. In this case MouseLeftButton
            down as a click dismiss and change the visibility to collapsed at that point.
          </p>
          <figure>
                <pre class="prettyprint">protected override void OnAttached()
{
    AssociatedObject.MouseLeftButtonDown += (s, e) =&gt;
        AssociatedObject.Visibility = Visibility.Collapsed;
}</pre>
            <figcaption>Fig 04-031</figcaption>
          </figure>
          <p>
            Now we need a Content Control to put this on. In the MainWindow View replace the current ContentControl with
            a two row Grid and a new ContentControl in the top row above our existing ContentControl in the bottom row:
          </p>
          <figure>
                <pre class="prettyprint">&lt;Grid&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height=&quot;Auto&quot; /&gt;
        &lt;RowDefinition /&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;ContentControl&gt;
        &lt;i:Interaction.Behaviors&gt;
            &lt;local:ShowNotificationMessageBehavior Message=&quot;{Binding NotificationMessage}&quot; /&gt;
        &lt;/i:Interaction.Behaviors&gt;
    &lt;/ContentControl&gt;
    &lt;ContentControl Content=&quot;{Binding CurrentViewModel}&quot;
                    Grid.Row=&quot;1&quot; /&gt;

    &lt;!--&lt;Customers:CustomerListView /&gt;--&gt;
&lt;/Grid&gt;</pre>
            <figcaption>Fig 04-032</figcaption>
          </figure>
          <p>
            On that ContentControl you can see we add the InteractionBehaviors Collection (similar to the Triggers
            Attached Property we saw in a previous demo). We put our Behavior inside of that and we combine the Message
            property of our Behavior to something we expect our ViewModel to expose. We need to add some namespaces to
            the top of the file to bring in the i prefix (we can steal those from the previous View that already has a
            Behavior in it). I also need to add in the i prefix pointing to the Interactivity namespace which the
            Behaviors Attached Property resides in.
          </p>
          <figure>
            <pre class="prettyprint">xmlns:i=&quot;http://schemas.microsoft.com/expression/2010/interactivity&quot;</pre>
            <figcaption>Fig 04-033</figcaption>
          </figure>
          <p>
            Now we need to implement the NotificationMessage in the MainWindowViewModel class. Make the class inherit
            from INotifyPropertyChanged and add the NotificationMessage Property to the ViewModel:
          </p>
          <figure>
                <pre class="prettyprint">public class MainWindowViewModel : INotifyPropertyChanged
    {
        public MainWindowViewModel()
        {
            CurrentViewModel = new CustomerListViewModel();
        }
        public object CurrentViewModel { get; set; }

        public event PropertyChangedEventHandler PropertyChanged = delegate { };
    }</pre>
            <figcaption>Fig 04-033A</figcaption>
          </figure>

          <p>Because adding properties with the INPC pattern to them is so common I have my own code snippet to do it
            which is propc:
          </p>
          <figure>
                <pre class="prettyprint">private string _NotificationMessage;

public string NotificationMessage
{
    get { return _NotificationMessage; }
    set
    {
        if (value != _NotificationMessage)
        {
            _NotificationMessage = value;
            PropertyChanged(this, new PropertyChangedEventArgs(&quot;NotificationMessage&quot;));
        }
    }
}</pre>
            <figcaption>Fig 04-034</figcaption>
          </figure>

          <p>Type is string, the name of the property is NotificationMessage and you can see that my code snippet stubs
            out the standard INotifyProperty changed pattern in the set block of that property .
          </p>
          <p>
            Now we need to add code that will actually push some values into that NotificationMessage Property. For this
            we will use a simple Timer. Add a Timer that ticks every 5 seconds to the MainWindowViewModel’s constructor:
          </p>
          <figure>
                <pre class="prettyprint"> _timer.Elapsed += (s, e) =&gt; NotificationMessage = &quot;At the tone the time will be: &quot; + DateTime.Now.ToLocalTime() + &quot; beep.&quot;;
_timer.Start();</pre>
            <figcaption>Fig 04-035</figcaption>
          </figure>
          <p>
            Run the application and if you watch the top of the MainWindow you will see the message appear:
          </p>
          <figure>
            <img src="./images/Fig04-036.png"/>
            <figcaption>Fig 04-036</figcaption>
          </figure>
          <p>
            If you left click on the message text you can dismiss it, and five seconds later another one. So our Custom
            Behavior is acting as a nice little bridge between our View and ViewModel for our ViewModel to be able to
            push information up to the View and make modifications in the View but notice it required no code behind to
            do this just a nice declarative modification to a ContentControl using our Behavior.
          </p>
          <h3>Summary</h3>
          <p>
            As you saw in this module you have a variety of ways in which you can handle communication between your
            Views and ViewModels in MVVM that still allow them to remain loosely coupled from one another. You saw that
            Commands are a primary form of communication from View to ViewModel and should typically be used when a user
            action in the View (such as clicking on something, or some kind of input gesture) is really an imperative
            request from the User for the app to do something for them.
          </p>
          <p>
            Behaviors are another way to setup a communication path. Where the Behavior might fire a Command for some
            Control that does not directly support Commands, set a property or call a method on the ViewModel or
            possibly provide a path for the ViewModel to trigger a change in the View
          </p>
          <p>PropertyChanged notifications through a binding can always be used as a communication path to trigger
            behaviour in either direction.
          </p>
          <p>In the next module we'll finish out the structural topics you need to understand to apply MVVM correctly
            including how you should name and locate your MVVM parts, how to build out heirarchies of Views and
            ViewModels and how to work with Dependency Injection in your ViewModels and Services. We'll also touch on an
            overview of what MVVM frameworks are available to you. .
          </p>
        </div>
      </div>
    </div>
  </div>
</body>
</html>