<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>Vue.js Playbook</title>
  <script src="https://unpkg.com/vue"></script>
  <!--<link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"-->
  <!--integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" rel="stylesheet">-->
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
    .example {
      font-weight: bold;
    }
  </style>
</head>
<body>
<div class="container" id="app">
  <div class="panel-group">
    <div class="panel panel-primary">
      <div class="panel-heading">
        <h2>Vue.js Playbook</h2>
      </div>

      <div class="panel-body">
        <div>
          <h2>Filters, Properties, and Watchers</h2>
          <div>
            <h3>
              Introduction
            </h3>
            <p>
              Before we dive into this final module, I want to personally thank you for watching this course. I hope
              you'll reach out to me on Twitter, @chadcampbell, and share your opinions about this course. After you've
              done that, I want to show you what you've learned, and how it all ties together. Then I'll show you some
              final tweaks that'll improve your app. Welcome to the final lap.</p>
            <p>In module 1, I mentioned that a UI for searching fictional beers and breweries would be used to drive
              home the concepts of this course. If you opened the code samples associated with this course, which are
              found here:</p>
            <a href="https://github.com/ecofic/course-vue-getting-started">https://github.com/ecofic/course-vue-getting-started</a>
            <p>You'll notice in the upper right corner is a button that says view full example:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-001.png"/>
              <figcaption>Fig 06-001</figcaption>
            </figure>
            <p>If you click this button, you'll see the following:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-002.png"/>
              <figcaption>Fig 06-002</figcaption>
            </figure>
            <p>
              I'm going to run a search for ale, and press Enter. With some results on the screen, I want to quickly
              show you what you've learned in this course. In module 2, I showed you how to use templates. That
              information was used to render the name of our fictional beer engine, Growler, as shown here:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-003.png"/>
              <figcaption>Fig 06-003</figcaption>
            </figure>
            <p>As a reminder, the color change is based on whether the app can connect to the internet or not. In module
              3, I showed you how to bind to forms. You saw how to use the model directive to bind to HTML input
              elements like text fields. This information was used for the search field in Growler</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-004.png"/>
              <figcaption>Fig 06-004</figcaption>
            </figure>
            <p>You also saw how to use modifiers to handle common development chores and lighten your load. If you look
              next to the query field, you'll see a Search button:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-005.png"/>
              <figcaption>Fig 06-005</figcaption>
            </figure>
            <p>In module 4, you saw how to use event handlers. This empowered you to do things like handle a button
              click. In addition, you saw how to address common scenarios, like a user pressing the Enter key, which may
              be used in place of the Search button. In the case of Growler, if you did either of these things, you'd
              expect a search request to get fired off. While making the actual call to the search service is beyond the
              scope of this course, you still saw how to initiate that process. In addition, this sample app has the
              code to do that if you want to look at it.</p>
            <p>Going even further, if you want to learn how to create the actual search engine behind this button,
              please check out my Pluralsight course, Adding Search Abilities to Your Apps with Azure Search. Either
              way, once results were returned, you need a way to show them.</p>
            <p>In module 5, you saw how to conditionally render content. You saw how to render content conditionally at
              load time, and at runtime. You also saw how to render lists of items. This information could be used to
              render these results in the search engine:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-006.png"/>
              <figcaption>Fig 06-006</figcaption>
            </figure>
            <p>As you can see on the screen, the information you've learned in this course can be used to build a
              functioning app, however, there are a number of things that can be done to improve this app, specifically
              in regards to reacting to data changes.</p>
            <p>In this module, I'm going to show you how to react to data changes. Frist, I'll show you how to monitor
              data changes with watchers. Then, I'll show you how to render templates even faster with something called
              computed properties. Finally, I'll show you how to easily format data in a view using filters.</p>
            <p>This module is ordered this way because it matches how data changes get propagated. In fact, here's a
              diagram to reinforce the data flow:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-007.png"/>
              <figcaption>Fig 06-007</figcaption>
            </figure>
            <p class="example">Module 06 - lifecycle of watchers, computed properties, and filters</p>
            <p>This diagram is here to help you remember the order of operations. Each of the items that will be
              discussed in this module is intended to help you write better code. In fact, each of these items are
              entirely optional. You can achieve similar results using the other material presented in this course,
              however, I believe that once you learn about each of these topics, you'll see better ways to react to data
              changes. With that said, buckle up, we're pushing towards the finish line.
            </p>
          </div>
          <div>
            <h3>
              Monitoring Data Changes with Watchers
            </h3>
            <p>
              In module 3, you learned how to collect data from a user via input bindings. In module 4, you learned how
              to respond to user events like button clicks. You could take the information from these two modules and
              react to a user event that likely results in a data change. This event could be something like a button
              click or a blur event on an input field. There is a more direct and more predicable approach, though.</p>
            <p>Vue provides a way to directly react to a change in the data itself. Watchers are special functions that
              let you react to data property changes. For any data property, you can create a watcher in the watch
              option of a Vue instance. To demonstrate, let's imagine that users could buy beers from a list of beers.
              As a matter of fact, I'm going to switch over to Google Chrome and show you what that screen would look
              like. Now, when I click the buy button, notice that the Subtotal field updates:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-008.png"/>
              <figcaption>Fig 06-008</figcaption>
            </figure>
            <p class="example">Module 06 - Using watched property</p>
            <p class="example">Module 06 - Using watched property with a reference</p>
            <p>Each time I click the buy button, the price of the beer is added to the Subtotal. I want to take a moment
              and explain the code powering this:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-009.png"/>
              <figcaption>Fig 06-009</figcaption>
            </figure>
            <p>To show you all of the code involved on the screen, I have to break this story down across multiple
              slides, so please bear with me. Let's begin by looking at the data that's driving this view:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-010.png"/>
              <figcaption>Fig 06-010</figcaption>
            </figure>
            <p>Each beer in the beers property is rendered as a table row:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-011.png"/>
              <figcaption>Fig 06-011</figcaption>
            </figure>
            <p>Thanks to the for directive. Each table row includes the beer's name, price, and a button:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-012.png"/>
              <figcaption>Fig 06-012</figcaption>
            </figure>
            <p>If clicked, this button will pass the beer to the buy function. The buy function is defined in the
              methods option. That option is depicted by these ellipses:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-013.png"/>
              <figcaption>Fig 06-013</figcaption>
            </figure>
            <p>In reality, it looks like this:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-014.png"/>
              <figcaption>Fig 06-014</figcaption>
            </figure>
            <p>This slide has the methods option now visible. The ellipses represent the data object shown in the last
              slide:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-015.png"/>
              <figcaption>Fig 06-015</figcaption>
            </figure>
            <p>Here you can see the buy function triggered by the button in the template.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-016.png"/>
              <figcaption>Fig 06-016</figcaption>
            </figure>
            <p>If called, this function adds a beer to the user's shopping cart. When the shopping cart is updated, we
              want to update the subTotal property. Now, I could call the updateSubTotal function directly:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-017.png"/>
              <figcaption>Fig 06-017</figcaption>
            </figure>
            <p>If I wanted to, but in reality, there could be other functions that update the shopping cart also. Maybe
              users want to remove items from their cart, or change the number of beers. Either way, instead of calling
              the updateSubTotal function directly, it makes sense to call the function when the shopping cart itself
              changes.</p>
            <p>To do that, I'm going to create a watcher, as shown on this slide:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-018.png"/>
              <figcaption>Fig 06-018</figcaption>
            </figure>
            <p>The ellipses in this slide represent the methods option defined in the last slide. Notice the addition of
              the watch option, though:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-019.png"/>
              <figcaption>Fig 06-019</figcaption>
            </figure>
            <p>The watch option defines a list of watchers. Each key is the name of a property in the data object:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-020.png"/>
              <figcaption>Fig 06-020</figcaption>
            </figure>
            <p>This is the name of the property to monitor for data changes. If a data change happens, the keys value
              defines how to respond to that change. This definition includes the watcher's behavior and depth.
            </p>
          </div>
          <div>
            <h3>
              Defining a Watcher's Behavior'
            </h3>
            <p>
              I want to focus specifically on the watch option in this definition:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-021.png"/>
              <figcaption>Fig 06-021</figcaption>
            </figure>
            <p>If you focus on it, you can see that the behavior of the watcher is defined in a JavaScript function. In
              this case, a basic function is used that calls the updateSubTotal function:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-022.png"/>
              <figcaption>Fig 06-022</figcaption>
            </figure>
            <p class="example">Module 06 - Introductory example</p>
            <p>Technically, since this is all this watcher is doing, it could be simplified like this:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-023.png"/>
              <figcaption>Fig 06-023</figcaption>
            </figure>
            <p class="example">Module 06 - Simplified example</p>
            <p>In this example, the updateSubTotal function is called whenever the shopping cart is updated. When
              updated, Vue looks for the function named updateSubTotal in the methods option. At this point, you may be
              wondering why you would want to associate a full-blown function with a watcher:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-024.png"/>
              <figcaption>Fig 06-024</figcaption>
            </figure>
            <p>The approach on this slide is clearly more compact.
            <p>
            <p>Well, there is an added benefit to using a function. To demonstrate, I want to show you another
              example.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-025.png"/>
              <figcaption>Fig 06-025</figcaption>
            </figure>
            <p class="example">Module 06 - Getting before and after values</p>
            <p>In this example, I've defined a watcher on the subTotal property. Notice that in this watcher I've passed
              two parameters into the watcher function:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-026.png"/>
              <figcaption>Fig 06-026</figcaption>
            </figure>
            <p>When Vue calls a watcher function, it automatically passes in two parameters. I've named those parameters
              latest and original, in this case. Technically, you could give these parameters any valid name you wanted
              to. Still, what's important is what they represent. The first value is the value that the data property
              has been changed to.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-027.png"/>
              <figcaption>Fig 06-027</figcaption>
            </figure>
            <p>In this example, the latest parameter would be the value of the Subtotal including an added beer.
              However, the original parameter:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-028.png"/>
              <figcaption>Fig 06-028</figcaption>
            </figure>
            <p>Would be the value of the Subtotal before the price of the new beer is included. This is a way of
              inspecting the before and after state of a watched property.</p>
            <p>At this point, you may want to know why I chose to use the subTotal property instead of the shopping cart
              property used earlier. The fact is, I could not use the shopping cart property to show the latest and
              original parameter usage. The reason why is because Vue doesn't keep data copies for objects and arrays.
              Since the shopping cart is an array, it wouldn't work. Instead, you would need to use an expression like
              this:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-029.png"/>
              <figcaption>Fig 06-029</figcaption>
            </figure>
            <p>To detect a change in the length of an array. This example watches for changes to the length of the
              shopping cart. If a beer is added or removed from the array, the subTotal will get updated. While this is
              useful for handling changes to the length of an array, sometimes the contents of an item within an array,
              changes. To track those types of changes, you need to go deeper. In fact, you need to define a watcher's
              depth.
            </p>
          </div>
          <div>
            <h3>
              Defining a Watcher's Depth
            </h3>
            <p>
              By default, watchers use a shallow monitoring approach. In other words, a watcher compares old and new
              values by reference. This means that properties nested in a watched property do not cause a change to be
              detected when they get changed.</p>
            <p class="example">Module 06 - Defining a Watcher's Depth Example</p>

            <p>I want to demonstrate this point, because I believe it's important. Up to this point, the shopping cart
              property in the data object has just been an array:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-030.png"/>
              <figcaption>Fig 06-030</figcaption>
            </figure>
            <p>Let's expand the

              responsibility of the shopping cart, though. In fact, now it will have an array named items, which
              represent the items in the shopping cart:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-031.png"/>
              <figcaption>Fig 06-031</figcaption>
            </figure>
            <p>The shopping cart will also have a property named subTotal:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-032.png"/>
              <figcaption>Fig 06-032</figcaption>
            </figure>
            <p>The goal is that as beers are bought, the subtotal will get updated. If you're curious, we're basically
              refactoring code we've used earlier. I'm doing this just to demonstrate a scenario that I believe you'll
              run into in the real world. Now, if I run this code, you'll notice that the subtotal doesn't get updated
              when I click the buy button next to a beer.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-033.png"/>
              <figcaption>Fig 06-033#</figcaption>
            </figure>
            <p>
              You might be thinking that this was working earlier, why isn't it working now? The reason why is because
              the items property is nested within the shopping cart, so by default, Vue won't be able to detect the
              addition of beers to the items array. This means that the subtotal never gets updated:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-034.png"/>
              <figcaption>Fig 06-034</figcaption>
            </figure>
            <p>However, I could update the watcher definition like this:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-035.png"/>
              <figcaption>Fig 06-035</figcaption>
            </figure>
            <p>To react to changes in nested properties. This watcher syntax is slightly different than what's been
              used. The handler defines the function to call when the shoppingCart property changes:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-036.png"/>
              <figcaption>Fig 06-036</figcaption>
            </figure>
            <p>The notable part of this example, though, is the deep property:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-037.png"/>
              <figcaption>Fig 06-037</figcaption>
            </figure>
            <p>By setting this property to true, I'm telling Vue to watch for changes to properties nested within the
              shoppingCart property. This is set to false, by default, for performance reasons. For that reason, you
              should turn deep monitoring on only when it makes sense. After all, you shouldn't watch properties unless
              you have to. Watchers are a powerful way to react to data changes in a view. In general, watchers are
              useful for complex calculations, especially ones that require asynchronous calls. In most scenarios,
              especially ones that do not require complex calculations, you should use a computed property.
            </p>
          </div>
          <div>
            <h3>
              Faster Rendering with Computed Properties
            </h3>
            <p>
              A great user experience is a fast, responsive user experience. In order to meet this goal, you need to
              make implementation choices that will deliver the greatest performance. When rendering data in your UI,
              you can use methods to handle data conversions. However, when you call a method, the logic is run each
              time. If this logic is complex, or if it's called a lot of times, your app might render more slowly.
              Fortunately, Vue provides a way to cache properties once they've been computed.</p>
            <p>
              Computed properties are functions whose results are cached until their depending values change. This means
              that the first time a computed property is called, a result will be generated and cached. Then, anytime
              the computed property is called again, the cached value will be returned. Notably, the logic won't be
              re-evaluated. Instead, a computed properties result will only be regenerated if a depending value
              changes:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-038.png"/>
              <figcaption>Fig 06-038</figcaption>
            </figure>
            <p>This means a faster runtime experience. Let's see how to initialize a computed property.
            </p>
          </div>
          <div>
            <h3>
              Initializing Computed Properties
            </h3>
            <p>
              To initialize a computed property, you set up something that looks like a method. To demonstrate, let's
              look at an example:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-039.png"/>
              <figcaption>Fig 06-039</figcaption>
            </figure>
            <p class="example">Module 06 - Initializing a computed property</p>
            <p>In this example, I have a computed property named isOnline:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-040.png"/>
              <figcaption>Fig 06-040</figcaption>
            </figure>
            <p>This property is a flag that signals if the search engine is able to access the internet, or not. It
              provides a simple yes or no, based on the value of canConnect:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-041.png"/>
              <figcaption>Fig 06-041</figcaption>
            </figure>
            <p>By default, this property is set to false when the app starts. Once the app is created, the Axios library
              mentioned in module 1 is used to see if the app can reach a website:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-042.png"/>
              <figcaption>Fig 06-042</figcaption>
            </figure>
            <p>The result of that request is used to set the canConnect property. When the canConnect property changes,
              the isOnline computed property will get refreshed:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-043.png"/>
              <figcaption>Fig 06-043</figcaption>
            </figure>
            <p>In other words, the cached value will be replaced with the new value. This results in the UI bindings
              getting updated as well.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-044.png"/>
              <figcaption>Fig 06-044</figcaption>
            </figure>
            <p>So, if the can Connect property gets set to false, the UI will show no, and if the canConnect property is
              set to true, the UI will show yes. Computed properties are great when you want to cache values. That's
              why, by default, they strictly retrieve values. Basically, computed properties are getters by default, but
              if you want to expand a computed property to be a getter and a setter, you can. In fact, you can use a
              computed property as an accessor.
            </p>
          </div>
          <div>
            <h3>
              Using Computed Properties as Accessors
            </h3>
            <p>
              Computed properties can be used as accessors. Accessors are computed properties that can get or set
              property values. This concept may sound familiar, in fact, accessors are found in some form in other
              popular languages like C#, C++, and Java.</p>
            <p>To see what Vue's version of an accessor looks like, let's do a before and after of the isOnline computed
              property:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-045.png"/>
              <figcaption>Fig 06-045</figcaption>
            </figure>
            <p>Here on the left, you can see the isOnline computed property used in the last section. Now, I could
              expand this code and explicitly declare that this computed property is a getter by defining a get function
              like this.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-046.png"/>
              <figcaption>Fig 06-046</figcaption>
            </figure>
            <p class="example">Module 06 - Adding a getter</p>
            <p>This approach does not change the behavior of the computed property. Rather, it's a more verbose way of
              achieving the same goal.</p>
            <p>Now, if I wanted to set the canConnect value, I could by adding a set function, like this:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-047.png"/>
              <figcaption>Fig 06-047</figcaption>
            </figure>
            <p class="example">Module 06 - Adding a setter</p>
            <p>Now, the isOnline computed property lets you both get and set the canConnect data value. Notice how the
              set function takes in a parameter called newValue:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-048.png"/>
              <figcaption>Fig 06-048</figcaption>
            </figure>
            <p>This parameter is the value that you want to change a property to. This empowers you to use the existing
              value as a before value, and the newValue parameter as the after value. Then, when the new value is set to
              the canConnect data property value:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-049.png"/>
              <figcaption>Fig 06-049</figcaption>
            </figure>
            <p>The get function is rerun. The reason why is because canConnect is the dependency property for the
              computed property. This, in turn, means the UI will get updated to reflect the data change. Expanding a
              computed property to an accessor is great when you need to do more than retrieve a value. In fact, using a
              setter is a great way to impose validation on values, as they're being set. The big reason to use a
              computed property though, is for its caching abilities, which can provide a performance boost. In most
              cases, a computed property is the way to go, however, for basic text transformations, you may want to
              consider a filter.
            </p>
          </div>
          <div>
            <h3>
              Formatting with Filters
            </h3>
            <p>
              When working on an app, you may need to perform some basic transformations. For example, in Growler, each
              beer has International Beer Units, or IBUs, associated with it. Pretend for a second that that data looks
              like this:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-050.png"/>
              <figcaption>Fig 06-050</figcaption>
            </figure>
            <p>Well, if that were the case, you may want to transform the data in two ways. First, you may want to
              remove the periods. Next, you may want to make the text upper case. If you did these two things, each
              value would become this.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-051.png"/>
              <figcaption>Fig 06-051</figcaption>
            </figure>
            <p>These kinds of basic text transformations are best implemented as filters. Filters are a special type of
              function in Vue. They're intended to be used for common text conversions. This includes things like
              converting a string to lowercase, perhaps reversing a string, or, as seen in the case of our beer search
              engine, removing periods and converting the text to uppercase. If you wanted to make a filter that meets
              the needs of the last example, You'd have a filter that looks like this:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-052.png"/>
              <figcaption>Fig 06-052</figcaption>
            </figure>
            <p class="example">Module 06 - using a filter</p>
            <p>This slide has a predefined list of beers squished here in an array called results:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-053.png"/>
              <figcaption>Fig 06-053</figcaption>
            </figure>
            <p>The beer listed here has its international beer units available through the ibu property. In the HTML, a
              for directive is used to loop through the results:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-054.png"/>
              <figcaption>Fig 06-054</figcaption>
            </figure>
            <p>For each result, mustaches are used to create a semantic binding on the name:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-055.png"/>
              <figcaption>Fig 06-055</figcaption>
            </figure>
            <p>Mustaches are again used to bind the IBUs to the template. I'm using mustaches, because, as of the time
              of writing, filters could not be used with the HTML or text directives. Either way, inside of these
              mustaches there's a filter named convertIBU being applied.
            </p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-056.png"/>
              <figcaption>Fig 06-056</figcaption>
            </figure>
          </div>
          <div>
            <h3>
              Defining Filters
            </h3>
            <p>
              The convertIBU filter is defined in an instance-level object called filters.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-057.png"/>
              <figcaption>Fig 06-057</figcaption>
            </figure>
            <p>This object is at the same level as the data and methods objects you've already seen in this course.
              Inside of the filters object is a comma-delimited list of functions that can be used in a binding. In this
              case, only one filter named convertIBU is defined. This function takes in a value which is automatically
              passed in. The periods are then removed from the value, and it's converted to uppercase. That's it. If you
              wanted to pass in an additional parameter, you could, like this.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-058.png"/>
              <figcaption>Fig 06-058</figcaption>
            </figure>
            <p class="example">Module 06 - Passing a parameter to a filter</p>
            <p>In this example, I'm passing in a parameter called empty:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-059.png"/>
              <figcaption>Fig 06-059</figcaption>
            </figure>
            <p>This parameter's value is used if a beer doesn't have an IBU value. In this case, two dashes will be used
              instead of an empty string:</p>

            <p>Still, the value that the filter is being applied to is automatically passed into the function. Whether
              you pass in additional parameters or not, the value is always the first parameter passed to a filter,
              well, unless you're calling a filter programmatically, that is.
            </p>
          </div>
          <div>
            <h3>
              Programmatically Calling a Filter
            </h3>
            <p>
              While you can call filters decoratively, you can also call them programmatically. Once your view has been
              instantiated, the filters object becomes available via the options property. This means that you can
              access your filters via JavaScript. For example, if you wanted to refactor the convertIBU filter into
              multiple filters, you could. In fact, let's pretend that you decided to refactor the convertIBU filter
              like this.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-060.png"/>
              <figcaption>Fig 06-060</figcaption>
            </figure>
            <p class="example">Module 06 - Programmatically calling filters</p>
            <p>This slide shows the convertIBU filter refactored. Now, instead of one single filter, there are actually
              three:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-061.png"/>
              <figcaption>Fig 06-061</figcaption>
            </figure>
            <p>It should be noted that all of these filters belong in the filters object discussed earlier. I'm showing
              them this way due to the available real estate on the screen. You can see the actual implementation in the
              sample repo that goes with this course. Still, the convertIBU filter shown in the left half:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-062.png"/>
              <figcaption>Fig 06-062</figcaption>
            </figure>
            <p>Is calling the removePeriods and toUpperCase filters defined in the right half.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-063.png"/>
              <figcaption>Fig 06-063</figcaption>
            </figure>
            <p>I want to point out this check right here.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-064.png"/>
              <figcaption>Fig 06-064</figcaption>
            </figure>
            <p>This assertion is used to ensure that Growler is defined. The reason for this is because filters are
              added to the options after instantiation. Without this check, the app would not work. Still, once
              available, I can programmatically call each of the filters as shown on the screen. In reality, though, you
              shouldn't do this. I did this for the sole purpose of showing you the syntax of how to programmatically
              call a filter from another filter. Instead, you should consider chaining filters together.
            </p>
          </div>
          <div>
            <h3>
              Chaining Filters Together
            </h3>
            <p>
              Just like the modifiers explained in module 3, you can also chain filters together. Instead of using a
              period, though, as in the case with modifiers, you use a pipe. Let's pretend for a second that the filter
              definitions were changed one more time. For example, I'll make each filter its own unit, like this:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-065.png"/>
              <figcaption>Fig 06-065</figcaption>
            </figure>
            <p class="example">Module 06 - chaining filters together</p>
            <p>Now, there are three distinct filters, convertIBU, removePeriods, and toUpperCase:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-066.png"/>
              <figcaption>Fig 06-066</figcaption>
            </figure>
            <p>Each of these filters is being called in sequence by the HTML template shown on the right half of the
              screen:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-067.png"/>
              <figcaption>Fig 06-067</figcaption>
            </figure>
            <p>The result of the convertIBU filter:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-068.png"/>
              <figcaption>Fig 06-068</figcaption>
            </figure>
            <p>is passed as the value into the removePeriods filter:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-069.png"/>
              <figcaption>Fig 06-069</figcaption>
            </figure>
            <p>Then, the result of the removePeriods filter is passed as the value to the toUpperCase filter:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-070.png"/>
              <figcaption>Fig 06-070</figcaption>
            </figure>

            <p>After all of these filters have executed, the result is rendered in the HTML. Filters are a nice way to
              handle basic text transformations. At this point, you may be wondering, why use a filter instead of just
              calling a method?
            </p>
          </div>
          <div>
            <h3>
              Comparing Filters to Methods
            </h3>
            <p>
              Filters and methods are closely related. In fact, you can use methods to get the same result as a filter,
              however, filters serve a slightly different purposes. Filters are intended to be used in your HTML
              template. With this intent, there are two rules for defining filters. First, filters should only take in a
              value and return a new value. Along with this, filters should not change the value of any properties in a
              view. The convertIBU filter shown met both of these rules.</p>
            <p>Beyond the intended purpose, though, filters are just easier to read. Imagine the functions called by the
              convertIBU filters were methods. In that case, you'd call them like this.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-071.png"/>
              <figcaption>Fig 06-071</figcaption>
            </figure>
            <p class="example">Module 06 - comparing methods to filters</p>
            <p>When compared to the version that uses filters:</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-072.png"/>
              <figcaption>Fig 06-072</figcaption>
            </figure>
            <p>Which do you find easier to read? Personally, I find the filter version easier to read. It's more
              readable because of the chaining abilities. You don't have to mentally parse the code, you just read the
              code from left to right, which is more natural. If you're wondering whether you should use a filter or a
              method, there is another test.</p>
            <p>In general, filters are intended to be used across views, however, a method is specific to the instance.
              If you intend to reuse the code, you may want to ask yourself, if it should be a filter. Filters are a
              great way to handle basic text transformations. For more complex data transformations, a computed property
              is more appropriate.</p>
            <p>Finally, if you need to handle asynchronous data operations, you should consider a watcher. I've tried to
              summarize the abilities of each construct on this slide.</p>
            <figure>
              <img src="./images/vue-js-getting-started/Fig06-073.png"/>
              <figcaption>Fig 06-073</figcaption>
            </figure>
            <p>If you would like to pause the video and take a screenshot or print this out, it may be handy for you.
              Either way, in this module, you saw how to use watchers, computed properties, and filters to react to data
              changes. This concludes the content for this course.</p>
            <p>There are a number of valuable topics that are outside the scope of this course. For example, we barely
              scratched the surface of Axios. There are also more advanced topics like:</p>
            <ul>
              <li>Components</li>
              <li>Transitions</li>
              <li>Routing</li>
              <li>State Management</li>
              <li>Server-Side Rendering</li>
            </ul>
            <p>The reason these topics were not part of this course, is because this course was focused on getting you
              started with Vue. js. If you would like to learn about these more advanced topics, as well as other
              topics, please let me know on Twitter, @chadcampbell. If there is enough interest, I'd be happy to put
              together a follow-up course. Once again, I sincerely want to thank you for watching this course. I hope
              you'll take a moment to review the course. That lets me know if you found this course helpful. Best wishes
              on building your apps with Vue. js.
            </p>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
