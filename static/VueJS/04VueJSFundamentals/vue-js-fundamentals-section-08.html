<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>maxsagetech - Vue JS Fundamentals</title>
  <script src="https://unpkg.com/vue"></script>
  <!--<link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"-->
  <!--integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" rel="stylesheet">-->
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>

    img {
      max-width: 100%;
      width: 100%
    }
  </style>
</head>
<body>
<div class="container" id="app">
  <div class="panel-group">
    <div class="panel panel-primary">
      <div class="panel-heading">
        <h2>Vue JS Fundamentals</h2>
      </div>
      <div class="panel-body">
        <div class="course-transcript">
        <div><h2>Deploying Vue Applications to Production</h2>
          <div><h3>Introduction</h3>
            <p>Welcome to this final module on Deploying Vue Applications to Production. In this module, we'll explore
              everything from packaging our application for production to production configuration options, to actually
              deploying to a production server.</p>
            <p>The basic Vue CLI build is a zero config build with reasonable defaults that can be extended or modified
              whenever necessary. This means that you could very reasonably create a new project with the CLI, develop
              it and then use the CLI to create a production-ready build without having to do any configuration, webpack
              or otherwise. Of course in reality, that rarely happens.</p>
            <p>It seems that we always need to be able to tweak configurations as we make changes to support our
              development decisions and to support our development and production environments. Luckily, the
              configuration is very extensible and easy to customize with whatever webpack configuration changes you
              need to make.</p>
            <p>We'll take a look at how to do just that, but first let's take a look at what a zero config build
              includes. So just what is included in an out-of-the-box zero config deployment? Well, the answer is a
              lot:</p>
            <figure>
              <img src="images/Fig07-001.png"/>
              <figcaption>Fig 07-001</figcaption>
            </figure>
            <p>
              I'm not going to read through all of these, but this is what I found when looking through the webpack
              config generated by the Vue CLI at the time this course was produced. There's a lot here, and it includes
              all the things you typically want from a webpack build like minification, concatenation, cache busting via
              chunk hashing, CSS preprocessor support for the most popular options, etc. Everything you'd typically
              think about when creating a build. And so there's a good chance you'd do just fine right out of the
              box.</p>
            <p>But in the event you need to add or remove something to config, you can always do that.</p>
            <p>In this module, we'll cover:
            <ul>
              <li>Creating a basic Vue. js build using the CLI</li>
              <li>Using environment variables and build modes</li>
              <li>Deploying to a production web server</li>
              <li>Handling deep linking when using HTML5 history mode for routing on the client side</li>
              <li>Inspecting the built-in webpack config and customizing the webpack config</li>
            </ul>
            <p>Once we're done with this last module, you will have mastered all the fundamentals you need to know to
              get started with creating and deploying Vue.js applications. So let's jump in and wrap it up.
            </p>
          </div>
          <div><h3>Creating a Basic Vue.js Build with the CLI</h3>
            <p>
              Once you've finished development and you're ready to deploy your changes to production, creating a
              deployable build is simple. Typically, all you need to run is npm run build:</p>
            <figure>
              <img src="images/Fig07-002.png"/>
              <figcaption>Fig 07-002</figcaption>
            </figure>
            <p>So this script will tell the Vue CLI to create a deployable build utilizing all of the built-in webpack
              config that the CLI generated for us when we first generated our project. This will result in a production
              deployable distribution folder. This build will contain all of the latest best practices identified by the
              Vue team for generating a deployable web application, including all of the optimizations we mentioned in
              the previous clip, all of this without us even having to think about it.</p>
            <p>Of course if you want to dig into it and make modifications, you can. More on that later. So let's go
              ahead and run this. Now that this is finished, we have this deployable dist folder:</p>
            <figure>
              <img src="images/Fig07-003.png"/>
              <figcaption>Fig 07-003</figcaption>
            </figure>
            <p>All we need to do to deploy this to a production server is copy this dist folder to a place where it can
              be served by our web server. We'll do this with an express web server later. If we take a look inside this
              dist folder, you can see that we have css, js and img folders:</p>
            <figure>
              <img src="images/Fig07-004.png"/>
              <figcaption>Fig 07-004</figcaption>
            </figure>
            <p>in addition to a favicon and an index.html. The CSS, js and image folders are the webpack contents of all
              the code that we've written for our application. But where did this fave icon and index html come from? We
              never created those. Well, those came from this public directory right here:</p>
            <figure>
              <img src="images/Fig07-005.png"/>
              <figcaption>Fig 07-005</figcaption>
            </figure>
            <p>in our project, and they were generated by the CLI when we first created our application. And actually,
              any file that we put in this folder will be included in the final dist folder. But this index.html file is
              an important file. This is the starting point for our entire application. When we deploy this to
              production, our web server needs to serve up this index html file whenever anyone hits the URL for our
              application. That will then load up our entire Vue.js application.</p>
            <p>And that's all there is to generating a zero config deployment for production. Next let's take a look at
              some other options that we have when building this dist folder, and then we'll see how to deploy it all to
              production.
            </p>
          </div>
          <div><h3>Using Environment Variables and Build Modes</h3>
            <p>When we ran npm run build to generate our deployable dist folder, we didn't pass any arguments to it
              which means that by default it ran in production mode. But sometimes you want to be able to generate
              different deploys for different environments. We can do that with the mode flag. The default build that is
              created when we run npm run build is actually equivalent to this command, running npm run build with the
              switch mode=production:</p>
            <figure>
              <img src="images/Fig07-006.png"/>
              <figcaption>Fig 07-006</figcaption>
            </figure>
            <p>So by default it runs in production mode if we don't provide this mode flag. But we can provide different
              modes. For example, we could create a development mode build and pass in a development flag. And actually,
              when you run npm run serve, as we've been doing all along throughout this course to serve up our
              application and development, it actually creates a development mode build. The important thing to
              understand is that setting mode by default also sets the node_env variable, and this is really
              important.</p>
            <p>
              The webpack build that is generated when the node environment variable is set to production is very
              different than when it is set to development or anything else. Only production mode builds should be used
              in production.</p>
            <p>But what if we want to create a staging mode build and have it use the production node environment
              variables so that we could test a production build in a staging environment prior to production
              deployment</p>
            <p>Well, we can do that with environment variables. To demonstrate that, let's see what happens if we create
              a staging mode build. So I'm going to set mode equal to staging and we'll run that:</p>
            <figure>
              <img src="images/Fig07-007.png"/>
              <figcaption>Fig 07-007</figcaption>
            </figure>
            <p>All right, now take a look at what is in our dist folder:</p>
            <figure>
              <img src="images/Fig07-008.png"/>
              <figcaption>Fig 07-008</figcaption>
            </figure>
            <p>This looks quite different from our production build, which had bundled things up very nicely in a way
              that was appropriate for production. The staging build is basically a development build so we just have
              this one app.js file, for example, instead of optimized chunks. But we can change that so that we could
              have a staging build that runs in production mode.</p>
            <p>So over here in our project, in the root folder, I'm just going to create a new file. And we'll name that
              file. env.staging:</p>
            <figure>
              <img src="images/Fig07-009.png"/>
              <figcaption>Fig 07-009</figcaption>
            </figure>
            <p>And then inside here, I can set environment variables including node environment. And so I'm going to set
              the node environment here to production because even though I'm building a staging build:</p>
            <figure>
              <img src="images/Fig07-010.png"/>
              <figcaption>Fig 07-010</figcaption>
            </figure>
            <p>I want it to be a build that looks just like production so I can test it in staging just like it will
              look in production. So I'll save that and let's come back over here and let's run our npm run build with
              mode staging again:</p>
            <figure>
              <img src="images/Fig07-011.png"/>
              <figcaption>Fig 07-011</figcaption>
            </figure>
            <p>Okay, you can see from the output there that it's very different. So if I take a look at my dist folder
              again:</p>
            <figure>
              <img src="images/Fig07-012.png"/>
              <figcaption>Fig 07-012</figcaption>
            </figure>
            <p>you can see this is all optimized like it was when we did a production build. So we can actually use any
              word that we want here for the mode:</p>
            <figure>
              <img src="images/Fig07-013.png"/>
              <figcaption>Fig 07-013</figcaption>
            </figure>
            <p>So I use staging, but this could be foo or anything else. And then we just create a corresponding .env
              file with that mode name appended to the end of the file name:</p>
            <figure>
              <img src="images/Fig07-014.png"/>
              <figcaption>Fig 07-014</figcaption>
            </figure>
            <p>And it will use any environment variables that we put in here for the build, which leads to another
              question, what other variables might you put in your .env file. Well, you could have, for example,
              connection information for connecting to databases or other configuration options like that. Just be sure
              that if you do that, you don't ever commit secret information to GitHub or anywhere else. You'll want to
              encrypt those values or find some other solution.</p>
            <p>But there's another thing that we can use environment variables for. Let's create another environment
              file and we will call it .env.development:</p>
            <figure>
              <img src="images/Fig07-015.png"/>
              <figcaption>Fig 07-015</figcaption>
            </figure>
            <p>And in here, let's create a new environment variable. We'll just call it VUE_APP_TEST. Now the VUE_APP
              piece of this is important. More on that later. For now, I'm just going to set this to foo:</p>
            <figure>
              <img src="images/Fig07-016.png"/>
              <figcaption>Fig 07-016</figcaption>
            </figure>
            <p>And now that I have that set, let's come over to our home page and we'll add a created hook in here:</p>
            <figure>
              <img src="images/Fig07-017.png"/>
              <figcaption>Fig 07-017</figcaption>
            </figure>
            <p>
              And then when our homepage component is created, we're just going to console.log
              process.env.VUE_APP_TEST:</p>
            <figure>
              <img src="images/Fig07-018.png"/>
              <figcaption>Fig 07-018</figcaption>
            </figure>
            <p>And we created a development.env file with the app Vue test variable in it set to foo:</p>
            <figure>
              <img src="images/Fig07-019.png"/>
              <figcaption>Fig 07-019</figcaption>
            </figure>
            <p>Now we just need to start up our server again:</p>
            <figure>
              <img src="images/Fig07-020.png"/>
              <figcaption>Fig 07-020</figcaption>
            </figure>
            <p>So let's come over to our home page now and open up our console and just refresh this. And there you go,
              you can see that foo got logged here:</p>
            <figure>
              <img src="images/Fig07-021.png"/>
              <figcaption>Fig 07-021</figcaption>
            </figure>
            <p>because in our homepage, we console logged process.env.VUE_APP_TEST. And in our .env.development file,
              that is set to foo.</p>
            <p>Now let's see what happens if we don't prepend the Vue app to this. So we'll just call this
              SOME_TEST=bar:</p>
            <figure>
              <img src="images/Fig07-022.png"/>
              <figcaption>Fig 07-022</figcaption>
            </figure>
            <p>And then back in our home page, let's also print that variable, process.env.SOME_TEST:</p>
            <figure>
              <img src="images/Fig07-023.png"/>
              <figcaption>Fig 07-023</figcaption>
            </figure>
            <p>Okay, and let's stop and restart this again since we changed our .env file:</p>
            <figure>
              <img src="images/Fig07-024.png"/>
              <figcaption>Fig 07-024</figcaption>
            </figure>
            <p>Now let's come back over here and refresh. Notice that we got foo and undefined:</p>
            <figure>
              <img src="images/Fig07-025.png"/>
              <figcaption>Fig 07-025</figcaption>
            </figure>
            <p>And so in our config file:</p>
            <figure>
              <img src="images/Fig07-026.png"/>
              <figcaption>Fig 07-026</figcaption>
            </figure>
            <p>VUE_APP_TEST was available to us but SOME_TEST was not. This is because, for security reasons, Vue will
              only make environment variables available to our client side code that start with VUE_APP_, but there is
              one exception to this and that is NODE_ENV</p>
            <p>So if we were to set this to development or any other value:</p>
            <figure>
              <img src="images/Fig07-027.png"/>
              <figcaption>Fig 07-027</figcaption>
            </figure>
            <p>
              NODE_ENV would also be available to us in our client side code. And this is be cause it's not uncommon to
              want to get access to the node environment in your code. So that one is available without prefixing it
              with Vue app. But every other variable needs to be prefixed with that.</p>
            <p>So you can use these variables in order to provide server-specific variables to your application based on
              the environment that you're operating in.</p>
            <p>Okay, so now that we know how to configure our deployments with environment files, let's see how to
              actually deploy to production.
            </p>
          </div>
          <div><h3>Deploying to a Production Webserver</h3>
            <p>
              We just learned that we can create a production build with npm run build, and that creates this dist
              folder:</p>
            <figure>
              <img src="images/Fig07-028.png"/>
              <figcaption>Fig 07-028</figcaption>
            </figure>
            <p>Now we need to serve that folder from our web server. Your deployment process will be different based on
              the production web server you use, but just to give you an idea of what a basic deploy looks like, we'll
              deploy our site to an express web server.</p>
            <p>If you remember from earlier in the course, we cloned a build-a-bot-server that we used as an API. And up
              till now, that's all we used it for as an API. But let's update it to also serve our newly packaged app.
              Then we'll just deploy our app by copying this dist folder into our server</p>
            <p>So let's open this index.js file up in Visual Studio Code:</p>
            <figure>
              <img src="images/Fig07-029.png"/>
              <figcaption>Fig 07-029</figcaption>
            </figure>
            <p>And you can see here in the index.js file that we have a few routes set up for our API. Let's just add a
              route to also serve the app from a dist folder, and then we can just copy in the dist folder whenever we
              want to deploy a new version of our application.</p>
            <p>So all we need to do is right here at the bottom of our routes, add an app.use, and we'll specify the
              root url here. And then we'll use express.static to serve the dist directory, and we'll let express.static
              know that we want to serve the default index file as index.html:</p>
            <figure>
              <img src="images/Fig07-030.png"/>
              <figcaption>Fig 07-030</figcaption>
            </figure>
            <p>So this line basically says whenever anyone hits the root url and it's not handled by one of the routes
              above, then serve the index.html file from this dist folder. And that's it, this web server is now set up
              to serve our Vue app. The only thing that's missing is the dist folder.</p>
            <p>So basically, whenever you deploy a Vue app, you're basically just deploying or copying the dist folder
              to your web server. So let's go ahead and copy the dist folder from our build-a-bot app into our
              server:</p>
            <figure>
              <img src="images/Fig07-031.png"/>
              <figcaption>Fig 07-031</figcaption>
            </figure>
            <p>
              Okay, so now if we take a look here you can see that we have a dist folder in here:</p>
            <figure>
              <img src="images/Fig07-032.png"/>
              <figcaption>Fig 07-032</figcaption>
            </figure>
            <p>and this is our Vue.js application. And that's it, we just deployed are app to our server. Now let's go
              ahead and start our server. We can do that with npm start:</p>
            <figure>
              <img src="images/Fig07-033.png"/>
              <figcaption>Fig 07-033</figcaption>
            </figure>
            <p>And just like before, when we're running our API, you can see that this is running on port 8081. So one
              thing that's different now from when we were running in development mode is that we were spinning up our
              dev server on port 8080, and that was running with webpack dev server. And we did that with the npm run
              serve command from our build-a-bot folder. And then we were separately starting our API server on port
              8081. So we have our webpack dev server running on port 8080 and our API running on 8081.</p>
            <p>But now that we've deployed are app to this production server, both are app and our API are running on
              port 8081. So let's go check that out. So we'll just navigate to local host 8081</p>
            <figure>
              <img src="images/Fig07-034.png"/>
              <figcaption>Fig 07-034</figcaption>
            </figure>
            <p>And look at that, there is our server. And that is being served out of our dist folder. And if we click
              on Build, you can see that it is communicating with our API, which is running on the same server:</p>
            <figure>
              <img src="images/Fig07-035.png"/>
              <figcaption>Fig 07-035</figcaption>
            </figure>
            <p>So congratulations, you just deployed your first Vue.js application to production and everything here is
              working great except for one problem and that is deep linking. Let's take a look at that next.
            </p>
          </div>
          <div><h3>Handling Deep Linking on the Server</h3>
            <p>There is one problem with our newly deployed app. You can see that our app gets loaded just fine and I
              can even navigate around within my app without any problems. However, let's see what happens if we try
              deep linking into our app. For example, what happens if I navigate straight to this build url here:</p>
            <figure>
              <img src="images/Fig07-036.png"/>
              <figcaption>Fig 07-036</figcaption>
            </figure>
            <p>So I'm going to open a new tab and navigate to that url directly:</p>
            <figure>
              <img src="images/Fig07-037.png"/>
              <figcaption>Fig 07-037</figcaption>
            </figure>
            <p>So you can see that I got a 404 error here. Why is this? Well, by navigating directly to this build url,
              the browser sent a request to our web server saying please send me the document at this url. However,
              there is no document on our server at this url. We don't have a route on our servers for /build. That is a
              client side route. So this is just a manufactured url created by the Vue router that only the client side
              app knows about. And so our server ends up returning a 404 because it doesn't know how to serve this
              url.</p>
            <p>
              So basically, what we need to do is when someone requests any url from our server, we need to return the
              Vue single page application. Or in other words, the index. html file from our dist folder</p>
            <p>This is actually only a problem because we're running in HTML5 history mode. You may recall that before
              we were running in HTML5 history mode, our urls had hash lines in them like this:</p>
            <figure>
              <img src="images/Fig07-038.png"/>
              <figcaption>Fig 07-038</figcaption>
            </figure>
            <p>If you don't run in HTML5 history mode, the server won't try to load this url because the server only
              loads this stuff before the hash. But most people don't want this hash in their url so they turn on HTML5
              history mode. And when you do that, you need to handle deep linking on your server.</p>
            <p>So let's see how to make our server work with that. So if you think about how to make this work,
              basically, whenever a call that is made for a route that is not handled by one of these routes here:</p>
            <figure>
              <img src="images/Fig07-039.png"/>
              <figcaption>Fig 07-039</figcaption>
            </figure>
            <p>
              we'll want to serve the index.html file. That way, we'll serve up the spa and then Vue will load
              everything up and do client-side routing to the correct url. How you do this in different web servers
              varies, but in express, because this is such a common practice, there's an express middleware that we can
              use.</p>
            <p> So back in my terminal, I'm going to stop my server and I'm going to npm install this connect history
              api fallback middleware:</p>
            <figure>
              <img src="images/Fig07-040.png"/>
              <figcaption>Fig 07-040</figcaption>
            </figure>
            <p>Okay, so now that that's installed, I'm going to come over here and I'm going to go ahead and require
              that. So we'll set const history equal to require connect history api fallback:</p>
            <figure>
              <img src="images/Fig07-041.png"/>
              <figcaption>Fig 07-041</figcaption>
            </figure>
            <p>And then I just need to use that middleware like this. So right here at the top, before I route, I'm
              going to say app. use, and then I'm going to call that connect history api fallback function. And then
              inside here I'm going to tell it the name of my index.html file, which is just /index.html:</p>
            <figure>
              <img src="images/Fig07-042.png"/>
              <figcaption>Fig 07-042</figcaption>
            </figure>
            <p>In this case, this parameter isn't necessary because by default it will use index.html. I'm just putting
              it here for clarity. So basically, this says if a request comes in for a file that is not handled in the
              routes below, then redirect the request to /index. html.</p>
            <p>And this will essentially cause it to be handled by this route down here:</p>
            <figure>
              <img src="images/Fig07-043.png"/>
              <figcaption>Fig 07-043</figcaption>
            </figure>
            <p>Okay, so let's go check this out. So we need to start up our server again. And then let's come back over
              here and let's go ahead and deep link into the build page:</p>
            <figure>
              <img src="images/Fig07-044.png"/>
              <figcaption>Fig 07-044</figcaption>
            </figure>
            <p>Excellent, so you can see that works just fine. And we can try it again here for the cart page. And you
              can see everything:</p>
            <figure>
              <img src="images/Fig07-045.png"/>
              <figcaption>Fig 07-045</figcaption>
            </figure>
            <p>all the deep linking in our application is working now. And again, the way you set this up on your web
              server will be different depending on the production web server that you're using. Just know that you need
              to set up your server to always serve the index.html file whenever your server receives a request that it
              doesn't recognize.</p>
            <p>Cool, now let's take a look at how to change webpack config. But before we do that, we need to understand
              what the built-in webpack config looks like. So we'll take a look at that next.
            </p>
          </div>
          <div><h3>Inspecting the Built-in Webpack Config</h3>
            <p>
              We'd like to be able to edit our webpack config, but before we can do that we kind of need to know what is
              already configured. Without some help from the CLI, this would be challenging because the Vue CLI builds
              the webpack config dynamically. So there's no webpack config file to look at. But not to worry, the Vue
              CLI provides the inspect command which outputs the dynamic webpack config. All we need to do is in our
              terminal, run vue inspect:</p>
            <figure>
              <img src="images/Fig07-046.png"/>
              <figcaption>Fig 07-046</figcaption>
            </figure>
            <p>and then we can tell it which environment or build mode to output the config for. So I'm going to say
              generate the production webpack config for production mode:</p>
            <figure>
              <img src="images/Fig07-047.png"/>
              <figcaption>Fig 07-047</figcaption>
            </figure>
            <p>And now I could just run this and it would output the webpack config to the console here. But to make it
              easier to explore, let's pipe this to a file. So we'll pipe it to webpack.config.js:</p>
            <figure>
              <img src="images/Fig07-048.png"/>
              <figcaption>Fig 07-048</figcaption>
            </figure>
            <p>Okay, so this is generating the webpack for us. Remember, you don't ever need to do this. This config
              file that's being generated isn't going to be used. We're just generating it so we can see what the
              webpack config file looks like that the CLI is going to use when it creates a build.</p>
            <p>So let's go take a look at this file. So over here, we can see our webpack config js file. And you can
              see there's a lot of stuff here:</p>
            <figure>
              <img src="images/Fig07-049.png"/>
              <figcaption>Fig 07-049</figcaption>
            </figure>
            <p>including all the webpack rules and loaders and everything. And the nice thing is if we add any of our
              custom config, which we'll do in the next clip, when you run this command it merges that all together and
              generates the resulting file.</p>
            <p>So not only can you use this to see what the Vue CLI is generating itself but you can also see how
              changes that you create are going to get merged into the webpack config at build time. So this is really
              helpful in order to see what the Vue CLI is doing before we start making our own webpack customizations.
              Let's try that next.
            </p>
          </div>
          <div><h3>Customizing Webpack Config</h3>
            <p>Customizing the out-of-the-box webpack config can be almost as easy as editing an existing webpack config
              file. All we have to do is add a section to our Vue config file. If this file doesn't exist yet in a
              project of yours, just create it. We created this one earlier when we wanted to add our API proxy:</p>
            <figure>
              <img src="images/Fig07-050.png"/>
              <figcaption>Fig 07-050</figcaption>
            </figure>
            <p>So in here, we're just going to add a configureWebpack section:</p>
            <figure>
              <img src="images/Fig07-051.png"/>
              <figcaption>Fig 07-051</figcaption>
            </figure>
            <p>And this object is basically your webpack options object. So you configure things inside this object in
              the exact same way that you would your webpack options. And then the CLI uses webpack chain and webpack
              merge to merge it with its own config. So anything that you add here will be added to or overwrite the
              default config.</p>
            <p>
              To demonstrate this, let's add support for CoffeeScript. We do that by adding the Coffee loader. So
              loaders go in the module section. And the module section has rules. All right, and then we're going to add
              a new rule:</p>
            <figure>
              <img src="images/Fig07-052.png"/>
              <figcaption>Fig 07-052</figcaption>
            </figure>
            <p>and this rule will target files that end in .coffee. And then we'll just tell it to use the Coffee
              loader:</p>
            <figure>
              <img src="images/Fig07-053.png"/>
              <figcaption>Fig 07-053</figcaption>
            </figure>
            <p>And that's it, now this config will be merged in with the default webpack config. So now let's go take a
              look at the new webpack config. So we're going to come over to our terminal and we're going to re-run this
              vue inspect command to generate a webpack config:</p>
            <figure>
              <img src="images/Fig07-054.png"/>
              <figcaption>Fig 07-054</figcaption>
            </figure>
            <p>Now this is going to merge our config with the zero config that the CLI generated and we can go take a
              look at the result now. So over here in our webpack config I'm going to hit Control + K and then Control +
              0 in order to collapse everything in here:</p>
            <figure>
              <img src="images/Fig07-055.png"/>
              <figcaption>Fig 07-055</figcaption>
            </figure>
            <p>And then I'm going to expand this. And then down here in the modules, I'm going to expand modules. And
              inside rules, you can see how we have a whole bunch of rules:</p>
            <figure>
              <img src="images/Fig07-056.png"/>
              <figcaption>Fig 07-056</figcaption>
            </figure>
            <p>and down here at the bottom is our new CoffeeScript rule:</p>
            <figure>
              <img src="images/Fig07-057.png"/>
              <figcaption>Fig 07-057</figcaption>
            </figure>
            <p>Of course if we were actually going to leave this in and actually use CoffeeScript, then we need to npm
              install Coffee loader. Since we're just doing this to demonstrate how to edit the config, I'm not going to
              bother doing this. But you can see that we can be confident that the Vue CLI is going to take this rule
              into account when it creates our build.</p>
            <p>But what if instead of adding a new setting we wanted to edit an existing one? For example, I'm going to
              come up to the top of my page here and then I'm going to search for the string right here:</p>
            <figure>
              <img src="images/Fig07-058.png"/>
              <figcaption>Fig 07-058</figcaption>
            </figure>
            <p>So this is a rule targeting image files. And let's go ahead and expand this. And you can see this is a
              url loader rule:</p>
            <figure>
              <img src="images/Fig07-059.png"/>
              <figcaption>Fig 07-059</figcaption>
            </figure>
            <p>So what if we wanted to change this limit here? Well, let's try it, let's copy this rule here and then
              let's paste it in over here in our Vue config:</p>
            <figure>
              <img src="images/Fig07-060.png"/>
              <figcaption>Fig 07-060</figcaption>
            </figure>
            <p>So right here we'll add another rule here. So this is targeting that same rule and then we'll change the
              limit here to 5000:</p>
            <figure>
              <img src="images/Fig07-061.png"/>
              <figcaption>Fig 07-061</figcaption>
            </figure>
            <p>Well, this is actually going to have an unintended consequence. So let's delete our current webpack
              config file:</p>
            <figure>
              <img src="images/Fig07-062.png"/>
              <figcaption>Fig 07-062</figcaption>
            </figure>
            <p>and then we will go generate a new one:</p>
            <figure>
              <img src="images/Fig07-063.png"/>
              <figcaption>Fig 07-063</figcaption>
            </figure>
            <p>And now let's see what this looks like. So if we come back in here, and then let's search for this again,
              so now you can see there are actually two rules in here. And the first rule has it set to a thousand:</p>
            <figure>
              <img src="images/Fig07-064.png"/>
              <figcaption>Fig 07-064</figcaption>
            </figure>
            <p>and the second one has it set to 5000:</p>
            <figure>
              <img src="images/Fig07-065.png"/>
              <figcaption>Fig 07-065</figcaption>
            </figure>
            <p>This sort of configuration can have unintended consequences so there's a better way to edit existing
              rules. Instead of setting our configureWebpack to an object, we can use a function.</p>
            <p>So up here I'm going to set configureWebpack to a function:</p>
            <figure>
              <img src="images/Fig07-066.png"/>
              <figcaption>Fig 07-066.png</figcaption>
            </figure>
            <p>And that function takes in a config object, which is the existing config from the CLI. And then we can
              just mutate this config that was passed in here. So for our Coffee loader, I'm going to just append a rule
              to the module rule. So I'm going to say config.module.rules.push, and then I'm going to push on our
              CoffeeScript rules. So I'm just going to grab this here:</p>
            <figure>
              <img src="images/Fig07-067.png"/>
              <figcaption>Fig 07-067</figcaption>
            </figure>
            <p>and move it up here:</p>
            <figure>
              <img src="images/Fig07-068.png"/>
              <figcaption>Fig 07-068</figcaption>
            </figure>
            <p>Okay, so you can see I've mutated that config and added our CoffeeScript rule. That one was easy. The
              next one's going to be a little bit trickier. Let's start by storing our new rule in a variable. So I'm
              going to say const newRule =:</p>
            <figure>
              <img src="images/Fig07-069.png"/>
              <figcaption>Fig 07-069</figcaption>
            </figure>
            <p>and then let's grab this rule down here:</p>
            <figure>
              <img src="images/Fig07-070.png"/>
              <figcaption>Fig 07-070</figcaption>
            </figure>
            <p>and paste that up here:</p>
            <figure>
              <img src="images/Fig07-071.png"/>
              <figcaption>Fig 07-071</figcaption>
            </figure>
            <p>Okay, so now we have that in a variable available to us. Let's go ahead and delete this down here:</p>
            <figure>
              <img src="images/Fig07-072.png"/>
              <figcaption>Fig 07-072</figcaption>
            </figure>
            <p>
              Okay, so now we need to do something with this new rule. So first, let's find the index of the rule that
              we want to mutate. So I'm going to set an images rule index variable equal to
              config.module.rules.findIndex:</p>
            <figure>
              <img src="images/Fig07-073.png"/>
              <figcaption>Fig 07-073</figcaption>
            </figure>
            <p>
              And then we're going to find the rule where the test expression is targeting our image files. And the test
              object is a regex so that has a source, and the source is a string so we can use includes to search for
              our expression:</p>
            <figure>
              <img src="images/Fig07-074.png"/>
              <figcaption>Fig 07-074</figcaption>
            </figure>
            <p>Okay, so that should find the index of the url loader rule that we want to modify. And now I can splice
              the current rules array to replace the old rule with the new rule. So I'll say config.module.rules.splice.
              And I'll start slicing the array at imageRuleIndex and I'll replace that item, that one item, with our new
              rule:</p>
            <figure>
              <img src="images/Fig07-075.png"/>
              <figcaption>Fig 07-075</figcaption>
            </figure>
            <p>So this is a little bit complex and maybe not totally safe because we could have multiple rules that have
              that same test expression. But this will help you get the idea of how you might use the configureWebpack
              function in order to mutate state. And there are other options for editing existing config using webpack
              chain, but using webpack chain is beyond the scope of this course. Just be aware that if you start running
              into issues with modifying existing config, you can use webpack chain to help with mutating the
              config.</p>
            <p>
              Okay, so this rule should now be replaced with our new rule, so let's delete our webpack config and then
              let's go regenerate our config:</p>
            <figure>
              <img src="images/Fig07-076.png"/>
              <figcaption>Fig 07-076</figcaption>
            </figure>
            <p>Okay, let's go check this out. So in our webpack config here, let's search for this string again:</p>
            <figure>
              <img src="images/Fig07-077.png"/>
              <figcaption>Fig 07-077</figcaption>
            </figure>
            <p>And you can see now that we are only finding it once and it does have limit changed to 5000:</p>
            <figure>
              <img src="images/Fig07-078.png"/>
              <figcaption>Fig07-078</figcaption>
            </figure>
            <p>So now you've seen how you can edit the webpack config using the object syntax and the function syntax.
              And that's all there really is to editing the webpack configuration. You really have complete flexibility
              here, and all of this without ever having to eject from the Vue CLI so that we can continue to use the Vue
              CLI in the future to do upgrades and to handle most of our webpack config and other configuration for us.
              Cool, and that's all there is to editing webpack config.
            </p>
          </div>
          <div><h3>Summary</h3>
            <p>
              In this module, we learned about:</p>
            <ul>
              <li>Creating a basic Vue.js build using the CLI</li>
              <li>Using environment variables and build modes</li>
              <li>Deploying to a production web server</li>
              <li>Handling deep linking when using HTML5 history mode for client side routing</li>
              <li>Inspecting the built-in webpack config</li>
              <li>Customizing the webpack config</li>
            </ul>
            <p>And in this course, we've explored all the fundamentals you need to know for building and deploying
              quality, professional Vue. js applications. I hope you've enjoyed the course, and thanks for joining me on
              this journey to learn Vue. js fundamentals.</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
</body>
</html>
