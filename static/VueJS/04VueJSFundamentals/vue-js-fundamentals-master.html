<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>maxsagetech - Vue JS Fundamentals</title>
  <script src="https://unpkg.com/vue"></script>
  <!--<link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"-->
  <!--integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" rel="stylesheet">-->
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>

    img {
      max-width: 100%;
     
    }
  </style>
</head>
<body>
<div class="container" id="app">
  <div class="panel-group">
    <div class="panel panel-primary">
      <div class="panel-heading">
        <h2>Vue JS Fundamentals</h2>
      </div>
      <div class="panel-body">
        <div class="course-transcript">
          <div><h2>Course Overview</h2>
            <div><h3>Course Overview</h3>
              <p>Hi everyone. This is Jim Cooper, and welcome to my course on Vue.js Fundamentals. I've been working as
                a full-stack developer for more than 20 years, and I've been a serious front-end developer for the past
                6 years, working with AngularJS, Angular, React, and now Vue. js.</p>
              <p>Having spent some time in all of those frameworks, I'm excited to bring you this course on Vue. js
                Fundamentals. Of all the frameworks, I've found Vue to be the most enjoyable, intuitive, and
                lightweight. It is pure joy to work with. But there's still a lot to learn.</p>
              <p>In this course, we'll start where every Vue.js application should start, with the Vue CLI. We'll use
                the CLI to generate our project, and then we'll immediately start exploring how to build applications as
                we start creating our own Vue components and learning how components interact and communicate with each
                other.</p>
              <p>We'll also learn a lot about the Vue. js router, including how to create and navigate between routes
                and how to work with route params, named views, child routes, and route guards. Then we'll dive into
                managing state throughout our application with Vuex, and we'll see how to use Vuex to communicate
                asynchronously with APIs. We'll also learn how to use directives to easily decorate components or other
                elements with nicely encapsulated functionality. And we'll see how to use filters to format and modify
                data right from within our HTML templates. And of course, a web framework fundamentals course wouldn't
                be complete if you didn't learn how to package applications up and deploy them to production. We'll
                explore Vue's excellent tooling that makes creating production deployments a breeze.</p>
              <p>By the end of this course, you'll know everything you need to know to create production-ready Vue
                applications. Before beginning the course, you should be familiar with basic HTML, CSS, and JavaScript.
                Some knowledge of single-page applications will also be helpful, but if this is your first time jumping
                into single- page apps, that's fine too. So please join me on this journey to learn Vue with the Vue. js
                Fundamentals course at Pluralsight.
              </p>
            </div>
          </div>
          <div><h2>Getting Started with the Vue.js CLI</h2>
            <div><h3>Introduction</h3>
              <p>Hello. This is Jim Cooper, and welcome to this Vue. js Fundamentals module on getting started with the
                Vue. js CLI. In this module, we'll spend a few minutes gaining a high-level understanding of Vue.js
                applications, and then we'll dive into creating our first project with the Vue CLI.</p>
              <p>We'll even start writing some of our own code in this module, including building this home page for the
                Build-a-Bot application that we'll build throughout this course. We're going to have some fun in this
                course using Vue to create a simple website for building and buying custom robots.</p>
              <figure>
                <img src="images/Fig01-001.png"/>
                <figcaption>Fig 01-001</figcaption>
              </figure>
              <p>This application will be rich enough to demonstrate all the fundamental concepts you need in order to
                create your own applications with Vue, but it will also be simple enough that we won't waste our time
                building unnecessary features that have no educational value.</p>
              <p>And this is what it'll look like when you're finished.</p>
              <figure>
                <img src="images/Fig01-002.png"/>
                <figcaption>Fig 01-002</figcaption>
              </figure>
              <p>As you can see, I can come to the build page and start customizing my robot:</p>
              <figure>
                <img src="images/Fig01-003.png"/>
                <figcaption>Fig 01-003</figcaption>
              </figure>
              <p>And I can build the robot that I want and then click Add to Cart to add it to my cart. And then you can
                see, it shows up in my cart here:</p>
              <figure>
                <img src="images/Fig01-004.png"/>
                <figcaption>Fig 01-004</figcaption>
              </figure>
              <p>and I even show which robots I saved money on, if they happen to be on sale. And back on the Build
                page, I can click on any of these parts and learn more about the individual parts:</p>
              <figure>
                <img src="images/Fig01-005.png"/>
                <figcaption>Fig 01-005</figcaption>
              </figure>
              <p>This site doesn't seem like much, but there's a ton of concepts and learning built into this. It will
                be just enough to allow us to dive into things like creating components and child components,
                communicating between those components, routing and navigation, state management, and even API calls to
                a separate server. We'll even explore how to build and deploy this application to production. So let's
                jump right in and start learning about Vue.
              </p>
            </div>
            <div><h3>Gaining a Conceptual Understanding of Vue</h3>
              <p>At the heart of a view jess application, you find the Vue instance, is created whenever you call new
                view. In a typical view application, you will only ever have one Vue Instance.</p>
              <p>When you create a view instance, you will usually tell it to render a component, which you do by
                passing in an options object with a render function, which tells it to render an app component:</p>
              <figure>
                <img src="images/Fig01-006.png"/>
                <figcaption>Fig 01-006</figcaption>
              </figure>
              <p>This app component is the top level component in what will become a hierarchical component structure,
                so you can imagine your view instance wrapping your entire application:</p>
              <figure>
                <img src="images/Fig01-007.png"/>
                <figcaption>Fig 01-007</figcaption>
              </figure>
              <p>and inside that you have your App component and the App component may have a child component:</p>
              <figure>
                <img src="images/Fig01-008.png"/>
                <figcaption>Fig 01-008</figcaption>
              </figure>
              <p>which then may have other child components, etc. This should feel familiar if you've written any
                Angular or React applications, the component structure is similar other than the Vue instance. In a Vue
                application that includes routing, which is probably most view applications there's another piece.</p>
              <p>Basically, instead of the App component containing other components, or maybe in addition to it
                containing other components, it will also contain a router view:</p>
              <figure>
                <img src="images/Fig01-009.png"/>
                <figcaption>Fig 01-009</figcaption>
              </figure>
              <p>Which shows the content for the current Url and as the Url changes, the content inside the router view
                is updated. And while there is a lot more to a Vue application, this is a pretty good conceptual
                overview of the main structure of a Vue App. To understand the rest of the details. Let's jump into
                creating an app from the ground up.
              </p>
            </div>
            <div><h3>Setting up the Environment</h3>
              <p>We're going to need a few tools installed to get going. First, we'll need Git installed. I'm on
                Windows, so I'm going to use Git for Windows, which can be downloaded from here:</p>
              <figure>
                <img src="images/Fig01-010.png"/>
                <figcaption>Fig 01-010</figcaption>
              </figure>
              <p>If you're on a Mac, you can install SCM Git from here. And if you're on Linux, you can just run a
                command like this one:</p>
              <figure>
                <pre><code class="language-command-line">sudo apt-get install git</code></pre>
                <figcaption>Fig 01-011</figcaption>
              </figure>
              <p>from the terminal. I'll go ahead and download and install Git for Windows, and then I'll run that, and
                I'll just use the defaults throughout the install. And now that that's installed, I have this new Git
                Bash console that I can run:</p>
              <figure>
                <img src="images/Fig01-012.png"/>
                <figcaption>Fig 01-012</figcaption>
              </figure>
              <p>so we'll use that in a minute. And actually, while I prefer to use this Bash console, sometimes Windows
                users have issues with it, so if you're getting weird errors, try using the Windows console window
                instead.</p>
              <p>The next thing I need is Node. I prefer to install Node using Node Version Manager, just because it
                makes it easier to switch between versions of Node as I develop different applications. On Windows, I
                can download that from here:</p>
              <figure>
                <img src="images/Fig01-013.png"/>
                <figcaption>Fig 01-013</figcaption>
              </figure>
              <p>For Linux and Mac, you can just run this command from the terminal:</p>
              <figure>
                <pre><code class="language-command-line">curl -o-
                  https://raw.githubusercontent.com/creationix/nvm/v0.32.0/install.sh | bash</code></pre>
                <figcaption>Fig 01-014</figcaption>
              </figure>
              <p>So I'm going to go ahead and install NVM for Windows. And I'll just use all the default options here
                too. Okay, now that that's installed, I'm going to open my Git Bash console. On Windows, be sure to open
                it as an administrator. Okay, now that I have NVM installed, I can just run:</
              <figure>
                <pre><code class="language-command-line">nvm install 8.11.2</code></pre>
                <figcaption>Fig 01-015</figcaption>
              </figure>
              <p>and then the version of Node that you want to install. It's recommended that you use this version for
                this course, if you're following along, to avoid any compatibility issues. And now I can just tell NVM
                to use this version of Node:</p>
              <figure>
                <pre><code class="language-command-line">nvm use 8.11.2</code></pre>
                <figcaption>Fig 01-016</figcaption>
              </figure>
              <p>Okay, we're good to go with Git and Node now. If you have problems using NVM to install Node, you can
                try installing it directly from here:</p>
              <figure>
                <img src="images/Fig01-017.png"/>
                <figcaption>Fig 01-017</figcaption>
              </figure>
              <p>Just choose the correct installer for your system. Okay, let's get coding.
              </p>
            </div>
            <div><h3>Creating a New Project with the Vue CLI</h3>
              <p>We're going to use the Vue CLI to create our new project. If you're using Vue to create a project that
                you're going to deploy to a production environment, I highly recommend you use the CLI. The CLI
                represents a lot of thought and effort by the Vue team to create an environment where you can easily
                work in development, and when you're ready, create an optimized production build. So to get started,
                let's install the Vue CLI.</p>
              <p>We'll do that from the terminal. On Windows, we need to use the Bash terminal we just installed, and
                then we just need to use npm to install the Vue CLI globally, like this:</p>
              <figure>
                <pre><code class="language-command-line">npm install -g @vue/cli</code></pre>
                <figcaption>Fig 01-018</figcaption>
              </figure>
              <p>Typically, this is all you'll do to install the CLI. But for this course, we're going to install a
                specific version like this:</p>
              <figure>
                <pre><code class="language-command-line">npm install -g @vue/cli@3.0.0-rc.3</code></pre>
                <figcaption>Fig 01-019</figcaption>
              </figure>
              <p>If you're following along with this course, be sure to use this same version to ensure you don't run
                into any surprises or problems a long the way. And you can see that I'm using a release candidate
                version of the CLI. That's because version 3 of the CLI is not yet released. But don't worry; even
                though we're using an RC version of the CLI, it will still install a non-RC version of the Vue itself.
                We don't expect there to be any major changes to the CLI before final release, and since doing things
                with version 3 of the CLI is quite different from doing things with version 2, you'll be learning the
                new way to do things.</p>
              <p>Okay, now that that's installed, we can use it to generate our project. So I'm in my dev folder where I
                want to create my project:</p>
              <figure>
                <img src="images/Fig01-020.png"/>
                <figcaption>Fig 01-020</figcaption>
              </figure>
              <p>and now I can just run this command:</p>
              <figure>
                <pre><code class="language-command-line">vue create build-a-bot</code></pre>
                <figcaption>Fig 01-021</figcaption>
              </figure>
              <p>So this is going to create a new Vue project and is going to create that new project in a build-a-bot
                directory. Okay, so notice here that I can either choose to install according to a default preset, or I
                can choose this option to manually select which features to bootstrap my project with:</p>
              <figure>
                <img src="images/Fig01-022.png"/>
                <figcaption>Fig 01-022</figcaption>
              </figure>
              <p>Let's go ahead and choose Manually select features. So you can see that the Vue CLI starts with a
                handful of out-of-the-box features to choose from:</p>
              <figure>
                <img src="images/Fig01-023.png"/>
                <figcaption>Fig 01-023</figcaption>
              </figure>
              <p>Each of the features listed here has the ability, when you select one, to do several things, including
                things like prompting you for more information on the command line, modifying the webpack config,
                installing npm packages, and generating files.</p>
              <p>This is all based on a new Vue plugin architecture as of CLI version 3. And the whole idea is to create
                a zero-config environment, meaning they've done a lot of the thought to create all the webpack and other
                configs so you don't have to worry about that.</p>
              <p>Now usually, that sort of thing makes me nervous because when framework developers say you won't have
                to worry about it, it usually means I'm going to have to worry about it, and it's going to be a pain to
                work with when I do. And as you look at this out-of-the-box list, you might think, well, this is great
                if this list contains the features that I want, but what if I need something else? Or what if I don't
                choose something here and I want to add it later? Well, not to worry. Forget to install one of these? No
                problem, just add it later. Don't see a feature that you want? No problem, anyone can create a plugin
                and add it later. And there's a good chance you'll find that the community has created one for you. And
                when you do need to make changes to the webpack config yourself, you can do that too, all without ever
                having to eject from the CLI. This is all part of an attempt to create a zero-config or low-config
                environment, and they've done a stellar job of it. Of course, if you need to do some custom
                configuration, you can do that too.</p>
              <p>For now, let's just go ahead and add Babel and a linter. We're going to use a router and Vuex later,
                but we'll add those then so you can see how to do that. Okay, so now that I've selected this by hitting
                Space, I can hit enter to continue, and now we need to choose our linter options.</p>
              <figure>
                <img src="images/Fig01-024.png"/>
                <figcaption>Fig 01-024</figcaption>
              </figure>
              <p>And I'm going to go ahead and choose ESLint with the Airbnb config. I really like the Airbnb
                configuration for code styling, so I'll go ahead and select that. So I'll hit Enter, and then I'm going
                to select Lint on save:</p>
              <figure>
                <img src="images/Fig01-025.png"/>
                <figcaption>Fig 01-025</figcaption>
              </figure>
              <p>so that it will execute my linter whenever I save a file. Now I'm going to go ahead and hit Enter
                again. And then I have an option here as to whether to put my config in my package.json or in dedicated
                config files.</p>
              <figure>
                <img src="images/Fig01-026.png"/>
                <figcaption>Fig 01-026</figcaption>
              </figure>
              <p>And I like it in dedicated config files, so I'll select that. And then here I have the option to save
                all of these options that I've selected as a preset for future projects.</p>
              <figure>
                <img src="images/Fig01-027.png"/>
                <figcaption>Fig 01-027</figcaption>
              </figure>
              <p>If I do that, then when I create a new project in the future, I can select that preset instead of
                having to go through all these options again. But I'm just going to go ahead and so no here.</p>
              <p>Okay, so now it's generating our project for us and installing all of our npm dependencies:</p>
              <figure>
                <img src="images/Fig01-028.png"/>
                <figcaption>Fig 01-028</figcaption>
              </figure>
              <p>Cool. Now that that's done, let's take a quick peek at what it generated, and then we'll start writing
                some code of our own. So I'm going to open up my code editor, and I'm using Visual Studio Code, so I'm
                going to change directory into my new build-a-bot folder, and then I'll just type:</p>
              <figure>
                <pre><code class="language-command-line">code.</code></pre>
                <figcaption>Fig 01-029</figcaption>
              </figure>
              <p>and that should start Visual Studio Code in this directory.</p>
              <p>I highly recommend VS Code for working with Vue because it has a lot of great Vue extensions that offer
                some incredible support for working in Vue. In fact, let's take a look at those extensions. So notice
                here that I have an ESLint plugin, Vetur plugin, and a vue plugin:</p>
              <figure>
                <img src="images/Fig01-030.png"/>
                <figcaption>Fig 01-030</figcaption>
              </figure>
              <p>I recommend you install each of these if you're following along or if you're going to be doing Vue
                development in Visual Studio Code. And if you're unfortunate enough to be working in Windows like I am,
                you'll want to update a rule in your ESLint file. So right here we have this. eslintrc. js file, and I
                need to add a rule here to make it so that it handles Windows line endings correctly. So I'm just going
                to add rules, and I'm going to set linebreak-style to 0:</p>
              <figure>
                <img src="images/Fig01-031.png"/>
                <figcaption>Fig 01-031</figcaption>
              </figure>
              <p>Now this won't give me warnings due to my Windows-style line breaks. And then one last thing to
                configure for linting with Vue, over here in my workspace settings, I've configured some ESLint rules
                for formatting Vue files:</p>
              <figure>
                <img src="images/Fig01-032.png"/>
                <figcaption>Fig 01-032</figcaption>
              </figure>
              <p>So notice here that I'm telling ESLint to validate HTML, Vue, and JavaScript files. And notice for each
                one of these sections that autoFix is set to true:</p>
              <figure>
                <img src="images/Fig01-033.png"/>
                <figcaption>Fig 01-033</figcaption>
              </figure>
              <p>So whatever I save, if there are linting errors, it will autofix them for me. And then notice down here
                that I have eslint. autoFixOnSave set to true also. I've found that these settings are all required in
                order to really get ESLint working well and code formatting and styling working well with Vue files.</p>
              <p>All right, now that we've got our editor set up the way we want, let's take a look at what the CLI
                generated for us. We'll start with the package.json file. If we take a look at the scripts in the
                package.json file right here, you can see that it created these three scripts for us, all of which call
                the vue-cli-service.:</p>
              <figure>
                <img src="images/Fig01-034.png"/>
                <figcaption>Fig 01-034</figcaption>
              </figure>
              <p>The vue-cli-service manages a local dev webserver that is based on webpack DevServer.</p>
              <p>We're not going to cover the vue-cli-service in depth in this course, but you can learn more about it
                here:</p>
              <figure>
                <img src="images/Fig01-035.png"/>
                <figcaption>Fig 01-035</figcaption>
              </figure>
              <p>For now, we're just going to go ahead and run this serve script. So back in our terminal, we can just
                run:</p>
              <figure>
                <pre><code class="language-command-line">npm run serve</code></pre>
                <figcaption>Fig 01-036</figcaption>
              </figure>

              <p>And that's going to compile our application for development and then start a development server for us
                on port 8080:</p>
              <figure>
                <img src="images/Fig01-037.png"/>
                <figcaption>Fig 01-037</figcaption>
              </figure>
              <p>There we go. Now let's go take a look at that:</p>
              <figure>
                <img src="images/Fig01-038.png"/>
                <figcaption>Fig 01-038</figcaption>
              </figure>
              <p>Cool. So we can see that we have a running application here, and this is the sample web page that
                always gets generated from the CLI. This just gives us a good starting point that we can start editing.
                So let's take a look at how this is all working and being rendered. So back over here, we'll take a look
                at our main.js file in the src directory:</p>
              <figure>
                <img src="images/Fig01-039.png"/>
                <figcaption>Fig 01-039</figcaption>
              </figure>
              <p>This is the entry point for our Vue application:</p>
              <figure>
                <img src="images/Fig01-040.png"/>
                <figcaption>Fig 01-040</figcaption>
              </figure>
              <p>and you can see it's really simple. Notice we're just creating a new Vue instance here, and then we
                pass in this options object:</p>
              <figure>
                <img src="images/Fig01-041.png"/>
                <figcaption>Fig 01-041</figcaption>
              </figure>
              <p>to configure our Vue application. And all we're currently configuring is the render property. Notice
                that the render property is set to a function and that we're passing this App component into it:</p>
              <figure>
                <img src="images/Fig01-042.png"/>
                <figcaption>Fig 01-042</figcaption>
              </figure>
              <p>And all we're currently configuring on our Vue instance is the render property. Notice that the render
                property is rendering our App component, so when Vue bootstraps our app, it will start by displaying the
                App component. So let's take a look at that next.</p>

              <p>So first of all, notice that there are three sections to this file, a template section:</p>
              <figure>
                <img src="images/Fig01-043.png"/>
                <figcaption>Fig 01-043</figcaption>
              </figure>
              <p>a script section:</p>
              <figure>
                <img src="images/Fig01-044.png"/>
                <figcaption>Fig 01-044</figcaption>
              </figure>
              <p>and a style section:</p>
              <figure>
                <img src="images/Fig01-045.png"/>
                <figcaption>Fig 01-045</figcaption>
              </figure>
              <p>Clearly, this is not a file that a browser could understand, so the question is, how is this getting
                used? Well, consider a couple of things. First of all, there is a Vue-specific webpack plugin being used
                to parse this file into its individual parts and compile them in a way that a browser can use them. And
                secondly, this component was passed into the Vue instance, so Vue will work with what's generated by
                webpack to render this component. We'll talk more about components and each of these sections in the
                next module. For now, all you need to understand is that this App component is the top-level component
                in our app, and as we build our app, it will remain at the top level of our component hierarchy, as it
                is used to display routed components and their child components.</p>
              <p>Right now, there is no routing at work here. The App component is just displaying this HelloWorld
                component:</p>
              <figure>
                <img src="images/Fig01-046.png"/>
                <figcaption>Fig 01-046</figcaption>
              </figure>
              <p>So the App component is displaying this as a child component, and if we go look at that component,
                which is in this components folder, you can see that here is all the HTML and all the links that are
                currently being displayed in our app. Cool, so that's how everything is wired up that was generated by
                the CLI. Next, we'll start replacing this content with some of our own.
              </p>
            </div>
            <div><h3>Creating the Home Page</h3>
              <p>Alright, in this clip we're going to start creating some of our own content. We won't be exploring any
                new concepts just yet. We're just going to spend a little bit of time replacing this generated
                content:</p>
              <figure>
                <img src="images/Fig01-047.png"/>
                <figcaption>Fig 01-047</figcaption>
              </figure>
              <p>
                with some of our own content. This will get us a little more familiar with what the CLI generated and
                with the layout of our new app before we start digging into key Vue.js concepts. So let's start by
                renaming this HelloWorld component. This will become our new home page, so let's name it
                HomePage.vue:</p>
              <figure>
                <img src="images/Fig01-048.png"/>
                <figcaption>Fig 01-048</figcaption>
              </figure>
              <p>
                We could just name it Home.vue, but one of the Vue style guide rules says that components should be two
                words at a minimum. So we'll name it HomePage. And let's update the component name down here too:</p>
              <figure>
                <img src="images/Fig01-049.png"/>
                <figcaption>Fig 01-049</figcaption>
              </figure>
              <p>And then we'll have to update the import for this in the App component, so instead of importing
                HelloWorld, we'll import HomePage from HomePage.vue:</p>
              <figure>
                <img src="images/Fig01-050.png"/>
                <figcaption>Fig 01-050</figcaption>
              </figure>
              <p>and then we'll use that down here:</p>
              <figure>
                <img src="images/Fig01-051.png"/>
                <figcaption>Fig 01-051</figcaption>
              </figure>
              <p>And we'll change it up here in the template:</p>
              <figure>
                <img src="images/Fig01-052.png"/>
                <figcaption>Fig 01-052</figcaption>
              </figure>
              <p>And we don't need this msg attribute anymore, so we'll delete that:</p>
              <figure>
                <img src="images/Fig01-053.png"/>
                <figcaption>Fig 01-053</figcaption>
              </figure>
              <p>And I'd like to put all of this inside a main element:</p>
              <figure>
                <img src="images/Fig01-054.png"/>
                <figcaption>Fig 01-054</figcaption>
              </figure>
              <p>And we don't want this Vue logo up here anymore:</p>
              <figure>
                <img src="./images/Fig01-055.png"/>
                <figcaption>Fig 01-055.png</figcaption>
              </figure>
              <p>so we'll delete that. All right, and then let's add a couple of styles and clean up some styles that we
                don't need. So down here in the style section of our App component, I'd like to add a gradient to the
                body of our application. So I'm going to give it a background, I'm going to set linear-gradient to a
                gradient from top to bottom, and let's fix that spelling error, and then I want to set the
                background-attachment to fixed:</p>
              <figure>
                <img src="images/Fig01-056.png"/>
                <figcaption>Fig 01-056</figcaption>
              </figure>
              <p>And then down here on the app element, I'm just going to remove everything except our font family:</p>
              <figure>
                <img src="images/Fig01-057.png"/>
                <figcaption>Fig 01-057.png</figcaption>
              </figure>
              <p>
                And by the way, this app element is just referring to this div up here that has an id of app:</p>
              <figure>
                <img src="images/Fig01-058.png"/>
                <figcaption>Fig 01-058</figcaption>
              </figure>
              <p>And then I just wanted to add a few styles for this main div, so down here I'll add a main style. And I
                want to set margin to 0 auto, so this will center the main content, and we'll add some padding and give
                it a background-color of white and a width of 1024px and then just a min-height of 300px:</p>
              <figure>
                <img src="images/Fig01-059.png"/>
                <figcaption>Fig 01-059</figcaption>
              </figure>
              <p>Okay, we'll talk more about components and styling them in the next module. We're just trying to get a
                decent starting point set up here, and then we'll delve into this stuff more. So let's go see what our
                site looks like now:</p>
              <figure>
                <img src="images/Fig01-060.png"/>
                <figcaption>Fig 01-060</figcaption>
              </figure>
              <p>Okay, ignore the main content area, but notice that our background has a gray gradient now, and our
                main content area has a white background. Now let's go replace all of this content with our HomePage
                content. So back in our HomePage component, up here in the template, all right, so let's delete all of
                this content inside the outer div, and we'll change this class to home:</p>
              <figure>
                <img src="images/Fig01-061.png"/>
                <figcaption>Fig 01-061</figcaption>
              </figure>
              <p>And then I'm just going to go ahead and paste a little bit of content here. If you're following along,
                go ahead and paste this in:</p>
              <figure>
                <img src="images/Fig01-062.png"/>
                <figcaption>Fig 01-062</figcaption>
              </figure>
              <p>And then notice that we just have a couple of divs here:</p>
              <figure>
                <img src="images/Fig01-063.png"/>
                <figcaption>Fig 01-063</figcaption>
              </figure>
              <p>One just has an image of a robot, and the other has a get-started link. So notice that this image is
                loading robot-home.png file out of the assets folder, but that file doesn't exist in here:</p>
              <figure>
                <img src="images/Fig01-064.png"/>
                <figcaption>Fig 01-064</figcaption>
              </figure>
              <p>This is just the Vue logo that came with our Vue CLI sample page. So let's go download that
                robot-home.png file. To help us with this and a number of other tasks throughout this course, I've
                created a little helper repo over here in GitHub for the Vue.js Fundamentals course:</p>
              <figure>
                <img src="images/Fig01-065.png"/>
                <figcaption>Fig 01-065</figcaption>
              </figure>
              <p>And there's just a few files in here that we will occasionally use to download things as we go
                throughout this course. So in the src folder, notice we have an assets folder, and here is the
                robot-home.png file:</p>
              <figure>
                <img src="images/Fig01-066.png"/>
                <figcaption>Fig 01-066</figcaption>
              </figure>
              <p>And we'll actually need this other image, too, so we might as well download them both. So first I'll
                click on robot-home, and then click on Download, and then Save image as, and then I just need to go find
                my build-a-bot folder. And in the assets folder, we'll just save it here:</p>
              <figure>
                <img src="images/Fig01-067.png"/>
                <figcaption>Fig 01-067</figcaption>
              </figure>
              <p>And then we can go back and do the same thing for this build-a-bot logo. So we'll save that here too.
                Okay, cool. So now that robot-home image exists in our assets folder:</p>
              <figure>
                <img src="images/Fig01-068.png"/>
                <figcaption>Fig 01-068</figcaption>
              </figure>
              <p>Now we just need to clean up some styles down here. And we don't need any of these:</p>
              <figure>
                <img src="images/Fig01-069.png"/>
                <figcaption>Fig 01-069</figcaption>
              </figure>
              <p>so I'm just going to add a few classes here. So we have a home class, and I just want that to be
                text-align: center, and then a robot class, and I just want to set the height to 300px:</p>
              <figure>
                <img src="images/Fig01-070.png"/>
                <figcaption>Fig 01-070</figcaption>
              </figure>
              <p>This is for that robot image. So let's go see what our site looks like now:</p>
              <figure>
                <img src="images/Fig01-071.png"/>
                <figcaption>Fig 01-071</figcaption>
              </figure>
              <p>Okay, cool. This is looking great now. And you may have noticed that I didn't need to hit refresh on
                this page in order to see my changes. That's because we are using, behind the scenes Vue CLI is using
                the webpack DevServer, including Hot Module Replacement. So as we make changes to our code, the changes
                immediately show up in our browser without us having to refresh.</p>
              <p>Okay, awesome. So now we've created a new home page. But let's add one more thing that we're going to
                use throughout this course. Our site is missing a navigation header, so let's add that quick. And we
                could add that to our home component, but then when we navigate away from our home page, we would lose
                that navigation header. So really we want it to be on our App component. So up here just above our main
                element, we're going to add a header element:</p>
              <figure>
                <img src="images/Fig01-072.png"/>
                <figcaption>Fig 01-072</figcaption>
              </figure>
              <p>And that's going to have a nav element:</p>
              <figure>
                <img src="images/Fig01-073.png"/>
                <figcaption>Fig 01-073</figcaption>
              </figure>
              <p>and this nav element is nothing special. It's not Vue specific; it's just a normal HTML element that
                comes with HTML 5. And then inside here, we're going to use an unordered list to list out each of the
                nav elements:</p>
              <figure>
                <img src="images/Fig01-074.png"/>
                <figcaption>Fig 01-074</figcaption>
              </figure>
              <p>And for now, that's just going to have one list element, and that will have a nav-item class:</p>
              <figure>
                <img src="images/Fig01-075.png"/>
                <figcaption>Fig 01-075</figcaption>
              </figure>
              <p>And then inside here we're going to have an image, which will be our logo, so we'll give that logo
                class. And this is going to be the other image that we downloaded, so in our assets folder, it is the
                build-a-bot-logo.png file:</p>
              <figure>
                <img src="images/Fig01-076.png"/>
                <figcaption>Fig 01-076</figcaption>
              </figure>
              <p>And then we'll just say Build-a-Bot here:</p>
              <figure>
                <img src="images/Fig01-077.png"/>
                <figcaption>Fig 01-077</figcaption>
              </figure>
              <p>And now we just need to add some styles to style that. Again, we'll cover styling in more depth in the
                next module. But rather than have you type in all the styles, let's go over to our helper repo, and in
                the src folder, there is this header.css:</p>
              <figure>
                <img src="images/Fig01-078.png"/>
                <figcaption>Fig 01-078</figcaption>
              </figure>
              <p>And we're just going to click on the raw version of that and copy all of it, and then let's just paste
                that all in right here:</p>
              <figure>
                <img src="images/Fig01-079.png"/>
                <figcaption>Fig 01-079</figcaption>
              </figure>
              <p>Okay, so you can see we're just adding some header and nav item styling here and some styling for our
                logo. Okay, let's go take a look at that:</p>
              <figure>
                <img src="images/Fig01-080.png"/>
                <figcaption>Fig 01-080</figcaption>
              </figure>
              <p>All right, awesome. So you can see here, again, without having to refresh, Hot Module Refreshment just
                updated our page for us, and we now have a navigation bar at the top with a list item here on the left
                for navigating to our home page. And that's not a link yet or anything. We'll update that later. But now
                we have a home page with a navigation bar in our App component. And I realize that this clip was just a
                bit of just following along, not a lot of new concepts. But hopefully as we moved around in the app and
                replaced some HTML in our home page component and our App component, you began to become a little bit
                more familiar with the layout of our application, and hopefully that will help a bit going forward.</p>
              <p>In the next module, we're going to dive into components and templates syntax and start learning a lot
                more concepts. So in this module, we just learned some high-level things about Vue, and how to use the
                Vue CLI to create a project, and a little bit about working within components and making some HTML and
                CSS changes. In the next module, we're going to take a much deeper look at components and templates in
                text, so let's go jump into that.
              </p>
            </div>
          </div>
          <div><h2>Creating Vue.js Components and Using Template Syntax</h2>
            <div><h3>Introduction</h3>
              <p>
                In this module, we're going to explore all the fundamentals of creating Vue. js components and working
                with component syntax. This includes creating components, using bindings to display data and handle
                events, conditionally displaying elements with v-if and v-show, showing elements with v-for, styling
                components, working with component livecycle hooks, and reducing duplication with mixins. There's a lot
                here, so let's get started.
              </p>
            </div>
            <div><h3>Global Components vs. Single-file Components</h3>
              <p>
                Before we jump into coding, we should understand the difference between global components and
                single-file components:</p>
              <figure>
                <img src="images/Fig02-001.png"/>
                <figcaption>Fig 02-001</figcaption>
              </figure>
              <p>In this course, we'll be working only with single-file components, but in the wild, you'll likely run
                into Vue code that is using global components, so let's briefly talk about each of them and why you
                might use one over the other.</p>
              <p>First of all, it's good to understand that a component is really just another Vue instance. In fact,
                the easiest way to just get something to render in Vue would be to just create a Vue instance like
                this:</p>
              <figure>
                <img src="images/Fig02-002.png"/>
                <figcaption>Fig 02-002</figcaption>
              </figure>
              <p>
                You can see here that we're creating a new instance of Vue, and then we're passing in an options object
                that has a simple Hello World template:</p>
              <figure>
                <img src="images/Fig02-003.png"/>
                <figcaption>Fig 02-003</figcaption>
              </figure>
              <p> This line of code tells Vue which element on the page to mount this template in:</p>
              <figure>
                <img src="images/Fig02-004.png"/>
                <figcaption>Fig 02-004</figcaption>
              </figure>
              <p>So this is a really simple Vue application. In fact, you can hardly call it an application. But with
                this syntax, what if I want to get more complex, for example, if I want to break things up into smaller,
                reusable components? Well, we can do that with global components.</p>
              <p>To demonstrate this, let's pull this part of the template out into a separate component.</p>
              <figure>
                <img src="images/Fig02-005.png"/>
                <figcaption>Fig 02-005</figcaption>
              </figure>
              <p>So just above this, we'll create a new component, and notice here that we're calling Vue.component:</p>
              <figure>
                <img src="images/Fig02-006.png"/>
                <figcaption>Fig 02-006</figcaption>
              </figure>
              <p>
                and then we're passing in the name of the component here. And this last line should look a little
                familiar:</p>
              <figure>
                <img src="images/Fig02-007.png"/>
                <figcaption>Fig 02-007</figcaption>
              </figure>
              <p>This is the options object, and it is the same type of object that we're passing into our Vue instance
                down here:</p>
              <figure>
                <img src="images/Fig02-008.png"/>
                <figcaption>Fig 02-008</figcaption>
              </figure>
              <p>except that we're just not specifying an element property. This should help underscore the fact that
                components are really just Vue instances. With just one or two exceptions, the options object that you
                pass into a new component has the exact same properties available as the one you pass in to a Vue
                instance.</p>
              <p>So anyhow, notice that our new World component is assigned to this World variable:</p>
              <figure>
                <img src="images/Fig02-009.png"/>
                <figcaption>Fig 02-009</figcaption>
              </figure>
              <p>So now we can replace this part of our component:</p>
              <figure>
                <img src="images/Fig02-010.png"/>
                <figcaption>Fig 02-010</figcaption>
              </figure>
              <p>with that component like this:</p>
              <figure>
                <img src="images/Fig02-011.png"/>
                <figcaption>Fig 02-011</figcaption>
              </figure>
              <p>This World component:</p>
              <figure>
                <img src="images/Fig02-012.png"/>
                <figcaption>Fig 02-012</figcaption>
              </figure>
              <p>is a global component. It's just a global constant that I could use anywhere I want. This type of
                component is great for fairly small applications and especially great for prototyping, but it's not a
                great option for full, single-page applications at larger scale for a few reasons.</p>
              <p>First of all, in larger applications, global variables inevitably cause problems because they can be
                hard to locate, but more importantly, it's easy to run into naming conflicts.</p>
              <p>Secondly, global components use string templates. That means all of your HTML has to be defined inside
                a JavaScript string, which means you don't get any syntax highlighting, and you end up doing lots of
                escaping.</p>
              <p>
                Another limitation of global components is that while they nicely encapsulate your HTML template and
                component logic, CSS is completely left out of the encapsulation, requiring you to rely on global CSS
                styling.</p>
              <p>And finally, global components have no build-time compilation support, meaning, for example, you can't
                do any sort of preprocessing with things like Babel. Single-file components help us with all these
                limitations.</p>
              <p>A single-file component is a file with a Vue extension. There are typically three sections in a Vue
                file, including a template section, a script section, and a style section:</p>
              <figure>
                <img src="images/Fig02-013.png"/>
                <figcaption>Fig 02-013</figcaption>
              </figure>
              <p>The template and script sections are required, whereas the style section is optional. We'll dig deeper
                into everything you can do in these sections throughout the course, but basically the template section
                is where we define our HTML template. The script section is where we define the JavaScript functionality
                of our component and where we export it so that it can be exported elsewhere. And finally, the style
                section is where we define the CSS classes used by our template.</p>
              <p>Of course, if you look at this file:</p>
              <figure>
                <img src="images/Fig02-014.png"/>
                <figcaption>Fig 02-014</figcaption>
              </figure>
              <p>no browser is going to be able to render a file like this, so Vue files are compiled by webpack at
                build time to generate HTML, JavaScript, and CSS files that the browser can work with. This compilation
                comes for free, already configured for us when we start the project with the CLI. This all makes using
                single-file components a no-brainer when building full-featured web applications with Vue.</p>
              <p>So we'll be using single- file components throughout our course. And you may remember that this is what
                our App.vue component looks like that was generated by the CLI.</p>
              <figure>
                <img src="images/Fig02-015.png"/>
                <figcaption>Fig 02-015</figcaption>
              </figure>
              <p>The App.vue component is a single-file component and so is the HelloWorld component that the CLI
                created that we renamed to our HomePage component. Cool. So now that we understand a bit about the
                different types of components, let's jump into creating our first component from scratch.
              </p>
            </div>
            <div><h3>Creating Your First Component</h3>
              <p>All right, now the real fun begins. Let's start creating our own components. We already have a HomePage
                component; now we want to create a page where we can build our custom robots. A new page means a new Vue
                components, and I could just put that new component right here:</p>
              <figure>
                <img src="images/Fig02-016.png"/>
                <figcaption>Fig 02-016</figcaption>
              </figure>
              <p>in the components directory, but I don't think that scales very well as applications get larger. I
                prefer to structure my apps by feature areas, so let's make that change now. We'll start by creating a
                new home folder, and then we'll move the HomePage component into that folder:</p>
              <figure>
                <img src="images/Fig02-017.png"/>
                <figcaption>Fig 02-017</figcaption>
              </figure>
              <p>And now I can delete this empty components folder:</p>
              <figure>
                <img src="images/Fig02-018.png"/>
                <figcaption>Fig 02-018</figcaption>
              </figure>
              <p>All right, now we just need to update the reference to our HomePage component over here in our app
                component. It's now in the home folder:</p>
              <figure>
                <img src="images/Fig02-019.png"/>
                <figcaption>Fig 02-019</figcaption>
              </figure>
              <p>And that should be rendering fine, so let's go take a look at that:</p>
              <figure>
                <img src="images/Fig02-020.png"/>
                <figcaption>Fig 02-020</figcaption>
              </figure>
              <p>Okay, yep, that's working just fine. Now let's create our new component. So this is going to be a robot
                builder component, so let's create a new area for building. We'll call that the build folder. And then
                in here we'll create a new single-file component called RobotBuilder:</p>
              <figure>
                <img src="images/Fig02-021.png"/>
                <figcaption>Fig 02-021</figcaption>
              </figure>
              <p>Remember, component names should be two words. Okay, so let's create our three sections in here, so
                we'll have a template section and a script section and a style section.</p>
              <figure>
                <img src="images/Fig02-022.png"/>
                <figcaption>Fig 02-022</figcaption>
              </figure>
              <p>All right, our template's complaining just because we don't have a root element in here yet. We'll fix
                that in just a minute.</p>
              <p>First, we'll go ahead and create out component element and export it. So we're just going to export an
                object, and we'll give it a name, so this is our RobotBuilder:</p>
              <figure>
                <img src="images/Fig02-023.png"/>
                <figcaption>Fig 02-023</figcaption>
              </figure>
              <p>And notice that ESLint ran when I saved it, and it just removed some extraneous spaces at the
                beginning. So ESLint will run every time I save.</p>
              <p>Okay, now for the HTML and CSS. I don't want to bore you with typing in a bunch of HTML that isn't
                really Vue specific, so let's copy this from our GitHub repo. So back over here in the this src folder
                in the build folder, you can see I've created an HTML and CSS file for this component:</p>
              <figure>
                <img src="images/Fig02-024.png"/>
                <figcaption>Fig 02-024</figcaption>
              </figure>
              <p>so let's click on the HTML file, and then we'll click on Raw and copy this:</p>
              <figure>
                <img src="images/Fig02-025.png"/>
                <figcaption>Fig 02-025</figcaption>
              </figure>
              <p>and then we'll paste that back into our template. Okay, so you can see that we just have a bunch of
                HTML in here. There's nothing specific about Vue here, but you can see that we have a top section, a
                middle row section, and a bottom row section. And you can see the part selectors here:</p>
              <figure>
                <img src="images/Fig02-026.png"/>
                <figcaption>Fig 02-026</figcaption>
              </figure>
              <p>They basically are comprised of an image and buttons for left and right or up and down for changing the
                selected part.</p>
              <p>Just as a reminder of what we're actually building here, it's this Build page here:</p>
              <figure>
                <img src="images/Fig02-027.png"/>
                <figcaption>Fig 02-027</figcaption>
              </figure>
              <p>So this is our top section, our middle section, and our bottom section, and then here are the part
                selectors, what I'm calling part selectors, which consist of an image and buttons to select the
                individual parts. And so that's what all this HTML is here.</p>
              <figure>
                <img src="images/Fig02-028.png"/>
                <figcaption>Fig 02-028</figcaption>
              </figure>
              <p>And these buttons are not wired up to do anything yet, but you can see I have a lot of classes here, so
                let's go grab the styles for this file also.</p>
              <p>So back over here in our repository, we'll go back and back again, and I'm going to click on this
                RobotBuilder. css file and grab the content out of here:</p>
              <figure>
                <img src="images/Fig02-029.png"/>
                <figcaption>Fig 02-029</figcaption>
              </figure>
              <p>And then we're going to go ahead and paste that into the style section down here:</p>
              <figure>
                <img src="images/Fig02-030.png"/>
                <figcaption>Fig 02-030</figcaption>
              </figure>
              <p>So this is just all the styles for positioning each of those part selectors and the buttons and
                everything. And again, there's nothing really Vue specific here with regards to what I pasted in. This
                is all just CSS styling. The only thing that's Vue specific here is that I put the CSS inside this style
                tag in our single-file component.</p>
              <p>Okay, and then you can see these image tags are pointing to images that we haven't downloaded yet, so
                let's go grab those. And back over in our GitHub repo, you can see inside the build folder, there's an
                images folder, and there's a lot of images here:</p>
              <figure>
                <img src="images/Fig02-031.png"/>
                <figcaption>Fig 02-031</figcaption>
              </figure>
              <p>I could just click on each one of these and download them one at a time, but it will be easier to just
                clone this repo and then copy them locally.</p>
              <p>So I'm going to go back over to my terminal and stop my server, and then I'm going to move back a
                directory. And then I'm going to git clone this repo here. Okay, let's go ahead and clone that:</p>
              <figure>
                <img src="images/Fig02-032.png"/>
                <figcaption>Fig 02-032</figcaption>
              </figure>
              <p>Okay, now that that's there, I can go back into my build-a-bot directory, and then we'll change into
                the src/build directory, and we'll make a images directory here. And we'll move into that directory.</p>
              <figure>
                <img src="images/Fig02-033.png"/>
                <figcaption>Fig 02-033</figcaption>
              </figure>
              <p>
                Okay, now I can just copy those images from the cloned helper repo like this. So we'll just grab
                everything out of the images directory and copy it into this directory:</p>
              <figure>
                <img src="images/Fig02-034.png"/>
                <figcaption>Fig 02-034</figcaption>
              </figure>
              <p>Okay, so now you can see we have all those images in here. All right, now that we have those, let's
                move back to our application directory, and we'll go ahead and start the server:</p>
              <figure>
                <img src="images/Fig02-035.png"/>
                <figcaption>Fig 02-035</figcaption>
              </figure>
              <p>All right, now let's go take a look at what our new page looks like. Of course, how are we going to get
                to this page? We don't have routing set up yet, and so how are we going to view this RobotBuilder
                instead of the home page? Well, for now, we'll just have to import it over here also:</p>
              <figure>
                <img src="images/Fig02-036.png"/>
                <figcaption>Fig 02-036</figcaption>
              </figure>
              <p>And then we'll just go ahead and render this here instead of the HomePage component, and we'll comment
                this out for now:</p>
              <figure>
                <img src="images/Fig02-037.png"/>
                <figcaption>Fig 02-037</figcaption>
              </figure>
              <p>And then we just need to use this up in our template here:</p>
              <figure>
                <img src="images/Fig02-038.png"/>
                <figcaption>Fig 02-038</figcaption>
              </figure>
              <p>Okay, so now this should be showing our RobotBuilder instead of the HomePage, so let's go check that
                out. Okay, perfect. So you can see that we have our new RobotBuilder component rendering here:</p>
              <figure>
                <img src="images/Fig02-039.png"/>
                <figcaption>Fig 02-039</figcaption>
              </figure>
              <p>but these buttons don't do anything yet. But this is awesome. We have a new component, and it's just
                got some really basic HTML and CSS, and all we're doing so far with the component is just exporting it
                and then using it here in our main App component:</p>
              <figure>
                <img src="images/Fig02-040.png"/>
                <figcaption>Fig 02-040</figcaption>
              </figure>
              <p>So let's make this page more interesting next by adding some bindings so that we can start selecting
                the individual parts.
              </p>
            </div>
            <p>
            <h3>Binding Attributes to Data with v-bind</h3>
            <p>In order to make our new Build page a little more dynamic, we need to start by binding it to data from
              the component instead of these images being hardcoded in the HTML template:</p>
            <figure>
              <img src="images/Fig02-041.png"/>
              <figcaption>Fig 02-041</figcaption>
            </figure>
            <p>In order to provide data to our component, we need to update our component options to have a data
              function. So down here, we'll add that right here:</p>
            <figure>
              <img src="images/Fig02-042.png"/>
              <figcaption>Fig 02-042</figcaption>
            </figure>
            <p>So this is just going to be a function, and right now we'll just return an empty object. If we look at
              our Build page, we have all these different parts, heads, arms, torsos, and bases:</p>
            <figure>
              <img src="images/Fig02-043.png"/>
              <figcaption>Fig 02-043</figcaption>
            </figure>
            <p>And eventually, when we click these buttons, the corresponding part will be swapped out for another one.
              We're not going to wire up these buttons just yet, but let's get the images wired up to a list of
              parts.</p>
            <p>First, we need some data. Eventually we'll get the data for the parts from an API, but for now, we'll
              just create a file with all the data in it. So let's create a data folder inside our src folder, and
              inside that folder, we'll create a new parts. js file. And this folder is also going to contain our
              images, so let's move that images folder from our build folder into the data folder:</p>
            <figure>
              <img src="images/Fig02-044.png"/>
              <figcaption>Fig 02-044</figcaption>
            </figure>
            <p>Okay, now we need our parts data, so let's go back to our GitHub repo, let's go into the data folder, and
              grab this parts.js content:</p>
            <figure>
              <img src="images/Fig02-045.png"/>
              <figcaption>Fig 02-045</figcaption>
            </figure>
            <p>and we'll paste that into here. So this is mostly just JSON data, but you can see up here, this first
              line, there's some web pack goodness here:</p>
            <figure>
              <img src="images/Fig02-046.png"/>
              <figcaption>Fig 02-046</figcaption>
            </figure>
            <p>So we're using web pack's require.context here to make web pack aware of the image URLs so that we can
              just use them throughout this JSON data as relative URLs. So down here on line 10, you can see that we're
              calling images function and passing in a relative URL:</p>
            <figure>
              <img src="images/Fig02-047.png"/>
              <figcaption>Fig 02-047</figcaption>
            </figure>
            <p>When this is compiled by web pack, this will point to the relative URL of this image file. So other than
              that, this is all just JSON, and you can see that we have this parts variable up here:</p>
            <figure>
              <img src="images/Fig02-048.png"/>
              <figcaption>Fig 02-048</figcaption>
            </figure>
            <p>our constant, and that we're exporting it down here:</p>
            <figure>
              <img src="images/Fig02-049.png"/>
              <figcaption>Fig 02-049</figcaption>
            </figure>
            <p>And just so we understand the shape of our data a little bit, if I collapse each of these sections, you
              can see that the parts object is an object with properties for heads, arms, torsos, and bases:</p>
            <figure>
              <img src="images/Fig02-050.png"/>
              <figcaption>Fig 02-050</figcaption>
            </figure>
            <p>Each one of those is an array of parts. So this data is perfect for what we need. So let's jump back over
              to our RobotBuilder, and then let's import that data here. So we will import availableParts from
              data/parts:</p>
            <figure>
              <img src="images/Fig02-051.png"/>
              <figcaption>Fig 02-051</figcaption>
            </figure>
            <p>So the ESLint plugin for Visual Studio Code is a little bit funny. You might notice that I hit Save
              multiple times there, and it reformatted according to my linting rules a couple of times.</p>
            <p>Okay, so now we just want to return these available parts as part of our data object, so we can just
              return it like this:</p>
            <figure>
              <img src="images/Fig02-052.png"/>
              <figcaption>Fig 02-052</figcaption>
            </figure>
            <p>So now our data object is an object with an availableParts property that is set to that JSON data. Now
              let's see how we can use this data in our template.</p>
            <p>At the top of our template here, we have this image that is displaying currently the head image for a
              robot, and instead of setting the src to a hardcoded string like this:</p>
            <figure>
              <img src="images/Fig02-053.png"/>
              <figcaption>Fig 02-053</figcaption>
            </figure>
            <p>we want to bind it to an expression. We can do that like this:</p>
            <figure>
              <img src="images/Fig02-054.png"/>
              <figcaption>Fig 02-054</figcaption>
            </figure>
            <p>So this says bind the source attribute of this image element to this expression in the quotes. And inside
              that expression, we can access availableParts:</p>
            <figure>
              <img src="images/Fig02-055.png"/>
              <figcaption>Fig 02-055</figcaption>
            </figure>
            <p>So this is the availableParts object that we exposed in our data function. And then availableParts has a
              heads property which is an array, and we'll grab the first head and then grab the src property:</p>
            <figure>
              <img src="images/Fig02-056.png"/>
              <figcaption>Fig 02-056</figcaption>
            </figure>
            <p>So the src property, thanks to web pack, and we talked about this just a minute ago, this is the relative
              URL to the image for this head. Okay, so let's copy this expression down to each of the other parts. So
              we'll set these to v-bind also. And for now, we'll just bind them all to the heads:</p>
            <figure>
              <img src="images/Fig02-057.png"/>
              <figcaption>Fig 02-057</figcaption>
            </figure>
            <p>Okay, so if we look at this, we now have a robot with all heads:</p>
            <figure>
              <img src="images/Fig02-058.png"/>
              <figcaption>Fig 02-058</figcaption>
            </figure>
            <p>not a very useful robot, so let's just update each one of these to point to the correct part type. So
              here instead of heads, this is going to be arms, and this is going to be torsos:</p>
            <figure>
              <img src="images/Fig02-059.png"/>
              <figcaption>Fig 02-059</figcaption>
            </figure>
            <p>and this one is also arms, and then this is bases:</p>
            <figure>
              <img src="images/Fig02-060.png"/>
              <figcaption>Fig 02-060</figcaption>
            </figure>
            <p>Now if we refresh, there we go, now we have a functional robot again:</p>
            <figure>
              <img src="images/Fig02-061.png"/>
              <figcaption>Fig 02-061</figcaption>
            </figure>
            <p>And that's all thanks to the v-bind syntax, which is binding the source attribute of the image element to
              these expressions. Of course, you can bind any attribute of any element using v-bind.</p>
            <p>So now our image source attributes are all bound, but we can't change them. We still are not changing the
              image when we click these selector buttons. To do that, we're going to have to bind to the click event.
              Let's see how to do that next.
            </p>
          </div>
          <div><h3>Binding to Events with v-on</h3>
            <p>
              In order to react to actions by the user such as clicking on these buttons, we need to bind to the events
              of those elements. That's just as easy as binding to data was. All we need to do is use the v-on syntax.
              So on this button, I'm going to add a v-on binding to the click event:</p>
            <figure>
              <img src="images/Fig02-062.png"/>
              <figcaption>Fig 02-062</figcaption>
            </figure>
            <p>So now whenever this button is clicked, the expression inside these quotes would be called. So what I
              want to do here is I want to call a function:</p>
            <figure>
              <img src="images/Fig02-063.png"/>
              <figcaption>Fig 02-063</figcaption>
            </figure>
            <p>So I'm going to call selectNextHead. So this is the next button for the head image, so when the user
              clicks on this button, we're going to call this selectNextHead function. And that function needs to exist
              on our component. To do that, we're going to introduce a new property on our component called methods:</p>
            <figure>
              <img src="images/Fig02-064.png"/>
              <figcaption>Fig 02-064</figcaption>
            </figure>
            <p>and that's an object, and then you define each of the functions inside of here that you're going to call
              from your template. So we need selectNextHead:</p>
            <figure>
              <img src="images/Fig02-065.png"/>
              <figcaption>Fig 02-065</figcaption>
            </figure>
            <p>and for now, let's just console.log selectNextHead called. So let's go see if that works. So over here,
              let's open our console and then click this button:</p>
            <figure>
              <img src="images/Fig02-066.png"/>
              <figcaption>Fig 02-066</figcaption>
            </figure>
            <p>There you go; you can see each time I click it, this selectNextHead called gets logged. So our v-on click
              binding is working.</p>
            <p>But what we really want to do is have it select the next head instead of just console. logging. So we're
              going to have to track some index and increment and decrement it when the buttons are clicked. To do that,
              let's add a selectedHeadIndex to our data object:</p>
            <figure>
              <img src="images/Fig02-067.png"/>
              <figcaption>Fig 02-067</figcaption>
            </figure>
            <p>and we'll initialize that initially to 0. And then in our selectNextHead function, we'll increment that
              like this:</p>
            <figure>
              <img src="images/Fig02-068.png"/>
              <figcaption>Fig 02-068</figcaption>
            </figure>
            <p>And then to make that work up here in our template, instead of hardcoding this to 0, we're going to use
              our new selectedHeadIndex:</p>
            <figure>
              <img src="images/Fig02-069.png"/>
              <figcaption>Fig 02-069</figcaption>
            </figure>
            <p>So now this will grab the head that matches that index and bind the source property to the URL of that
              head. Okay, let's go check this out:</p>
            <figure>
              <img src="images/Fig02-070.png"/>
              <figcaption>Fig 02-070</figcaption>
            </figure>
            <p>Cool, so now as I click on this button, you can see that Vue is calling our selectNextHead function,
              which is incrementing the index, which updates the binding for that image. Okay, let's do the same thing
              for selectPreviousHead:</p>
            <figure>
              <img src="images/Fig02-071.png"/>
              <figcaption>Fig 02-071</figcaption>
            </figure>
            <p>So we need, on this previous selector, we need a v-on click binding, and that will call
              selectPreviousHead. So now let's go create that function down here:</p>
            <figure>
              <img src="images/Fig02-072.png"/>
              <figcaption>Fig 02-072</figcaption>
            </figure>
            <p>and that will decrement that index. Now let's go check that out. All right, cool, now I can move back and
              forth between the heads. Of course, we have a slight problem here. If I open the console, clicking on this
              next button, you can see that at some point I start getting an error:</p>
            <figure>
              <img src="images/Fig02-073.png"/>
              <figcaption>Fig 02-073</figcaption>
            </figure>
            <p>This is because we are incrementing that index out of range. So basically, we need to make it so that
              when we get to the end of the heads, then when you click the next button, it resets the index back to
              0.</p>
            <p>So to fix that, I'm going to create a couple of helper functions up here at the top of my script
              block:</p>
            <figure>
              <img src="images/Fig02-074.png"/>
              <figcaption>Fig 02-074</figcaption>
            </figure>
            <p>
              Okay, so we have a getPreviousValidIndex function and a getNextValidIndex function. And if you're
              following along, go ahead and type this in, but you can see it's just going to, when you're clicking
              getPrevious, it will deprecate it until it gets to 0, and then it will set it to the last head, and then
              vice-versa with the getNextValidIndex function.</p>
            <p>And then notice that these functions take in the index to increment and the length of the current parts
              array. So down here:</p>
            <figure>
              <img src="images/Fig02-075.png"/>
              <figcaption>Fig 02-075</figcaption>
            </figure>
            <p>instead of incrementing this, we're going to call getNextValidIndex, and we will pass in
              this.selectedHeadIndex, and the length of the heads array:</p>
            <figure>
              <img src="images/Fig02-076.png"/>
              <figcaption>Fig 02-076</figcaption>
            </figure>
            <p>Okay, and then we'll do the same sort of thing for getPreviousHeadIndex. Okay, so that should fix this
              problem:</p>
            <figure>
              <img src="images/Fig02-077.png"/>
              <figcaption>Fig 02-077</figcaption>
            </figure>
            <p>And then these functions don't mutate the index; they just return a new index, so I need to set the
              selectedHeadIndex to whatever's returned from these. And our linter is complaining because these lines are
              too long, so let's just wrap them, format them a little bit better:</p>
            <figure>
              <img src="images/Fig02-078.png"/>
              <figcaption>Fig 02-078</figcaption>
            </figure>
            <p>Okay, let's go check this out. So now as I increment, you can see that it is wrapping around, and we're
              not getting any errors and same for going to the previous heads:</p>
            <figure>
              <img src="images/Fig02-079.png"/>
              <figcaption>Fig 02-079</figcaption>
            </figure>
            <p>Awesome. So now we know how to bind to the click events. And, of course, we could bind to any event that
              is fired by any element. So we've updated the head, but we have not yet updated the other parts, so let's
              go fix those bindings.</p>
            <p>So if we go back up to our template, I'm basically going to need to copy these bindings:</p>
            <figure>
              <img src="images/Fig02-080.png"/>
              <figcaption>Fig 02-080</figcaption>
            </figure>
            <p>down to all the other buttons. So there's the previous binding and then the next binding. And then this
              will have to call, this is the left arm, so I'm going to call selectPreviousLeftArm and
              selectNextLeftArm:</p>
            <figure>
              <img src="images/Fig02-081.png"/>
              <figcaption>Fig 02-081</figcaption>
            </figure>
            <p>
              Okay, I'm going to go ahead and do the same thing for all of the rest of the parts, but I'm going to go
              ahead and do that off-screen because it's not too interesting to follow along.</p>
            <p>Okay, so you can see here that I've updated the bindings for selectPreviousTorso and NextTorso:</p>
            <figure>
              <img src="images/Fig02-082.png"/>
              <figcaption>Fig 02-082</figcaption>
            </figure>
            <p>
              RightArm:</p>
            <figure>
              <img src="images/Fig02-083.png"/>
              <figcaption>Fig 02-083</figcaption>
            </figure>
            <p>and Base:</p>
            <figure>
              <img src="images/Fig02-084.png"/>
              <figcaption>Fig 02-084</figcaption>
            </figure>
            <p>And then notice also that in the v-bind source bindings, I've updated the hardcoded 0 to the
              selectedBaseIndex, RightArmIndex, and TorsoIndex, and same thing for LeftArmIndex:</p>
            <figure>
              <img src="images/Fig02-085.png"/>
              <figcaption>Fig 02-085</figcaption>
            </figure>
            <p>And then you can see down here that I've initialized them all to 0 here in our data function:</p>
            <figure>
              <img src="images/Fig02-086.png"/>
              <figcaption>Fig 02-086</figcaption>
            </figure>
            <p>and then I've added methods for each one of them, selectNextHead and PreviousHead, LeftArm:</p>
            <figure>
              <img src="images/Fig02-087.png"/>
              <figcaption>Fig 02-087</figcaption>
            </figure>
            <p>Torso:</p>
            <figure>
              <img src="images/Fig02-088.png"/>
              <figcaption>Fig 02-088</figcaption>
            </figure>
            <p>RightArm, and Base:</p>
            <figure>
              <img src="images/Fig02-089.png"/>
              <figcaption>Fig 02-089</figcaption>
            </figure>
            <p>So if you're following along, go ahead and copy and paste all those and update them appropriately. Okay,
              so let's go check this out. So now we can move to the next and previous head, and left arm, torso, right
              arm, and base:</p>
            <figure>
              <img src="images/Fig02-090.png"/>
              <figcaption>Fig 02-090</figcaption>
            </figure>
            <p>Awesome. We have a functioning robot builder. In the next clip, we'll take a look at an abbreviated
              syntax for these v-bind and v-on bindings:</p>
            <figure>
              <img src="images/Fig02-091.png"/>
              <figcaption>Fig 02-091</figcaption>
            </figure>
          </div>
          <div><h3>Using Shorthand Bindings</h3>
            <p>We just created all of these bindings in our RobotBuilder HTML, and I just wanted to take a second to
              call out a more abbreviated syntax that's really nice. Anywhere we use this v-bind syntax, we can replace
              it with just a colon, so this is a shorthand syntax for v-bind. And then anywhere we use v-on, we can
              replace that with an at sign:</p>
            <figure>
              <img src="images/Fig02-092.png"/>
              <figcaption>Fig 02-092</figcaption>
            </figure>
            <p>so no colon here. I really like this syntax because it's very non-obtrusive, but it's also really clear
              that we're creating bindings. So let's replace all of these with a search and replace. So I'm going to
              search for v-bind and replace it with just colon, so I'm replacing v-bind: with just a colon. And I'll
              just replace all of those. And then I'm going to search for v-on: and replace it with just an @ sign.
              Let's replace all of those. And our RobotBuilder should still be working. Let's check it out. There we go.
              We can still see our image are, bindings are working, and our button bindings are all working.</p>
            <p>So from here on out in the course, we'll be using this abbreviated binding syntax. Next, let's take a
              look at how we can create and bind to computed properties.
            </p>
          </div>
          <div><h3>Binding to Computed Properties</h3>
            <p>Sometimes you want to be able to easily bind to something in your HTML template that involves a complex
              calculation. Doing complex calculations in your HTML template isn't really a great idea. We can solve that
              and move the complexity into the component with computed properties. All of these expressions are a little
              ugly:</p>
            <figure>
              <img src="images/Fig02-093.png"/>
              <figcaption>Fig 02-093</figcaption>
            </figure>
            <p>What would be nice is if we had a selected robot property on our component that we can use. So if we come
              down to our component, we can add a computed property here:</p>
            <figure>
              <img src="images/Fig02-094.png"/>
              <figcaption>Fig 02-094</figcaption>
            </figure>
            <p>And like the methods property, this contains methods. So I'm going to add a selectedRobot function, and
              this will return an object that represents our selected robot. And then that object will have a property
              for each part like this:</p>
            <figure>
              <img src="images/Fig02-095.png"/>
              <figcaption>Fig 02-095</figcaption>
            </figure>
            <p>So there's the left arm, and then we'll do the torso, and then the right arm, and finally the bases. So
              now selectedRobot. head will return the currently selected head and so forth. So now up here:</p>
            <figure>
              <img src="images/Fig02-096.png"/>
              <figcaption>Fig 02-096</figcaption>
            </figure>
            <p>instead of these expressions, we can just replace these with selectedRobot.head.src:</p>
            <figure>
              <img src="images/Fig02-097.png"/>
              <figcaption>Fig 02-097</figcaption>
            </figure>
            <p>So let's copy this down to each one of these img tags. So there's the leftArm, and then here is the
              torso, and now the rightArm, and finally the base.</p>
            <p>Okay, so that should be working great. So if we come over to our robot builder, now we can still use our
              robot builder, but our code is a lot more simple in our template where we don't have this complex
              expression, but we are just binding to the head of the selected robot.</p>
            <p>So this is better, and while this one just helps simplify our template a little bit, there are cases
              where it can simplify them a lot. You really want to be careful not to do too much logic in your
              templates, and computed properties make that easy.
            </p>
          </div>
          <div><h3>Displaying Data with Interpolation</h3>
            <p>Our robot builder is looking pretty good, and we've learned how to bind to attributes and events, but we
              haven't yet learned how to simply just display raw data on the page. We do that with interpolation. To
              demonstrate that, let's display the name of our robot just above the robot head.</p>
            <p>If we take a look at the parts data over here, you can see that each part has a title:</p>
            <figure>
              <img src="images/Fig02-098.png"/>
              <figcaption>Fig 02-098</figcaption>
            </figure>
            <p>And the names of the heads actually make for a pretty good name for our robots. So let's display the name
              of the currently selected head above our robot. Because of our computed property, this is going to be
              really easy. So let's add a new div right here:</p>
            <figure>
              <img src="images/Fig02-099.png"/>
              <figcaption>Fig 02-099</figcaption>
            </figure>
            <p>and we'll give it a class of robot-name. And let's add that class down here in our styles:</p>
            <figure>
              <img src="images/Fig02-100.png"/>
              <figcaption>Fig 02-100</figcaption>
            </figure>
            <p>And I'm going to position this absolute. And I want to position it about 25 pixels above the top of the
              head, and then we'll align the text to the center, and then we'll set the width to 100%.</p>
            <p>Okay, now for the interpolation part. Back up here inside our div, we're just going to add an expression
              like this:</p>
            <figure>
              <img src="images/Fig02-101.png"/>
              <figcaption>Fig 02-101</figcaption>
            </figure>
            <p>So the double brackets is used for interpolation, and inside there, we'll just put an expression. So we
              just want to use selectedRobot.head.title:</p>
            <figure>
              <img src="images/Fig02-102.png"/>
              <figcaption>Fig 02-102</figcaption>
            </figure>
            <p>And this is it. That's all there is to interpolation, and you can put any valid expression in here.
              Although, again, it's recommended that you only use simple expressions in your template. Okay, let's go
              check this out:</p>
            <figure>
              <img src="images/Fig02-103.png"/>
              <figcaption>Fig 02-103</figcaption>
            </figure>
            <p>All right, awesome, you can see here that our robot has a name, and then you can see, as I click through
              the robot heads, that the robot name up here is changing due to that interpolation expression:</p>
            <figure>
              <img src="images/Fig02-104.png"/>
              <figcaption>Fig 02-104</figcaption>
            </figure>
            <p>So interpolation is really simple. Before we wrap up on interpolation though, let me mention one more
              performance option. We can add a v-once tag to any element like this:</p>
            <figure>
              <img src="images/Fig02-105.png"/>
              <figcaption>Fig 02-105</figcaption>
            </figure>
            <p>and when you do this, any bindings inside that element will be evaluated once and then never again. This
              is handy for performance reasons if you have a page with a lot of bindings that are going to render once
              and then you don't expect the data to change. In our case though, this isn't what we want.</p>
            <p>If I come over now to our robot builder and cycle through the robot heads, you can see that the binding
              isn't updated:</p>
            <figure>
              <img src="images/Fig02-106.png"/>
              <figcaption>Fig 02-106</figcaption>
            </figure>
            <p>It updated once when the page was rendered, and then it's not being updated anymore. So we don't want
              that here, so let's remove it. But it's good to know about for performance reasons. Now that should be
              updating again.</p>
            <p>Okay, cool. So next, we're going to take a look at ways to dynamically show and hide our content on our
              page.
            </p>
          </div>
          <div><h3>Conditionally Displaying Content with v-if and v-show</h3>
            <p>
              Vue supplies two directives that we can use to conditionally show or hide content, v-if and v-show. Let's
              check them both out and talk about when to use each one.</p>
            <p>To demonstrate this, let's add an indicator next to this title right here:</p>
            <figure>
              <img src="images/Fig02-107.png"/>
              <figcaption>Fig 02-107</figcaption>
            </figure>
            <p>that indicates whether the robot is on sale. If we look at our parts data again, you can see that some of
              the parts have an onSale attribute:</p>
            <figure>
              <img src="images/Fig02-108.png"/>
              <figcaption>Fig 02-108</figcaption>
            </figure>
            <p>So we'll bind to the onSale property for the heads, and if the head shows that it's onSale, we'll
              indicate that the robot is on sale.</p>
            <p>So back in our RobotBuilder, right here next to the interpolation expression that's showing the title,
              we'll add a span with a class of sale:</p>
            <figure>
              <img src="images/Fig02-109.png"/>
              <figcaption>Fig 02-109</figcaption>
            </figure>
            <p>And then we'll just add the text Sale! inside here. Okay, let's go add that class to our CSS down
              here.</p>
            <figure>
              <img src="images/Fig02-110.png"/>
              <figcaption>Fig 02-110</figcaption>
            </figure>
            <p>
              Okay, so if we go look at this right now, it appears that all of the heads are on sale, but that is not
              accurate. There is actually only one head that's on sale, and it's our Friendly Bot, so let's use v-if to
              only show this sale span if the head is on sale.</p>
            <p>So right here I'm going to add a v-if binding:</p>
            <figure>
              <img src="images/Fig02-111.png"/>
              <figcaption>Fig 02-111</figcaption>
            </figure>
            <p>and then the expression inside of the v-if just needs to be a Boolean. If the expression evaluates to
              true, the element is shown, so we'll just put selectedRobot.head.onSale:</p>
            <figure>
              <img src="images/Fig02-112.png"/>
              <figcaption>Fig 02-112</figcaption>
            </figure>
            <p>Okay, so now if this onSale element exists on the head and it's set to true, then this span element will
              be displayed. Otherwise, it will not be displayed. So let's check that out. Okay, cool, that's working
              better. Now only our Friendly Bot appears to be on sale:</p>
            <figure>
              <img src="images/Fig02-113.png"/>
              <figcaption>Fig 02-113</figcaption>
            </figure>
            <p>which is correct. Okay, so that's v-if. Now let's check out v-show. It's actually works identically. So I
              could change v-if to v-show, and then if we go look at this, it's still working just the same. So you
              might wonder, well, what's the point? Well, the difference is what's happening behind the scenes.</p>
            <p>If we take a look at this element, we'll inspect it here, and then let's navigate to one that is not on
              sale. Okay, you can see that the element is actually still here:</p>
            <figure>
              <img src="images/Fig02-114.png"/>
              <figcaption>Fig 02-114</figcaption>
            </figure>
            <p>but it has an inline style now that says display: none. And so that is how Vue is showing and hiding this
              element when we're using v-show. It does so by adding style=display: none.</p>
            <p>However, if we change this to v-if again, and then look at this again, you can see that actually the
              element isn't even here:</p>
            <figure>
              <img src="images/Fig02-115.png"/>
              <figcaption>Fig 02-115</figcaption>
            </figure>
            <p>It's been removed completely from the DOM. And as I move through this, if I hit the one that is on sale,
              then the element shows up again:</p>
            <figure>
              <img src="images/Fig02-116.png"/>
              <figcaption>Fig 02-116</figcaption>
            </figure>
            <p>And so v-if actually adds and removes elements from the DOM, whereas v-show leaves the elements there and
              just styles them differently.</p>
            <p>So the question is, when should we use v-if, and when should we use v-show? Basically, if the content
              that you are showing and hiding is expensive to generate, and it's going to be shown and hidden
              frequently, then you should use v-show because Vue won't have to go through the expensive rendering
              process each time it's redisplayed.</p>
            <p>But if your content is not expensive to render like our current example, or if it's not going to be
              hidden and redisplayed frequently, then v-if is perfect.</p>
            <p>
              Right now we're just showing and hiding a span element, but imagine if this was a Vue component that we
              were showing and hiding, and imagine that that component had a child component which also had child
              components. You can see how that can get really expensive to rerender. In that case, v-show would be
              better. In our case, v-if is perfect because it's just a span; it's not expensive to render at all, so
              we'll leave it with a v-if.</p>
            <p>Next, let's take a look at how to repeat elements using v-for.
            </p>
          </div>
          <div><h3>Repeating Elements with v-for</h3>
            <p>Let's take a look now at how to repeat an element based on repeating data such as an array. A great use
              case for that would be a shopping cart which would list all of the robots that we've added to our cart.
              But before we can really have a functional cart page, we need to still learn about routing and state
              management. So for now, let's just add a cart section to this page, and later we can move it to its own
              cart page. That way, we can add multiple robots to our cart and then see how to use the v-for directive in
              order to list them all on the page.</p>
            <p>Let's start by adding an add-to-cart button. So we'll just put this here at the top. We're actually going
              to absolute position it. So I'm going to add a button here, and the class for this button is going to be
              add-to-cart. And we'll add a click binding, which will call an addToCart function:</p>
            <figure>
              <img src="images/Fig02-117.png"/>
              <figcaption>Fig 02-117</figcaption>
            </figure>
            <p>All right, and we'll just have this button say Add to Cart. Okay, and since we're going to absolute
              position this button, we need to have a class on that's container div that's positioned relative. So we'll
              add a class, and this will just be content:</p>
            <figure>
              <img src="images/Fig02-118.png"/>
              <figcaption>Fig 02-118</figcaption>
            </figure>
            <p>It's the content of this component. And then down here in our styles, we will add a content class:</p>
            <figure>
              <img src="images/Fig02-119.png"/>
              <figcaption>Fig 02-119</figcaption>
            </figure>
            <p>and set it to position: relative. And then we're going to add our add-to-cart class, and we will position
              that, absolute, 30 pixels from the right with a width of 220 pixels and a little bit of padding, and we'll
              set the font size to 16 pixels.</p>
            <p>Okay, so our button is going to call an addToCart method that we need to add still, so down here in
              methods we will add an addToCart function:</p>
            <figure>
              <img src="images/Fig02-120.png"/>
              <figcaption>Fig 02-120</figcaption>
            </figure>
            <p>Okay, and then when we add a robot to the cart, we will be basically adding it to an array. But a cart
              needs to know the cost. So let's calculate the cost and add that to the robot.</p>
            <p>So each of the parts already has cost data associated with it, so we'll calculate the cost like this.
              We'll create a new variable, cost, and set that to the sum of the cost of all the parts, so let's create a
              variable up here for the robot so we don't have to keep saying this.selectedRobot. And then here we will
              set the cost to robot.head.cost + robot.leftArm.cost + torso.cost + rightArm.cost, and finally, plus the
              base.cost:</p>
            <figure>
              <img src="images/Fig02-121.png"/>
              <figcaption>Fig 02-121</figcaption>
            </figure>
            <p>Okay, so we now have a cost variable that represents the cost of our robot. Now we can add it to our
              cart. So up here in our data function, let's add a cart property, and we'll default it to an empty
              array:</p>
            <figure>
              <img src="images/Fig02-122.png"/>
              <figcaption>Fig 02-122</figcaption>
            </figure>
            <p>
              And it's important that we initialize this variable here in the data function. If we don't do it here, Vue
              won't notice that the data is changing. Vue's change detection works by hooking into the getters and
              setters of properties in the data function.</p>
            <p>And so even if we were to add a cart variable below by saying this.cart=newArray, Vue wouldn't even
              notice it because it never hooked into it. And so any data that you are going to want to bind to that's
              going to change, that you need to make sure to initialize it in the data function. Otherwise, Vue won't be
              able to notice when it's changing.</p>
            <p>So we've initialized that up there, and now down here we can just push our robot onto that array. So
              we'll say this.cart.push:</p>
            <figure>
              <img src="images/Fig02-123.png"/>
              <figcaption>Fig 02-123</figcaption>
            </figure>
            <p>and then just for immutability purposes, I want to use Object.assign here so that the robot that is in
              the array isn't the same instance as the selected robot property. This isn't really a Vue thing; this is
              more of a good programming practice in JavaScript to make sure that you don't have inadvertent pointers to
              the same object in your code. So I'm just going to do an Object.assign and start with an empty object and
              assign robot, and then I'll assign the cost:</p>
            <figure>
              <img src="images/Fig02-124.png"/>
              <figcaption>Fig 02-124</figcaption>
            </figure>
            <p>So the result here is that we will have our robot object plus the cost property on that robot, and then
              we're pushing that onto the cart.</p>
            <p>Okay, so if we go look at our page, we now have an Add to Cart button:</p>
            <figure>
              <img src="images/Fig02-125.png"/>
              <figcaption>Fig 02-125</figcaption>
            </figure>
            <p>and when we click it, it will calculate the cost of the robot and add that robot with its cost to an
              array. But of course, clicking that does nothing right now because we're not displaying anything.
              Actually, it is doing some behind the scenes; we just can't see that it is. So let's go display the
              contents of our cart.</p>
            <p>For that, we'll need v-for. So back up in our template here at the bottom, let's create a new div, and
              that's just going to have a header in here that says Cart. And then also inside this div we'll create a
              table:</p>
            <figure>
              <img src="images/Fig02-126.png"/>
              <figcaption>Fig 02-126</figcaption>
            </figure>
            <p>So this table will display the contents of our cart, so we'll have a table header with a single row and
              just two columns, one that is the name of the robot and another one will have a class on this one for the
              cost so that we can align it to the right:</p>
            <figure>
              <img src="images/Fig02-127.png"/>
              <figcaption>Fig 02-127</figcaption>
            </figure>
            <p>Okay, so there's our header row, and then we're going to have a tbody, and then we'll have a table row
              here:</p>
            <figure>
              <img src="images/Fig02-128.png"/>
              <figcaption>Fig 02-128</figcaption>
            </figure>
            <p>And this is where we want to start repeating data. So basically, we want a new table row here for every
              robot in our cart. So we can do that with v-for. Okay, so now we have the v-for directive. And the binding
              here is an interesting type of binding that is specific to v-for. We're going to add a binding like
              this:</p>
            <figure>
              <img src="images/Fig02-129.png"/>
              <figcaption>Fig 02-129</figcaption>
            </figure>
            <p>
              So this is basically saying, for each robot in the cart, and then robot is actually a variable that we can
              use within this element. So we'll get a new table row element for each robot in the cart, and the down
              here inside the table row we can create a table data element, and we can say robot.head.title:</p>
            <figure>
              <img src="images/Fig02-130.png"/>
              <figcaption>Fig 02-130</figcaption>
            </figure>
            <p>So this robot here is the same robot here, and then we'll add another table data for the cost, and then
              will also have class equal to cost, and then that will bind to robot.cost:</p>
            <figure>
              <img src="images/Fig02-131.png"/>
              <figcaption>Fig 02-131</figcaption>
            </figure>
            <p>Okay, so for each robot, it's going to create a new table row element with all of this content inside of
              each table row element and the bindings specific to each robot. There's just one caveat here. Whenever
              you're repeating data, Vue needs to be able to, for performance reasons, identify each element in there
              for updates. And so we need to add a unique key attribute to our repeated table row element:</p>
            <figure>
              <img src="images/Fig02-132.png"/>
              <figcaption>Fig 02-132</figcaption>
            </figure>
            <p>So we can do that like this. We'll just set a key attribute equal to an expression. But what unique value
              can we provide here for the key? The value needs to be unique for each repeated element. So to make that
              easy, we can just access the zero-based index of each of the items like this:</p>
            <figure>
              <img src="images/Fig02-133.png"/>
              <figcaption>Fig 02-133</figcaption>
            </figure>
            <p>Up in our v-for expression, instead of just grabbing robot, we also grab an index. So this is a
              zero-based index for each item in the array. And now I can, on the key here, I can set the key to
              index:</p>
            <figure>
              <img src="images/Fig02-134.png"/>
              <figcaption>Fig 02-134</figcaption>
            </figure>
            <p>
              And actually, this key attribute, right now as it is, we're just setting it to the string index. We're not
              binding, and so we need to add a binding:</p>
            <figure>
              <img src="images/Fig02-135.png"/>
              <figcaption>Fig 02-135</figcaption>
            </figure>
            <p>So this is a v-bind binding, binding key to the index expression. Okay, so this v-for should work
              perfectly now. And for each robot in the cart, we will get a new row. We just need some styles for this,
              so let's come down here to the bottom, and we're going to add some styles around table data and table
              header and we just want to, by default, text-align: left and have some padding and a little extra padding
              on the right:</p>
            <figure>
              <img src="images/Fig02-136.png"/>
              <figcaption>Fig 02-136</figcaption>
            </figure>
            <p>And then we need our cost class, and we're going to text-align it to the right:</p>
            <figure>
              <img src="images/Fig02-137.png"/>
              <figcaption>Fig 02-137</figcaption>
            </figure>
            <p>Okay, let's go take a look at this. Okay, so here we have our robot, we have our Add to Cart button up
              here, and down here we have our cart:</p>
            <figure>
              <img src="images/Fig02-138.png"/>
              <figcaption>Fig 02-138</figcaption>
            </figure>
            <p>So I'm going to go ahead and add this robot to the cart, and we now have a Large Cyclops in our cart, and
              then let's also add a Small Cyclops, and we'll change some of the parts on this, and then add that to the
              cart. Okay, so now you can see we have a Large Cyclops and a Small Cyclops, each with a different
              cost:</p>
            <figure>
              <img src="images/Fig02-139.png"/>
              <figcaption>Fig 02-139</figcaption>
            </figure>
            <p>So our v-for directive is working, and it's repeating over each robot that we've added to our cart
              array.</p>
            <p>
              Okay, one last thing I want to mention is a performance warning that you should never use v-if and v-for
              on the same element. So up here on our v-for, right here, I should not ever do a v-if here also:</p>
            <figure>
              <img src="images/Fig02-140.png"/>
              <figcaption>Fig 02-140</figcaption>
            </figure>
            <p>If you need to hide and show data on the same element that's using v-for, you need to use some other
              mechanism such as using an internal element or something like that so that it's not on the same element as
              this v-for. This is just a performance warning that you'll see in the Vue docs, so it's just good to be
              aware of that.</p>
            <p>All right, next, we'll take a look at a number of considerations around styling our components.
            </p>
          </div>
          <div><h3>Styling Components</h3>
            <p>By now, you've probably gotten used to the idea that we can style our components down here in the style
              section:</p>
            <figure>
              <img src="images/Fig02-141.png"/>
              <figcaption>Fig 02-141</figcaption>
            </figure>
            <p>Although we haven't talked about this directly, as we've proceeded this far in the course, we've been
              adding to these styles, and you've seen how it immediately affects the component. But we haven't really
              explored what's actually happening here or how far-reaching these styles are. To explore this a little
              more, let's jump over to our App component. Notice in the styles of our App component that we're styling
              things like this main tag and the header tag:</p>
            <figure>
              <img src="images/Fig02-142.png"/>
              <figcaption>Fig 02-142</figcaption>
            </figure>
            <p>and you can see those main and header tags up here in our template. But what about this body tag:</p>
            <figure>
              <img src="images/Fig02-143.png"/>
              <figcaption>Fig 02-143</figcaption>
            </figure>
            <p>That main tag does not show up at all up here in our template. And yet, if we look at our app, the
              gradient that we're adding to he body tag is showing up here in the background of our app:</p>
            <figure>
              <img src="images/Fig02-144.png"/>
              <figcaption>Fig 02-144</figcaption>
            </figure>
            <p>So how is it that the body style that we're adding here is getting applied to a body tag that's not part
              of this component? The body tag is actually part of this index.html file that was generated by the CLI. So
              notice we have a body tag here:</p>
            <figure>
              <img src="images/Fig02-145.png"/>
              <figcaption>Fig 02-145</figcaption>
            </figure>
            <p>So this index.html file is what is actually loaded when our app first loads, and it has a body tag. And
              then you can see down here on line 14 that we have this app element:</p>
            <figure>
              <img src="images/Fig02-146.png"/>
              <figcaption>Fig 02-146</figcaption>
            </figure>
            <p>and this is what the render function is binding to, and so this is where the rest of our app is
              displayed. But it's concerning that we have a style in our app.vue component that is styling something
              outside of that component. But not to worry, there's an easy solution to this.</p>
            <p>Back here in our App component, on the style tag right here, we can add a scoped attribute:</p>
            <figure>
              <img src="images/Fig02-147.png"/>
              <figcaption>Fig 02-147</figcaption>
            </figure>
            <p>And if we go back now to our page, you can see we've lost our gradient:</p>
            <figure>
              <img src="images/Fig02-148.png"/>
              <figcaption>Fig 02-148</figcaption>
            </figure>
            <p>So we just essentially scoped all of the styles inside this style element to only this App component.
              That's pretty awesome, but how does Vue accomplish it?</p>
            <p>Let's take a look at the source of our page in the browser. So I'm going to inspect this:</p>
            <figure>
              <img src="images/Fig02-149.png"/>
              <figcaption>Fig 02-149</figcaption>
            </figure>
            <p>and then notice on this header element that it has a data attribute with a hash after it. And if I go
              back over here and remove this scoped attribute:</p>
            <figure>
              <img src="images/Fig02-150.png"/>
              <figcaption>Fig 02-150</figcaption>
            </figure>
            <p>and then refresh, notice that the randomized hash has disappeared:</p>
            <figure>
              <img src="images/Fig02-151.png"/>
              <figcaption>Fig 02-151</figcaption>
            </figure>
            <p>So first of all, the scoped attribute is adding those data attributes. So if we putthe scoped attribute
              back, and then take note of the header styles that are being applied here:</p>
            <figure>
              <img src="images/Fig02-152.png"/>
              <figcaption>Fig 02-152</figcaption>
            </figure>
            <p>the background-color, the width, and the margin. Now if we go look at the source again and refresh, take
              a look over here in the inspector that is showing the styles for header:</p>
            <figure>
              <img src="images/Fig02-153.png"/>
              <figcaption>Fig 02-153</figcaption>
            </figure>
            <p>Notice that it's not just being applied to any header element; it's actually only being applied to header
              elements with this data attribute. So that's how Vue handles scoping styles. It puts these randomized
              hashes on scoped elements and then targets them specifically with that hash. So a header element on
              another component would either not have this data attribute at all, or it would have a different data
              attribute because it's in a different scope.</p>
            <p>And the same concept applies to child components, as we'll see in the next clip. With some exceptions, if
              you add the scoped element to a parent component, its styles won't bleed into the child component. We'll
              take a closer look at this in a minute. But first, let's talk a bit about scoped versus global styles
              .</p>
            <p>As a general rule, you should not have global styles in any component other than your top-level app
              component. So let's go fix our RobotBuilder so that it has scoped styles.</p>
            <p>So over here in the style element, we'll add the scoped attribute:</p>
            <figure>
              <img src="images/Fig02-154.png"/>
              <figcaption>Fig 02-154</figcaption>
            </figure>
            <p>and so now we don't have global styles in our RobotBuilder. But the App component is a good place to have
              some global styles, so let's do that. And the interesting thing is that in our App component, we want some
              global styles, but we also want some styles that apply only to the App component. But that's okay; you can
              do that. You can have multiple style blocks, and one can be scoped and the other not:</p>
            <figure>
              <img src="images/Fig02-155.png"/>
              <figcaption>Fig 02-155</figcaption>
            </figure>
            <p>So now we have a global style block here and a scoped style block down here. And let's move this body
              style up here to our global style:</p>
            <figure>
              <img src="images/Fig02-156.png"/>
              <figcaption>Fig 02-156</figcaption>
            </figure>
            <p>And the rest of these styles are specific to the App component, and so we want to leave those in the
              scoped style block.</p>
            <p>So now if we go back and refresh, and let's close our console, you can see that we have our gradient
              background again:</p>
            <figure>
              <img src="images/Fig02-157.png"/>
              <figcaption>Fig 02-157</figcaption>
            </figure>
            <p>And so the body style is being applied globally, whereas the rest of these are only being applied to this
              component. Okay, cool. So now we'll take a look at how this all affects child components.
            </p>
          </div>
          <div><h3>Styling Child Components</h3>
            <p>
              It's important to understand what it means when you add the scoped attribute to a parent component and how
              that affects child components. Right now, our RobotBuilder is a child component of our App component, and
              if we take a look at our RobotBuilder, you can see right here we have this robot-name class:</p>
            <figure>
              <img src="images/Fig02-158.png"/>
              <figcaption>Fig 02-158</figcaption>
            </figure>
            <p>Let's add an element in our App component with that same class. So right here just above our
              RobotBuilder, we're going to create a div element with a class of robot-name:</p>
            <figure>
              <img src="images/Fig02-159.png"/>
              <figcaption>Fig 02-159</figcaption>
            </figure>
            <p>which happens to match the robot name class inside our RobotBuilder.</p>
            <p>And then down here in the scoped style, we will add that robot-name class with color: red:</p>
            <figure>
              <img src="images/Fig02-160.png"/>
              <figcaption>Fig 02-160</figcaption>
            </figure>
            <p>Okay, so if we go take a look at this:</p>
            <figure>
              <img src="images/Fig02-161.png"/>
              <figcaption>Fig 02-161</figcaption>
            </figure>
            <p>you can see that the robot-name styles got applied to the element in the App component but not to the
              element with the matching class name in the child component. So this is what we would expect; it is scoped
              to our parent component.</p>
            <p>But I want to point out something. Watch what happens if I come up here and wrap this div around the
              RobotBuilder:</p>
            <figure>
              <img src="images/Fig02-162.png"/>
              <figcaption>Fig 02-162</figcaption>
            </figure>
            <p>So now this div is wrapping the RobotBuilder. So let's see if that changed anything:</p>
            <figure>
              <img src="images/Fig02-163.png"/>
              <figcaption>Fig 02-163</figcaption>
            </figure>
            <p>Ah, now you can see that both the parent component and the child component got styled. So it appears that
              the parent component's styles are bleeding into the child component. And this is sort of true, but not
              really. At least, it's not true as far as Vue is concerned. Let's see what happens if we also add a border
              to this style. So down here, I'm going to also add border, and we'll add a 2px solid blue border:</p>
            <figure>
              <img src="images/Fig02-164.png"/>
              <figcaption>Fig 02-164</figcaption>
            </figure>
            <p>So now if we come back over here, notice that we do have a border that is wrapping the div in the App
              component:</p>
            <figure>
              <img src="images/Fig02-165.png"/>
              <figcaption>Fig 02-165</figcaption>
            </figure>
            <p>and that div stretches across this because the RobotBuilder is wrapped by this div. But the interesting
              thing is that even though the border is being applied to the robot-name class, it is not bleeding down
              into the child component's robot-name class. Otherwise, we would see a border around this robot title
              here:</p>
            <figure>
              <img src="images/Fig02-166.png"/>
              <figcaption>Fig 02-166</figcaption>
            </figure>
            <p>So it seems that the font color is bleeding into the child component, but the border is not. So when Vue
              says that its styles are scoped, what it means is that it's not going to apply that style directly to
              classes or elements outside of the scope, but that doesn't mean that the child elements won't be affected
              due to CSS inheritance. That's just the nature of CSS.</p>
            <p>In CSS, there are a number of CSS properties that get inherited. Font color, for example, is inherited,
              whereas border is not. That's why you see a difference here.</p>
            <p>So know that when you style something in a parent component that wraps a child component, traditional CSS
              inheritance will still be at play. But Vue won't specifically target elements outside of the component if
              the style is scoped. So it's important to understand that difference between Vue targeting an element or
              applying classes to an element in a child, versus styles just getting inherited because they are applied
              to a parent element by CSS.</p>
            <p>But what if you do want to be able to style a child component from the parent? Vue does allow a parent to
              style a child component within the bounds of scoped CSS, so let's take a look at how to do that. The
              easiest way to think about this is to consider the root element of a child component part of the parent's
              scope.</p>
            <p>So over here in our RobotBuilder:</p>
            <figure>
              <img src="images/Fig02-167.png"/>
              <figcaption>Fig 02-167</figcaption>
            </figure>
            <p>this element is the root component, or the root element of our RobotBuilder. And notice that it has a
              content class. So if we go to its parent component, the App component, and let's remove this test div:</p>
            <figure>
              <img src="images/Fig02-168.png"/>
              <figcaption>Fig 02-168</figcaption>
            </figure>
            <p>we don't need this anymore:</p>
            <figure>
              <img src="images/Fig02-169.png"/>
              <figcaption>Fig 02-169</figcaption>
            </figure>
            <p>And now down here, instead of robot-name here, let's change this to just content:</p>
            <figure>
              <img src="images/Fig02-170.png"/>
              <figcaption>Fig 02-170</figcaption>
            </figure>
            <p>So now we are applying these styles to the content class. And there is no content class in our App
              component; it's only in our RobotBuilder. So let's go back over here, and there, now you can see that the
              red text and blue border are being applied to the content class in our child component:</p>
            <figure>
              <img src="images/Fig02-171.png"/>
              <figcaption>Fig 02-171</figcaption>
            </figure>
            <p>This is only because that content class is on the root component of the child:</p>
            <figure>
              <img src="images/Fig02-172.png"/>
              <figcaption>Fig 02-172</figcaption>
            </figure>
            <p>and so you can use the root component of a child component to allow a parent to apply styles to the child
              component. But what if we want to access this robot-name:</p>
            <figure>
              <img src="images/Fig02-173.png"/>
              <figcaption>Fig 02-173</figcaption>
            </figure>
            <p>from our parent and style it? So over in our App.vue, we could add .content .robot-name:</p>
            <figure>
              <img src="images/Fig02-174.png"/>
              <figcaption>Fig 02-174</figcaption>
            </figure>
            <p>So generally, you can target things in CSS like this where you can target a robot-name class that's
              contained within the content class. And since we're able to target the content class from the parent, the
              question is, are we able to target elements inside of that content class? So we would expect to now to see
              a blue border and red text around the robot name. So if we come take a look at this, yeah, you can see
              that our style's not getting applied anywhere:</p>
            <figure>
              <img src="images/Fig02-175.png"/>
              <figcaption>Fig 02-175</figcaption>
            </figure>
            <p>If you want to be able to do deep targeting like this, you need to use the deep selector that looks like
              this:</p>
            <figure>
              <img src="images/Fig02-176.png"/>
              <figcaption>Fig 02-176</figcaption>
            </figure>
            <p>And now if we take a look at it, there, now you can see that we can target it:</p>
            <figure>
              <img src="images/Fig02-177.png"/>
              <figcaption>Fig 02-177</figcaption>
            </figure>
            <p>So you can target child elements within scoped styles like this by starting with the class of the root
              element and then using the deep selector to select other items within the child component. But you need to
              be aware that this deep component is truly deep. It is not just the child component, but this will also
              affect child components of your child component, so it will keep going down the chain. And it's possible
              that this won't work with some CSS preprocessors, and so in that case, there is also the deep
              selector:</p>
            <figure>
              <img src="images/Fig02-178.png"/>
              <figcaption>Fig 02-178</figcaption>
            </figure>
            <p>
              and that has the same effect. Okay, we don't want to keep this here:</p>
            <figure>
              <img src="images/Fig02-179.png"/>
              <figcaption>Fig 02-179</figcaption>
            </figure>
            <p>so let's delete that. That covers everything for styling child components. Next, let's take a look at
              conditionally applying styles to elements.
            </p>
          </div>
          <div><h3>Conditionally Applying Styles with Style Bindings</h3>
            <p>
              Sometimes we want to apply a style to an element based upon a certain condition. That's quite easy to do
              with Vue. Let's use a style binding to make it so that the border around the head turns red if it's on
              sale.</p>
            <p>So over here in our template, we're going to style this div right here:</p>
            <figure>
              <img src="images/Fig02-180.png"/>
              <figcaption>Fig 02-180</figcaption>
            </figure>
            <p>It's the one that contains the head. So a style binding looks like this:</p>
            <figure>
              <img src="images/Fig02-181.png"/>
              <figcaption>Fig 02-181</figcaption>
            </figure>
            <p>And really, this is just binding to the style attribute. And you provide an object, and we're going to
              set the border to a 3px solid red border:</p>
            <figure>
              <img src="images/Fig02-182.png"/>
              <figcaption>Fig 02-182</figcaption>
            </figure>
            <p>And this should be working, if we go over here and take a look at it:</p>
            <figure>
              <img src="images/Fig02-183.png"/>
              <figcaption>Fig 02-183</figcaption>
            </figure>
            <p>However, it's not yet conditional. So every head has a red border, not just the ones that are on sale. So
              we'll get to conditional in just a second, but first I want to mention that there are some CSS attributes
              that have hyphens in them. For example, background-color. But this isn't valid JavaScript. For this to be
              valid JavaScript, you have to add brackets around this because this is object notation here:</p>
            <figure>
              <img src="images/Fig02-184.png"/>
              <figcaption>Fig 02-184</figcaption>
            </figure>
            <p>But Vue actually makes this easier by allowing you to use camel case for CSS attribute names that have
              hyphens in them:</p>
            <figure>
              <img src="images/Fig02-185.png"/>
              <figcaption>Fig 02-185</figcaption>
            </figure>
            <p>so just keep that in mind. We don't need this though, so we'll just change this back to border:</p>
            <figure>
              <img src="images/Fig02-186.png"/>
              <figcaption>Fig 02-186</figcaption>
            </figure>
            <p>So for this to be conditional, we need to not just have it be hardcoded to a string, so we can just
              change that to bind to a computer property on the component. So instead of this object here, we're just
              going to bind this to headBorderStyle:</p>
            <figure>
              <img src="images/Fig02-187.png"/>
              <figcaption>Fig 02-187</figcaption>
            </figure>
            <p>Now the style binding will be set to whatever object is returned by headBorderStyle. So let's go add a
              computed property for that:</p>
            <figure>
              <img src="images/Fig02-188.png"/>
              <figcaption>Fig 02-188</figcaption>
            </figure>
            <p>So that's a method, and it's just going to, for now we'll have it just return border, and we'll hardcode
              that again to 3px solid red:</p>
            <figure>
              <img src="images/Fig02-189.png"/>
              <figcaption>Fig 02-189</figcaption>
            </figure>
            <p>Okay, so this still isn't dynamic. We still are just getting a red border on everything:</p>
            <figure>
              <img src="images/Fig02-190.png"/>
              <figcaption>Fig 02-190</figcaption>
            </figure>
            <p>But now, because this is a computed property, we could just use a ternary here. So let's bring this down
              onto a separate line, and instead of always setting border to this string, we'll set it to a ternary
              statement. We'll say if this.selectedRobot.head is onSale, then return 3px solid red:</p>
            <figure>
              <img src="images/Fig02-191.png"/>
              <figcaption>Fig 02-191</figcaption>
            </figure>
            <p>Otherwise, return 3px solid gray. Okay, let's go check that out. Okay, it looks like this is working
              great now. So now only the items that's on sale has a red border:</p>
            <figure>
              <img src="images/Fig02-192.png"/>
              <figcaption>Fig 02-192</figcaption>
            </figure>
            <p>Okay, one last thing to be aware of is up here in our style binding, sometimes it's necessary to apply
              styles based on multiple calculations. In that case, we could add an array, or bind this to an array
              instead. And this could be a second calculated property so that it applies these styles, the
              headBorderStyle first, and then moreStyles second.</p>
            <figure>
              <img src="images/Fig02-193.png"/>
              <figcaption>Fig 02-193</figcaption>
            </figure>
            <p>And moreStyles will override headBorderStyle, so the second one overrides the first if there are any
              conflicts. We don't have a need for that, though, so we'll just go with the simple object syntax:</p>
            <figure>
              <img src="images/Fig02-194.png"/>
              <figcaption>Fig 02-194</figcaption>
            </figure>
            <p>Of course, it's better to use classes than inline styles, so now let's take a look at how to
              conditionally apply CSS classes.
            </p>
          </div>
          <div><h3>Conditionally Applying Classes with Class Bindings</h3>
            <p>Let's see how to replace this style binding with a class binding so that we can use classes instead of
              inline styles. First, let's start by adding a class down here. We'll call it sale-border, and that will
              just have a border that is 3px solid red:</p>
            <figure>
              <img src="images/Fig02-195.png"/>
              <figcaption>Fig 02-195</figcaption>
            </figure>
            <p>And then back up here where our style binding is, instead of this we'll use a class binding:</p>
            <figure>
              <img src="images/Fig02-196.png"/>
              <figcaption>Fig 02-196</figcaption>
            </figure>
            <p>And then a class binding is basically an object where the keys are the names of the classes that you
              would like to toggle. So in this case, we have a sale-border class. And then you just set that to a
              Boolean expression that will evaluate to true when you want this class to be applied. So in this case we
              want it to be applied when the selectedRobot.head is onSale:</p>
            <figure>
              <img src="images/Fig02-197.png"/>
              <figcaption>Fig 02-197</figcaption>
            </figure>
            <p>So this is just saying apply the sale-border class when the onSale property is true.</p>
            <figure>
              <img src="images/Fig02-198.png"/>
              <figcaption>Fig 02-198</figcaption>
            </figure>
            <p>And if we wanted to toggle multiple classes, we would just add more properties to this object. So this
              should be working just like the style binding was. So the Friendly Bot is on sale, and the rest are not on
              sale. Perfect.</p>
            <p>Now one thing that you might not have noticed, if we inspect this, this div where we applied the sale
              border, also has the classes top and part:</p>
            <figure>
              <img src="images/Fig02-199.png"/>
              <figcaption>Fig 02-199</figcaption>
            </figure>
            <p>If we go over and take a look at our template, you can see that this element has both a class binding and
              a class attribute on it:</p>
            <figure>
              <img src="images/Fig02-200.png"/>
              <figcaption>Fig 02-200</figcaption>
            </figure>
            <p>so the top and part classes are going to always be applied, and the sale-border property is going to be
              applied conditionally, so you can combine them like this. Of course, this class object could get fairly
              complex if you were toggling lots of classes. So you could always move this expression to a computed
              property like we did with the style binding.</p>

            <p>But like style bindings, there's another syntax that we could use here, an array syntax. So I could just
              provide an array here, and that array contains the classes that I would like to apply.</p>
            <figure>
              <img src="images/Fig02-201.png"/>
              <figcaption>Fig 02-201</figcaption>
            </figure>
            <p>So this is not conditional; this will always apply a class, so we should be seeing that everywhere:</p>
            <figure>
              <img src="images/Fig02-202.png"/>
              <figcaption>Fig 02-202</figcaption>
            </figure>
            <p>But we could then take this and, let's undo a little bit and grab this expression:</p>
            <figure>
              <img src="images/Fig02-203.png"/>
              <figcaption>Fig 02-203</figcaption>
            </figure>
            <p>and with this array syntax, let's put in a, let's use a computed property like we did with our style
              bindings. So I'm going to create a computed property called saleBorderClass:</p>
            <figure>
              <img src="images/Fig02-204.png"/>
              <figcaption>Fig 02-204</figcaption>
            </figure>
            <p>and we will add the value of that to our array. So now down in our computed properties, I can change this
              to saleBorderClass. And then this is just going to return the saleBorder string if the robot head is on
              sale, so we'll just use a ternary like this. So if it's on sale, then return sale-border. Otherwise it'll
              return an empty string:</p>
            <figure>
              <img src="images/Fig02-205.png"/>
              <figcaption>Fig 02-205</figcaption>
            </figure>
            <p>Okay, so that should be conditional again:</p>
            <figure>
              <img src="images/Fig02-206.png"/>
              <figcaption>Fig 02-206</figcaption>
            </figure>
            <p>There we go. And now that we have that using the array syntax, we could actually collapse these class
              expressions into a single expression. So I'm going to take these out of here:</p>
            <figure>
              <img src="images/Fig02-207.png"/>
              <figcaption>Fig 02-207</figcaption>
            </figure>
            <p>and make them strings in here. And then I can get rid of this class attribute:</p>
            <figure>
              <img src="images/Fig02-208.png"/>
              <figcaption>Fig 02-208</figcaption>
            </figure>

            <p>and now it's all taken care of in our class binding. Cool, I like that final syntax, so let's go with
              that.</p>
            <p>And next, we'll take a look at using CSS preprocessors like Sass.
            </p>
          </div>
          <div><h3>Using SASS and Other CSS Pre-processors</h3>
            <p>Vue. js fully supports using CSS preprocessors if, for example, you want to use something like Sass
              instead of plain old CSS. In fact, the zero-config web pack configuration that comes with the basic CLI
              includes all of the web pack config to support Sass, Less, and Stylus. All you have to do is npm install
              the appropriate loaders if you want to use them.</p>
            <p>So here in our terminal, I'm going to just type :</p>
            <figure>
              <pre><code class="language-command-line">npm install node-sass and sass-loader --save-dev</code></pre>
              <figcaption>Fig 02-209</figcaption>
            </figure>
            <p>
              Let's go ahead and install that. And since the built-in web pack config is already set up to handle the
              Sass loader, we can just jump in using that in our project. So all we have to do to support Sass is come
              down to the style section, and up here at the top where we define our style tag, all we need to do is
              specify the language used here, so I can say lang=scss:</p>
            <figure>
              <img src="images/Fig02-210.png"/>
              <figcaption>Fig 02-210</figcaption>
            </figure>
            <p>And now I can start using Sass syntax in here, so I could, for example, wrap this inside of the part
              class:</p>
            <figure>
              <img src="images/Fig02-211.png"/>
              <figcaption>Fig 02-211</figcaption>
            </figure>
            <p>and then if we come back over here and start our server again:</p>
            <figure>
              <pre><code class="language-command-line">npm run serve</code></pre>
              <figcaption>Fig 02-212</figcaption>
            </figure>
            <p>and then come back over to our browser and refresh:</p>
            <figure>
              <img src="images/Fig02-213.png"/>
              <figcaption>Fig 02-213.png</figcaption>
            </figure>
            <p>you can see that all our styles, so these images, are still the correct size, even though we added the
              Sass syntax for sizing them.</p>
            <p>So that was surprisingly easy, and you can see how the zero-config environment made that really simple.
              Of course, if you wanted to use a CSS preprocessor other than Sass, Less, or Stylus, you could do that,
              but you would have to go in and modify the webpack.config, and we'll talk about that in the deploying to
              production module. But out of the box, those three are already supported. And now our robot builder is
              using Sass.</p>
            <p>This wraps up our discussion of styling our components. We're going to next take a look at the different
              component lifecyle hooks that we can tap into.
            </p>
          </div>
          <div><h3>Using Component Lifecycle Hooks</h3>
            <p>
              There are several lifecycle hooks that we can tap into to take an action based on the various lifecycle
              states of a component. Let's take a look at the created lifecycle hook. A typical use case for lifecycle
              hooks is to fetch data from a API when a component is first created, but we're not ready to do that just
              yet. We'll implement that exact use case later in the module about state management when we start using an
              API.</p>
            <p>For now, let's just make it so that whenever this RobotBuilder component is created, we log something
              into the console. So all we need to do is add a created function like this. And then we can just console.
              log in here:</p>
            <figure>
              <img src="images/Fig02-214.png"/>
              <figcaption>Fig 02-214</figcaption>
            </figure>
            <p>And tapping into a lifecyle hook is that easy. Let's go check this out over in our browser. So let's open
              our console and clear it, and then I'm going to refresh this. And when this page loaded, the RobotBuilder
              component was created:</p>
            <figure>
              <img src="images/Fig02-215.png"/>
              <figcaption>Fig 02-215</figcaption>
            </figure>
            <p>And then you can see down here we got this component created message. And again, this isn't a great use
              case, obviously, but it's pretty common that you'll do things in here like fetch data from an API that's
              needed for this component.</p>
            <p>There are a handful of lifecycle hooks, but covering all of them is beyond the scope of this course. If
              you want to explore more about lifecyle hooks, you can check it out here in the Vue documentation:</p>
            <figure>
              <img src="images/Fig02-216.png"/>
              <figcaption>Fig 02-216</figcaption>
            </figure>
            <p>They provide this lifecyle diagram that shows all of the different lifecycle hooks, beforeCreate,
              created, beforeMount, mounted, beforeUpdate, updated, and beforeDestroy, and finally, destroyed. And it
              shows you in this diagram here where in the lifecycle of a component each of these hooks gets called.</p>
            <p>
              And again, we'll touch on this more later in the course. If you want to look at it right now, to explore
              lifecycle states further, you can check it out in the Passing Data to Parent Components clip, which is
              inside the Enabling Intercomponent Communication module, or you can also look at it in the State
              Management module when we start talking about making API calls.</p>
            <p>For now, let's move on and take a look at mixins.
            </p>
          </div>
          <div><h3>Reducing Duplication with Mixins</h3>
            <p>
              Mixins are a way to share functionality across multiple components. Basically, any component option can be
              extracted out into a mixin file, and then when you import the mixin, it will be merged into the rest of
              your component options.</p>
            <p>Let's see how to do that. Let's take this created lifecycle hook and move it into a mixin. So we'll grab
              it from here:</p>
            <figure>
              <img src="images/Fig02-217.png"/>
              <figcaption>Fig 02-217</figcaption>
            </figure>
            <p>and then let's create a new file called created-hook-mixin.js:</p>
            <figure>
              <img src="images/Fig02-218.png"/>
              <figcaption>Fig 02-218</figcaption>
            </figure>
            <p>And then here we'll just export an object:</p>
            <figure>
              <img src="images/Fig02-219.png"/>
              <figcaption>Fig 02-219</figcaption>
            </figure>
            <p>So basically, we're just export a component configuration object here, and whatever is in this object
              will be merged in with any components that you use it in.</p>
            <p>So to use it, let's go back into our RobotBuilder, and we're going to import our createdHookMixin from
              created-hook-mixin</p>
            <figure>
              <img src="images/Fig02-220.png"/>
              <figcaption>Fig 02-220</figcaption>
            </figure>
            <p> And then we're just going to use this down here in a mixin property, so mixins, and then this is just an
              array of mixins, and we're only going to have one, the createdHookMixin:</p>
            <figure>
              <img src="images/Fig02-221.png"/>
              <figcaption>Fig 02-221</figcaption>
            </figure>
            <p>Cool. Now this mixin can be used in multiple components. Right now, we're just going to be using it in
              this one. And if we come back over to our web app and open our console and refresh, you can see our
              component created messages still getting logged:</p>
            <figure>
              <img src="images/Fig02-222.png"/>
              <figcaption>Fig 02-222</figcaption>
            </figure>
            <p>And so our created hook is still working, but it is now extracted out into a mixin that could be reused.
              Again, our application isn't quite mature enough yet for a great example for mixins. If you want to see a
              better example of this, in the Managing State with Vuex module, we talk about it when we have a few
              components that all need the same data, so we'll create a mixin in order to share the logic that will be
              used to fetch that data across multiple components. You can find that in the clip on Using Actions to Work
              with APIs and Asynchronous Data.</p>
            <p>I just wanted to talk about it a little bit here in the components section so that you knew about it. And
              just be aware, you can use a mixin to share any component option across multiple components including
              lifecycle hooks, props, computed properties, etc.
            </p>
          </div>
          <div><h3>Summary</h3>
            <p>In this module, we learned about the following component concepts, creating components, using bindings to
              display data and handle events, conditionally displaying elements with v-if and v-show, repeating elements
              with v-for, the various ways to style components, working with component lifecycle hooks, and using
              mixins.</p>
            <p>In the next module, we'll export various ways to communicate between components.
            </p>
          </div>
        </div>
        <div><h2>Enabling Inter-component Communication </h2>
          <div><h3>Introduction</h3>
            <p>In this module on intersection-component communication, we'll explore how to communicate between
              components. You don't get far in building an application before you run into situations where one
              component needs to know something about what's going on with another component, so it'll be good to learn
              how to accomplish this with Vue.</p>
            <p>There are a few topics to cover including using props to share data with child components, validating
              component props, passing data to parent components with events, and injecting content into a child
              component with slots. Understanding how to do this will allow us to build rich client-side applications
              with Vue, so let's dive in.
            </p>
          </div>
          <div><h3>Creating Child Components</h3>
            <p>So far, we haven't really done much with creating child components, other than the fact that our App
              component uses our RobotBuilder component. If we take a look at this RobotBuilder template, you can see a
              lot of repeating code here for each of the individual part selectors:</p>
            <figure>
              <img src="images/Fig03-001.png"/>
              <figcaption>Fig 03-001</figcaption>
            </figure>
            <p>Let's turn this into a part selector component and reuse it in each of these places. When we do that,
              we'll need to pass down to the PartSelector component the parts that we want it to select from, and that
              will be a great way to show how to communicate between components.</p>
            <figure>
              <img src="images/Fig03-002.png"/>
              <figcaption>Fig 03-002</figcaption>
            </figure>
            <p>So we'll start by creating a PartSelector component, and rather than completing this whole thing from
              scratch, let's start with a partially completed component. So over here in our helper repo in the src,
              build folder, we have this PartSelector.vue file:</p>
            <figure>
              <img src="images/Fig03-003.png"/>
              <figcaption>Fig 03-003</figcaption>
            </figure>
            <p>So let's grab that and paste that into our new component. So if we take a look at what we've pasted in
              here, you can see that at the top here:</p>
            <figure>
              <img src="images/Fig03-004.png"/>
              <figcaption>Fig 03-004</figcaption>
            </figure>
            <p>we have some HTML that looks a lot like the HTML that was being repeated multiple times over in our
              RobotBuilder. And then down here in the component script, you can see that we have some functions for
              getting the next and previous index:</p>
            <figure>
              <img src="images/Fig03-005.png"/>
              <figcaption>Fig 03-005</figcaption>
            </figure>
            <p>and down here:</p>
            <figure>
              <img src="images/Fig03-006.png"/>
              <figcaption>Fig 03-006</figcaption>
            </figure>
            <p>methods on our component for selecting the next part and the previous part that call those functions.
              This should look a little bit familiar because this same code, or code a lot like it, existed over in our
              RobotBuilder. So we've just moved that over into our PartSelector.</p>
            <p>And then notice up here:</p>
            <figure>
              <img src="images/Fig03-007.png"/>
              <figcaption>Fig 03-007</figcaption>
            </figure>
            <p>we're importing all of the available parts, and we're setting, here on line 13:</p>
            <figure>
              <img src="images/Fig03-008.png"/>
              <figcaption>Fig 03-008</figcaption>
            </figure>
            <p>this parts variable to the heads from the availableParts. This is just temporary so we can get up and
              going. The parts for the PartSelector will actually be passed into us by its parent component, so we'll
              delete this pretty quick here.</p>
            <p>So just to bring you up to speed with what the plan is, if we look at our robot builder, each one of
              these parts is going to be a different instance of the PartSelector, and the RobotBuilder will be
              responsible for giving each instance of the PartSelector the correct list of parts for it to work with. So
              in the RobotBuilder, when we create this instance of the PartSelector, it will pass in a list of heads,
              and when it creates this one, it will pass in a list of arms, etc. This will be a great way to learn how
              to communicate with child components.</p>
            <p>And now that the PartSelector will be taking care of all of the selecting of the parts, then over in our
              RobotBuilder we can delete a bunch of stuff here. So we can delete these functions here:</p>
            <figure>
              <img src="images/Fig03-009.png"/>
              <figcaption>Fig 03-009</figcaption>
            </figure>
            <p>that we saw exist now over in the PartSelector, and then we can delete all of these functions down here.
              And notice how many of these there are that we're going to be deleting:</p>
            <figure>
              <img src="images/Fig03-010.png"/>
              <figcaption>Fig 03-010</figcaption>
            </figure>
            <p>and all of these will be replaced with just two functions in the PartSelector. So you can see how this is
              going to be eliminating duplication, and it's going to be a lot cleaner. All right, and then we're not
              going to needs these selected indexes here:</p>
            <figure>
              <img src="images/Fig03-011.png"/>
              <figcaption>Fig 03-011</figcaption>
            </figure>
            <p>either. And then we're just going to initialize each one of these parts in our selected robot to just an
              empty object, so each one of these will be just initialized like this:</p>
            <figure>
              <img src="images/Fig03-012.png"/>
              <figcaption>Fig 03-012</figcaption>
            </figure>
            <p>And actually, now that this doesn't have any complex calculations anymore, it doesn't really need to be a
              computed property, so let's just move this up to our data object:</p>
            <figure>
              <img src="images/Fig03-013.png"/>
              <figcaption>Fig 03-013</figcaption>
            </figure>
            <p>And this will just be a property instead of a function, and it'll just return this object.</p>
            <p>And now we're just going to go ahead and import our PartSelector</p>
            <figure>
              <img src="images/Fig03-014.png"/>
              <figcaption>Fig 03-014</figcaption>
            </figure>
            <p>All right, and then this is something that you may not have noticed in the App component, but whenever
              you reference a child component, not only do you need to import it; you also need to list it in a
              components array on the parent component like this:</p>
            <figure>
              <img src="images/Fig03-015.png"/>
              <figcaption>Fig 03-015</figcaption>
            </figure>
            <p>This is what makes our component aware of this selector so that we can now use it up here. Okay, so now
              we're going to replace each one of these:</p>
            <figure>
              <img src="images/Fig03-016.png"/>
              <figcaption>Fig 03-016</figcaption>
            </figure>
            <p>with just a PartSelector:</p>
            <figure>
              <img src="images/Fig03-017.png"/>
              <figcaption>Fig 03-017</figcaption>
            </figure>
            <p>So we have one at the bottom for our base, three in the middle for the left arm, torso, and right
              arm:</p>
            <figure>
              <img src="images/Fig03-018.png"/>
              <figcaption>Fig 03-018</figcaption>
            </figure>
            <p>
              and then up here in the head, we have a little bit more going on. So we can go ahead and replace all of
              this here</p>
            <figure>
              <img src="images/Fig03-019.png"/>
              <figcaption>Fig 03-019</figcaption>
            </figure>
            <p>with the PartSelector:</p>
            <figure>
              <img src="images/Fig03-020.png"/>
              <figcaption>Fig 03-020</figcaption>
            </figure>
            <p>and we can get rid of this div here:</p>
            <figure>
              <img src="images/Fig03-021.png"/>
              <figcaption>Fig 03-021</figcaption>
            </figure>
            <p>This stuff, however:</p>
            <figure>
              <img src="images/Fig03-022.png"/>
              <figcaption>Fig 03-022</figcaption>
            </figure>
            <p>we're going to want to reuse later, and so I'm just going to comment that out for now.</p>
            <p>Okay, so now we can use these PartSelector elements because we have declared them down here. Oh, and
              actually, this is not supposed to be an array:</p>
            <figure>
              <img src="images/Fig03-023.png"/>
              <figcaption>Fig 03-023</figcaption>
            </figure>
            <p>this is an object</p>
            <figure>
              <img src="images/Fig03-024.png"/>
              <figcaption>Fig 03-024</figcaption>
            </figure>
            <p>So this is really an object where we're saying that we have a PartSelector component that is set to that
              PartSelector:</p>
            <figure>
              <img src="images/Fig03-025.png"/>
              <figcaption>Fig 03-025</figcaption>
            </figure>
            <p>but we can just use the shorthand syntax as shown previously. But you can see already how much cleaner
              our template is because we cleaned up so much duplication. So let's go check this out:</p>
            <figure>
              <img src="images/Fig03-026.png"/>
              <figcaption>Fig 03-026</figcaption>
            </figure>
            <p>Okay, well, we've got all heads again, so not exactly what we want, but it is what we expected since our
              PartSelector is currently just hardcoded to return heads. To fix that, each instance of our PartSelector
              needs to receive its list of parts from its parent component, so we'll do that next.</p>
            <p>But you'll also notice that our arrows on our buttons are missing, and the buttons aren't exactly in the
              right place. So depending on where the PartSelector is, sometimes the buttons need to be on the top and
              bottom of the image, and sometimes they need to be on the left and right. So the PartSelector will also
              need to know what position it's in before it knows what type of buttons to display, so we'll fix that too.
            </p>
            <p>We'll get into all of that in the next clip when we start talking about how to pass data down to child
              components.
            </p>
          </div>
          <div><h3>Using Props to Share Data with Child Components</h3>
            <p>We need to update our RobotBuilder to pass in the parts to the PartSelector for it to cycle through. So
              we'll start with this first one:</p>
            <figure>
              <img src="images/Fig03-027.png"/>
              <figcaption>Fig 03-027</figcaption>
            </figure>
            <p>which should allow the user to select which robot head they want. So that means over in our RobotBuilder,
              right here:</p>
            <figure>
              <img src="images/Fig03-028.png"/>
              <figcaption>Fig 03-028</figcaption>
            </figure>
            <p>We want to tell the PartSelector which parts to use, and we'd like to do that like this:</p>
            <figure>
              <img src="images/Fig03-029.png"/>
              <figcaption>Fig 03-029</figcaption>
            </figure>
            <p>So availableParts is already available to us in our RobotBuilder's data object, and then we're just
              grabbing the heads off of it. And notice that we're binding it to a parts attribute of the PartSelector.
              This won't work yet because the PartSelector doesn't have a parts attribute to bind to. We'll add that
              next.</p>
            <p>We can do that over in the PartSelector by just adding props to the component like this:</p>
            <figure>
              <img src="images/Fig03-030.png"/>
              <figcaption>Fig 03-030</figcaption>
            </figure>
            <p>And then the most simple syntax for this is just to pass in a string array:</p>
            <figure>
              <img src="images/Fig03-031.png"/>
              <figcaption>Fig 03-031</figcaption>
            </figure>
            <p>And that's all there is to making props available to be bound to by parent components. And now that we
              have that, we can stop hardcoding the parts up here:</p>
            <figure>
              <img src="images/Fig03-032.png"/>
              <figcaption>Fig 03-032</figcaption>
            </figure>
            <p>which means we don't need this import here:</p>
            <figure>
              <img src="images/Fig03-033.png"/>
              <figcaption>Fig 03-033</figcaption>
            </figure>
            <p>And then down here inside the component wherever we're using parts, this needs to be this.parts now:</p>
            <figure>
              <img src="images/Fig03-034.png"/>
              <figcaption>Fig 03-034</figcaption>
            </figure>
            <p>
              since we're getting that off the props. Okay, so now that we have that prop, let's go ahead and pass in
              the correct parts in each of these instances:</p>
            <figure>
              <img src="images/Fig03-035.png"/>
              <figcaption>Fig 03-035</figcaption>
            </figure>
            <p>This is torsos, and this is arms again, and then this one is bases. Cool, let's go see how this
              looks:</p>
            <figure>
              <img src="images/Fig03-036.png"/>
              <figcaption>Fig 03-036</figcaption>
            </figure>
            <p>
              Awesome, now we're getting the correct parts, even though the arms aren't quite positioned right. And even
              though our buttons are still missing their arrow icons and aren't quite positioned right, if I click them,
              they do work. And you can see our PartSelector even supports indicting if a part is on sale:</p>
            <figure>
              <img src="images/Fig03-037.png"/>
              <figcaption>Fig 03-037</figcaption>
            </figure>
            <p>Now in order to fix the arm positions and display the buttons correctly, we need to apply a CSS class to
              each one of these PartSelectors based on the position of each part selector. So for example, this part
              selector for the head is in the top position. This left arm selector is in the left position, this one's
              in the center position, this one's in the right position, and this one's in the bottom position. And if we
              take a look at the PartSelector down in the styles:</p>
            <figure>
              <img src="images/Fig03-038.png"/>
              <figcaption>Fig 03-038</figcaption>
            </figure>
            <p>
              you can see that I've already created CSS classes to handle displaying those correctly. But these position
              classes aren't being applied yet anywhere in our PartSelector component, and that's partly because the
              PartSelector component doesn't know what position it's in.</p>
            <p>So let's come back over to the RobotBuilder, and in addition to specifying the parts for each one, let's
              specify the position. So I'm going to set position=top:</p>
            <figure>
              <img src="images/Fig03-039.png"/>
              <figcaption>Fig 03-039</figcaption>
            </figure>
            <p>And notice there's something different about this binding. Notice the parts binding is using a colon, but
              the position is not. That's because position isn't really actually a binding. It's really just an
              attribute on the PartSelector, and we're setting it to the hardcoded string top. Whereas parts is an
              attribute, but we're binding to that attribute and passing along availableParts.heads, which is an
              expression that needs to be evaluated.</p>
            <p>So let's go ahead and add this position to each of these others too:</p>
            <figure>
              <img src="images/Fig03-040.png"/>
              <figcaption>Fig 03-040</figcaption>
            </figure>
            <p>So we've got left and center, and then right, and then finally down for our base, this is going to be
              bottom. Okay, now we're passing to our PartSelector what position it's in, so over here we need to add a
              position prop so it can receive that value:</p>
            <figure>
              <img src="images/Fig03-041.png"/>
              <figcaption>Fig 03-041</figcaption>
            </figure>
            <p>And now we're just going to use that in a class binding. So up here in the template, right here on this
              div, in addition to the part class, I also want to bind to the position:</p>
            <figure>
              <img src="images/Fig03-042.png"/>
              <figcaption>Fig 03-042</figcaption>
            </figure>
            <p>So remember, we can specify both a class and class binding, and they'll get combined. And so in the case
              of the head, this div will have two classes, a part class and a top class. So whatever value is passed in
              to the PartSelector for the position prop will become a class here. And then based on those classes and
              the styles that we specified below, everything will get styled correctly:</p>
            <p>So let's go take a look at our component again:</p>
            <figure>
              <img src="images/Fig03-043.png"/>
              <figcaption>Fig 03-043</figcaption>
            </figure>
            <p>There we go. Now our buttons are all positioned and you can see that some are on top and some are on
              bottom versus left and right, and the arrows are all there. And that all came from our CSS styling.</p>
            <p>So just to review the important parts of this, we can pass data into child components using attributes
              like this:</p>
            <figure>
              <img src="images/Fig03-044.png"/>
              <figcaption>Fig 03-044</figcaption>
            </figure>
            <p>and for each attribute, you just need to specify props in the child component:</p>
            <figure>
              <img src="images/Fig03-045.png"/>
              <figcaption>Fig 03-045</figcaption>
            </figure>
            <p>It's really that simple to pass data to a child component. We can, however, take this a little bit
              further and actually validate the props that are passed to make sure that they're the right type, etc.
              Let's take a look at that next.
            </p>
          </div>
          <div><h3>Validating Props</h3>
            <p>Our PartSelector component now takes in two props, parts and position:</p>
            <figure>
              <img src="images/Fig03-046.png"/>
              <figcaption>Fig 03-046</figcaption>
            </figure>
            <p>but there are no restrictions on the type of data or values that could be passed in to these props. We'd
              like to provide some validation to prevent parent components from passing in bad data. That's actually
              quite easy to do with a little different syntax.</p>
            <p>Let's start by requiring the parts prop to be an array and the position prop to be a string. So instead
              of using an array here, we'll use a keyed object where the keys are the names of the props, and the values
              are objects that specify validation information. So for the parts prop, we expect its type to be an array,
              and for position we expect its type to be a string:</p>
            <figure>
              <img src="images/Fig03-047.png"/>
              <figcaption>Fig 03-047</figcaption>
            </figure>
            <p>And now that we have these in place, if we come back over to our RobotBuilder, and on one of these,
              instead of passing in an array for the parts, we'll just pass in a string:</p>
            <figure>
              <img src="images/Fig03-048.png"/>
              <figcaption>Fig 03-048</figcaption>
            </figure>
            <p>And now if we come back over here:</p>
            <figure>
              <img src="images/Fig03-049.png"/>
              <figcaption>Fig 03-049</figcaption>
            </figure>
            <p>obviously, our left arm selector isn't going to be working because it's a string, not an array of parts.
              But if we take a look in our browser, you can see that we have a validation message here:</p>
            <figure>
              <img src="images/Fig03-050.png"/>
              <figcaption>Fig 03-050</figcaption>
            </figure>
            <p>because we passed in an invalid data type for the parts. And you can see right here it says Expected
              Array but got String.</p>
            <p>So we now have type checking that can help us identify problems during development. So let's go back and
              fix that:</p>
            <figure>
              <img src="images/Fig03-051.png"/>
              <figcaption>Fig 03-051</figcaption>
            </figure>
            <p>And then we can also make our props required. So here I'm going to, in addition in to specifying type,
              specify required: true, and then we'll do that for position, too, because it's also required:</p>
            <figure>
              <img src="images/Fig03-052.png"/>
              <figcaption>Fig 03-052</figcaption>
            </figure>
            <p>And now over here in our RobotBuilder, let's not pass in the left position. So if we come back over here,
              let's clear this and refresh. Well, you might be surprised to see here that there is no message:</p>
            <figure>
              <img src="images/Fig03-053.png"/>
              <figcaption>Fig 03-053</figcaption>
            </figure>
            <p>There's no validation error, and that's because, if we look at what we passed in, we didn't pass in
              nothing. We actually passed in an empty string:</p>
            <figure>
              <img src="images/Fig03-054.png"/>
              <figcaption>Fig 03-054</figcaption>
            </figure>
            <p>And so because we are providing a value for a position, it's not triggering the validation message. If we
              remove this altogether, however:</p>
            <figure>
              <img src="images/Fig03-055.png"/>
              <figcaption>Fig 03-055</figcaption>
            </figure>
            <p>and come back over here:</p>
            <figure>
              <img src="images/Fig03-056.png"/>
              <figcaption>Fig 03-056</figcaption>
            </figure>
            <p>there, now you can see it's saying that there is a required prop that's missing. But what if we actually
              do want to ensure that users cannot pass in an empty string here:</p>
            <figure>
              <img src="images/Fig03-057.png"/>
              <figcaption>Fig 03-057</figcaption>
            </figure>
            <p>Essentially, we want to indicate what are the valid values for position? So we can do that with a
              validator function. So in addition to specifying that position is required, we're going to supply a
              validator function, and that is a function that takes in the value that's being passed in to the prop. And
              we just want to ensure that it is one of these values, left, right, top, bottom, or center:</p>
            <figure>
              <img src="images/Fig03-058.png"/>
              <figcaption>Fig 03-058</figcaption>
            </figure>
            <p>So basically, I just want to make sure that the value is included in that array, or that this array
              includes the values that's passed in. Okay, now because we are passing in an empty string, we should now
              be seeing an error over here:</p>
            <figure>
              <img src="images/Fig03-059.png"/>
              <figcaption>Fig 03-059</figcaption>
            </figure>
            <p>and sure enough, if we refresh here, you can see that we are getting an error that the custom validator
              failed for prop position.</p>
            <p>Cool, so let's go back to our RobotBuilder and pass position back in here:</p>
            <figure>
              <img src="images/Fig03-060.png"/>
              <figcaption>Fig 03-060</figcaption>
            </figure>
            <p>and then if I clear this and refresh, you can see we're not getting that error anymore. And our
              RobotBuilder looks great:</p>
            <figure>
              <img src="images/Fig03-061.png"/>
              <figcaption>Fig 03-061</figcaption>
            </figure>
            <p>So awesome, we're now validating the props that being passed into our child component. Next, we'll take a
              look at how to pass data back to a parent component from a child component.
            </p>
          </div>
          <div><h3>Passing Data to Parent Components with Events</h3>
            <p>We now have a fully functioning PartSelector, and we're passing data from our RobotBuilder down to the
              PartSelector via its props. However, notice when I click this Add to Cart button:</p>
            <figure>
              <img src="images/Fig03-062.png"/>
              <figcaption>Fig 03-062</figcaption>
            </figure>
            <p>that I'm getting weird results down here in the cart:</p>
            <figure>
              <img src="images/Fig03-063.png"/>
              <figcaption>Fig 03-063</figcaption>
            </figure>
            <p>This is because our RobotBuilder, which is the parent component, isn't aware of changes that are
              happening inside the PartSelectors, which are child components of the RobotBuilder. If we look at the
              code:</p>
            <figure>
              <img src="images/Fig03-064.png"/>
              <figcaption>Fig 03-064</figcaption>
            </figure>
            <p>you can see that the Add to Cart method expects there to be a selectedRobot, and in our data function up
              here:</p>
            <figure>
              <img src="images/Fig03-065.png"/>
              <figcaption>Fig 03-065</figcaption>
            </figure>
            <p>you can see that we are initializing each of the parts in that selectedRobot to an empty object. And
              before we extracted the PartSelector component, each of these parts was getting updated whenever the user
              selected a new part, but now that selection is happening inside our PartSelector child components. So when
              we click on each of these buttons:</p>
            <figure>
              <img src="images/Fig03-066.png"/>
              <figcaption>Fig 03-066</figcaption>
            </figure>
            <p>the RobotBuilder has no idea that anything has changed because these buttons are inside the PartSelector
              component. So we need a way to tell our parent component when a different part is selected.</p>
            <p>Let's take a look at how to create events in the child component that the parent component can bind to.
              This will allow the parent component to react to changes in its child components, and it will allow us to
              pass data back to the parent component from the child component.</p>
            <p>So over here in our PartSelector component, down here in the methods, you can see that we have these two
              methods, selectNextPart and selectPreviousPart:</p>
            <figure>
              <img src="images/Fig03-067.png"/>
              <figcaption>Fig 03-067</figcaption>
            </figure>
            <p>We want both of these to emit an event that parent components can listen to by binding to them. This is
              surprisingly simple with Vue.</p>
            <p>Each Vue component has an emit function available that we can call to emit an event. So right here in the
              selectPreviousPart function, down here at the bottom, I'm just going to call this. emit, and then I'm just
              going to pass in the name of the event that we want to emit. So let's emit the event partSelected:</p>
            <figure>
              <img src="images/Fig03-068.png"/>
              <figcaption>Fig 03-068</figcaption>
            </figure>
            <p>This now means that a parent component can bind to a partSelected event when it creates the PartSelector
              component. We'll see how to do that in just a sec.</p>
            <p>First, when we emit this event, we want to be able to pass along some data with it. It won't do us much
              good to let the robot builder know that a part was selected if we don't tell it which part was selected,
              so let's pass along the currently selected part like this:</p>
            <figure>
              <img src="images/Fig03-069.png"/>
              <figcaption>Fig 03-069</figcaption>
            </figure>
            <p>Remember, we have a computed property up here:</p>
            <figure>
              <img src="images/Fig03-070.png"/>
              <figcaption>Fig 03-070</figcaption>
            </figure>
            <p>on our component called selectedPart so we're just using that here to pass it along. All right, and we're
              going to also want to emit that inside the selectNextPart function, so let's copy this and paste it
              here:</p>
            <figure>
              <img src="images/Fig03-071.png"/>
              <figcaption>Fig 03-071</figcaption>
            </figure>
            <p>
              Okay, cool. Now let's go see how to bind to this in the parent component. So over here in our
              RobotBuilder, up here we have our PartSelectors, and we'll start with this one here:</p>
            <figure>
              <img src="images/Fig03-072.png"/>
              <figcaption>Fig 03-072</figcaption>
            </figure>
            <p>We just want to bind to this new partSelected event. Binding to a component's event is done the exact
              same way you bind to any other element's event, with the v-on syntax or the at shorthand syntax. So we're
              going to bind to partSelected, and then we could bind that to a method on our component like thi:</p>
            <figure>
              <img src="images/Fig03-073.png"/>
              <figcaption>Fig 03-073</figcaption>
            </figure>
            <p>but actually, I think that this is going to be simple enough. I just want to handle it inline like
              this:</p>
            <figure>
              <img src="images/Fig03-074.png"/>
              <figcaption>Fig 03-074</figcaption>
            </figure>
            <p>
              So this is a function that takes in a part. And then this is the PartSelector for the robot head, and so I
              want to set the selectedRobot's head to this part, so we'll do that like this:</p>
            <figure>
              <img src="images/Fig03-075.png"/>
              <figcaption>Fig 03-075</figcaption>
            </figure>
            <p>So remember, the selectedRobot is an object that we already have on our component, and we're just setting
              the head to this part that's being passed in. And that's it, easy peasy.</p>
            <p>All you have to do to pass data to a parent is emit an event in the child component and then bind to it
              like this. So let's go ahead and do this for the other PartSelectors. So this is the left arm:</p>
            <figure>
              <img src="images/Fig03-076.png"/>
              <figcaption>Fig 03-076</figcaption>
            </figure>
            <p>this is the torso:</p>
            <figure>
              <img src="images/Fig03-077.png"/>
              <figcaption>Fig 03-077</figcaption>
            </figure>
            <p>this is the right arm:</p>
            <figure>
              <img src="images/Fig03-078.png"/>
              <figcaption>Fig 03-078</figcaption>
            </figure>
            <p>and this is the base:</p>
            <figure>
              <img src="images/Fig03-079.png"/>
              <figcaption>Fig 03-079</figcaption>
            </figure>
            <p>Okay, so that's it; the RobotBuilder is now aware of the selected parts because we're binding to the
              partSelected events and setting the selectedRobot parts. So if we go back over to our browser now and
              select each of these parts:</p>
            <figure>
              <img src="images/Fig03-080.png"/>
              <figcaption>Fig 03-080</figcaption>
            </figure>
            <p>and then click Add to Cart, you can see that that works just fine because the RobotBuilder is now aware
              of the data that's being passed back to it.</p>
            <p>But actually, we still have a small problem here. If I refresh this page and then click this Add to Cart
              button without changing anything:</p>
            <figure>
              <img src="images/Fig03-081.png"/>
              <figcaption>Fig 03-081</figcaption>
            </figure>
            <p>you can see that we're still getting our broken state. So it doesn't work when the page first loads, but
              if I change all of the parts and then click Add to Cart, you can see that it works just fine:</p>
            <figure>
              <img src="images/Fig03-082.png"/>
              <figcaption>Fig 03-082</figcaption>
            </figure>
            <p>This actually makes sense when you remember how we implemented the events. If we go back over to our
              PartSelector, you can see that we only emit the events when the selectNextPart or selectPreviousPart
              functions are called:</p>
            <figure>
              <img src="images/Fig03-083.png"/>
              <figcaption>Fig 03-083</figcaption>
            </figure>
            <p>and these are only called when the user clicks the buttons. So when the page first loads, the
              PartSelectors haven't emitted these events yet, and so the RobotBuilder doesn't have any selected parts.
              This is actually a great opportunity to tap into a component lifecyle method.</p>
            <p>So let's add a created function:</p>
            <figure>
              <img src="images/Fig03-084.png"/>
              <figcaption>Fig 03-084</figcaption>
            </figure>
            <p>and then let's emit the partSelected event when the component is first created. But instead of copying
              this line again:</p>
            <figure>
              <img src="images/Fig03-085.png"/>
              <figcaption>Fig 03-085</figcaption>
            </figure>
            <p>let's create a new function called emitSelectedPart:</p>
            <figure>
              <img src="images/Fig03-086.png"/>
              <figcaption>Fig 03-086</figcaption>
            </figure>
            <p>and then we will move this:</p>
            <figure>
              <img src="images/Fig03-087.png"/>
              <figcaption>Fig 03-087</figcaption>
            </figure>
            <p>up into here:</p>
            <figure>
              <img src="images/Fig03-088.png"/>
              <figcaption>Fig 03-088</figcaption>
            </figure>
            <p>and then right here, we can just call this.emitSelectedPart:</p>
            <figure>
              <img src="images/Fig03-089.png"/>
              <figcaption>Fig 03-089</figcaption>
            </figure>
            <p>And then we'll do the same thing down here:</p>
            <figure>
              <img src="images/Fig03-090.png"/>
              <figcaption>Fig 03-090</figcaption>
            </figure>
            <p>
              And then in our created event, we'll also call it here:</p>
            <figure>
              <img src="images/Fig03-091.png"/>
              <figcaption>Fig 03-091</figcaption>
            </figure>
            <p>So now the currently selected part will get emitted when this component is created, in addition to when
              clicking the buttons. And you can see up here that in our data function:</p>
            <figure>
              <img src="images/Fig03-092.png"/>
              <figcaption>Fig 03-092</figcaption>
            </figure>
            <p>we initialize the selectedPartIndex to 0, so when the selectedPart component is created, the first part
              in the list of parts that's passed in is always the selected part. So we have a default selected part that
              will get emitted whenever this component is first created.</p>
            <p>So now if we go over to our page here and refresh, you can see that I'm not going to change any of these
              parts, and I'm going to go ahead and click Add to Cart:</p>
            <figure>
              <img src="images/Fig03-093.png"/>
              <figcaption>Fig 03-093</figcaption>
            </figure>
            <p>and now it's working just fine because those events got emitted. So this is working great, but it's a
              little bit hard to see the events as they flow in as we click on the buttons because we don't see that the
              events are working until we click the Add to Cart button. For that reason, in order to see this a little
              bit better, let's add a little preview image up above the Add to Cart button that shows a preview of what
              our currently selected robot looks like.</p>
            <p>And as the events are emitted from the child components, you'll see the parent component changing. So
              we'll grab the HTML for that preview element over here in our GitHub repo. In src, build there is this
              RobotBuilder-preview.html:</p>
            <figure>
              <img src="images/Fig03-094.png"/>
              <figcaption>Fig 03-094</figcaption>
            </figure>
            <p>so let's grab that. And then we'll come back to our RobotBuilder, and right here at the top of the
              template inside the content div just above the Add to Cart button:</p>
            <figure>
              <img src="images/Fig03-095.png"/>
              <figcaption>Fig 03-095</figcaption>
            </figure>
            <p>we'll add that here.</p>
            <figure>
              <img src="images/Fig03-096.png"/>
              <figcaption>Fig 03-096</figcaption>
            </figure>
            <p>And then there's some styles for this too, so let's go grab those, so that's this
              RobotBuilder-preview.css:</p>
            <figure>
              <img src="images/Fig03-097.png"/>
              <figcaption>Fig 03-097</figcaption>
            </figure>
            <p>So let's copy that, and then back over here we'll just drop those in the bottom of our style section:</p>
            <figure>
              <img src="images/Fig03-098.png"/>
              <figcaption>Fig 03-098</figcaption>
            </figure>
            <p>
              Okay, let's go take a look at that and see what we've got. Okay, so you can see our preview is showing up
              here:</p>
            <figure>
              <img src="images/Fig03-099.png"/>
              <figcaption>Fig 03-099</figcaption>
            </figure>
            <p>so that's great, but the Add to Cart button is on top of it, so let's go fix that. So over here in our
              template, let's move our button:</p>
            <figure>
              <img src="images/Fig03-100.png"/>
              <figcaption>Fig 03-100</figcaption>
            </figure>
            <p>into our new preview section:</p>
            <figure>
              <img src="images/Fig03-101.png"/>
              <figcaption>Fig 03-101</figcaption>
            </figure>
            <p>We'll just move that up here. And then down here in the CSS, we just need to find the Add to Cart style,
              and we'll no longer need this right position:</p>
            <figure>
              <img src="images/Fig03-102.png"/>
              <figcaption>Fig 03-102</figcaption>
            </figure>
            <p>and we want to change the width a little bit to just 210 pixels. Now let's go take a look at that. Okay,
              there we go. Now the Add to Cart button's below:</p>
            <figure>
              <img src="images/Fig03-103.png"/>
              <figcaption>Fig 03-103</figcaption>
            </figure>
            <p>and there's our preview image. And now that we have that preview image, we can see the events coming in
              as we change them by clicking the parts here. And you can see that the preview image, which is on the
              parent component, is changing as we change the parts in the child component:</p>
            <figure>
              <img src="images/Fig03-104.png"/>
              <figcaption>Fig 03-104</figcaption>
            </figure>
            <p>Okay, this is awesome, and this is a great example of how to emit events from child components to pass
              data back to parent components.</p>
            <p>Now I just want to take a short detour here to talk again about lifecycle hooks because we have a great
              use case now. If we go back and look at our PartSelector component, you can see that right here we are
              emitting the selected part in the created lifecycle hook:</p>
            <figure>
              <img src="images/Fig03-105.png"/>
              <figcaption>Fig 03-105</figcaption>
            </figure>
            <p>And then down here in the selectNextPart and selectPreviousPart methods:</p>
            <figure>
              <img src="images/Fig03-106.png"/>
              <figcaption>Fig 03-106</figcaption>
            </figure>
            <p>we are emitting it again.</p>
            <p>We could simply this a little bit by using the updated lifecycle hook, and that is called whenever the
              data for the component is updated.</p>
            <p>So let's change this created hook to an updated hook:</p>
            <figure>
              <img src="images/Fig03-107.png"/>
              <figcaption>Fig 03-107</figcaption>
            </figure>
            <p>and then let's come down here and just delete these so that they're not emitted.</p>
            <figure>
              <img src="images/Fig03-108.png"/>
              <figcaption>Fig 03-108</figcaption>
            </figure>
            <p>These aren't going to be necessary because when we click the buttons, we end up changing the data, and
              because the data is changed, the updated lifecycle hook will get called and emit our selected part.</p>
            <p>So now if we come back here:</p>
            <figure>
              <img src="images/Fig03-109.png"/>
              <figcaption>Fig 03-109</figcaption>
            </figure>
            <p>you can see that our data is not being updated, but if I click this, then updated is being called:</p>
            <figure>
              <img src="images/Fig03-110.png"/>
              <figcaption>Fig 03-110</figcaption>
            </figure>
            <p>but this isn't quite what I want because we started out with it blank. And so we actually need both
              updated and created. We need those both to called emitSelectedPart:</p>
            <figure>
              <img src="images/Fig03-111.png"/>
              <figcaption>Fig 03-111</figcaption>
            </figure>
            <p>So now if I refresh, now as I change the parts, then you can see that the preview looks accurate:</p>
            <figure>
              <img src="images/Fig03-112.png"/>
              <figcaption>Fig 03-112</figcaption>
            </figure>
            <p>
              Cool. I just wanted to take that little detour to show you how lifecycle hooks work now that we had a
              better use case. And this is awesome. Now we've seen how to pass data to parent components with events,
              and we learned a little bit more about lifecycle hooks in the process.</p>
            <p>Next, let's learn how to inject HTML or Vue content into a component.
            </p>
          </div>
          <div><h3>Injecting Content into a Child Component with Slots</h3>
            <p>Sometimes you want to create a component that you can pass content into and have it be displayed in the
              appropriate place within that component. Imagine, for example, a component that is used as a collapsible
              drawer that expands and collapses as you click on a header, showing and hiding its content when clicked.
              In that case, you want a component to be reusable so that you can just wrap some part of your template in
              a collapsible component and it shows and hides that content.</p>
            <p>To experiment with this, we'll do just that; let's create a collapsible component that we can use to show
              and hide this preview image over here:</p>
            <figure>
              <img src="images/Fig03-113.png"/>
              <figcaption>Fig 03-113</figcaption>
            </figure>
            <p>And so over in our RobotBuilder, we want to be able to use it like this. So around this preview content,
              I want to have a CollapsibleSection component:</p>
            <figure>
              <img src="images/Fig03-114.png"/>
              <figcaption>Fig 03-114</figcaption>
            </figure>
            <p>And I'll wrap all of this content, the preview image but not the Add to Cart button, in that
              CollapsibleSection component:</p>
            <figure>
              <img src="images/Fig03-115.png"/>
              <figcaption>Fig 03-115</figcaption>
            </figure>
            <p>And then basically, this CollapsibleSection component will have a header that says expand and collapse,
              and when we click on it, it will show and hide this content. So let's go create this component.</p>
            <p>And I'm going to put that in a shared folder, since this is likely to be used by other components. And in
              there, I'll create a new file, CollapsibleSection.vue:</p>
            <figure>
              <img src="images/Fig03-116.png"/>
              <figcaption>Fig 03-116</figcaption>
            </figure>
            <p>And the template for this will be really simple, so I'll just type that in. So here's the template
              section of our component, and it's going to have an outer div, and then it's going to have an inner div
              that is the header, so we'll give it a header class:</p>
            <figure>
              <img src="images/Fig03-117.png"/>
              <figcaption>Fig 03-117</figcaption>
            </figure>
            <p>And then it's going to have a couple of spans in here, and those spans will say Collapse and Expand:</p>
            <figure>
              <img src="images/Fig03-118.png"/>
              <figcaption>Fig 03-118</figcaption>
            </figure>
            <p>
              And these are going to be shown or hidden based on whether the CollapsibleSection is currently open or
              not, so we will add a v-if, and we'll say if it's open, then show Collapse. And down here, if it is not
              open, then show Expand:</p>
            <figure>
              <img src="images/Fig03-119.png"/>
              <figcaption>Fig 03-119</figcaption>
            </figure>
            <p>And then on each of these spans we're going to bind to a click event, and we will just toggle open to not
              open, and we'll do that for both of these:</p>
            <figure>
              <img src="images/Fig03-120.png"/>
              <figcaption>Fig 03-120</figcaption>
            </figure>
            <p>And then I just want a down and up arrow here, so I'm going to add these Unicode characters:</p>
            <figure>
              <img src="images/Fig03-121.png"/>
              <figcaption>Fig 03-121</figcaption>
            </figure>
            <p>So that is an up arrow, and then a down arrow. Okay, so there's our header, and then basically we want to
              be able to add right here our togglable content here:</p>
            <figure>
              <img src="images/Fig03-122.png"/>
              <figcaption>Fig 03-122</figcaption>
            </figure>
            <p>So this is where we want our injected content to appear, so we'll come back to that in a second. First,
              let's add our script block. And we're going to export our component definition object, and this component
              will be named CollapsibleSection. And it will have a data object which has the open variable that we're
              toggling with our click handlers up above. So our data object will just return a new object with open set
              to true by default:</p>
            <figure>
              <img src="images/Fig03-123.png"/>
              <figcaption>Fig 03-123</figcaption>
            </figure>
            <p>Okay, and that's it for the component script, and then we just need a few styles here, and we'll have
              those be scoped as always. And we just need to style our header, and I wanted it have a background-color
              of gray and a little bit of padding. And we want it to have a pointer cursor:</p>
            <figure>
              <img src="images/Fig03-124.png"/>
              <figcaption>Fig 03-124</figcaption>
            </figure>
            <p>Okay, so now we have a component that has a header, and when we click on it, it toggles the open flag
              between true and false. Now we just need to know how to display injected content right here:</p>
            <figure>
              <img src="images/Fig03-125.png"/>
              <figcaption>Fig 03-125</figcaption>
            </figure>
            <p>where we want our toggleable content. For that, we use slots like this:</p>
            <figure>
              <img src="images/Fig03-126.png"/>
              <figcaption>Fig 03-126</figcaption>
            </figure>
            <p>So this slot element is a Vue-specific thing, and now that we've added it here, when we create a
              CollapsibleSection element like we have over in our RobotBuilder over here:</p>
            <figure>
              <img src="images/Fig03-127.png"/>
              <figcaption>Fig 03-127</figcaption>
            </figure>
            <p>this content that we put inside of our CollapsibleSection:</p>
            <figure>
              <img src="images/Fig03-128.png"/>
              <figcaption>Fig 03-128</figcaption>
            </figure>
            <p>will be shown right here where this slot element is:</p>
            <figure>
              <img src="images/Fig03-129.png"/>
              <figcaption>Fig 03-129</figcaption>
            </figure>
            <p>It's really that simple. Of course, since this is a collapsible section, we want to hide this slot when
              it's not open, so we'll put a v-if on here and only show it when open is true:</p>
            <figure>
              <img src="images/Fig03-130.png"/>
              <figcaption>Fig 03-130</figcaption>
            </figure>
            <p>Okay, so if we go back to our RobotBuilder component and we want to import this, and it looks like I
              must've missed something here. Yep, this CollapsibleSection needs to go down here actually:</p>
            <figure>
              <img src="images/Fig03-131.png"/>
              <figcaption>Fig 03-131</figcaption>
            </figure>
            <p>You may have already noticed that when I did it before. Okay, so if we come down here now and import our
              new CollapsibleSection component, so I'm going to import CollapsibleSection from..
              /shared/CollapsibleSection.vue:</p>
            <figure>
              <img src="images/Fig03-132.png"/>
              <figcaption>Fig 03-132</figcaption>
            </figure>
            <p>and then we can use this down here in our components:</p>
            <figure>
              <img src="images/Fig03-133.png"/>
              <figcaption>Fig 03-133</figcaption>
            </figure>
            <p>Now that is available to be used. And so now, this CollapsibleSection component should be working. Let's
              go take a look at that. There we go:</p>
            <figure>
              <img src="images/Fig03-134.png"/>
              <figcaption>Fig 03-134</figcaption>
            </figure>
            <p>Now you can see that we have a header here above our preview, and actually that's now working. I must've
              got my click handler wrong. Oh, yep, here I meant this to be equals not open:</p>
            <figure>
              <img src="images/Fig03-135.png"/>
              <figcaption>Fig 03-135</figcaption>
            </figure>
            <p>So basically, clicking on these spans will toggle the open variable. So now let's come back over here.
              And when I collapse this, there we go:</p>
            <figure>
              <img src="images/Fig03-136.png"/>
              <figcaption>Fig 03-136</figcaption>
            </figure>
            <p>so our collapsible content is working, and you can see how we injected content into our collapsible
              content using a slot. And then one last thing to be aware of, this may be a little less common, is the
              concept of default content for a slot.</p>
            <p>So in our CollapsibleSection, inside this slot element, I can provide any content that I want, so I could
              say here, div DefaultContent:</p>
            <figure>
              <img src="images/Fig03-137.png"/>
              <figcaption>Fig 03-137</figcaption>
            </figure>
            <p>And then this this will be displayed if no content is passed in. So let's add another CollapsibleSection
              here just above this one:</p>
            <figure>
              <img src="images/Fig03-138.png"/>
              <figcaption>Fig 03-138</figcaption>
            </figure>
            <p>and we won't provide any content for that. And now if we come over here, you can see that we have
              DefaultContent here instead of any data that was passed in:</p>
            <figure>
              <img src="images/Fig03-139.png"/>
              <figcaption>Fig 03-139</figcaption>
            </figure>
            <p>because we didn't pass in any content here. And as soon as I pass in something here, then that will show
              instead of the default content. And that's all there is to working with slots. I'm going to go ahead and
              delete the CollapsibleSection we just added. And that wraps up this module on inter-component
              communication.
            </p>
          </div>
          <div><h3>Summary</h3>
            <p>
              In this module, we've learned about using props to share data with child components, validating component
              props, passing data to parent components with events, and injecting content into a child component with
              slots. In the next module, we'll explore Vue.js routing and navigation.
            </p>
          </div>
        </div>
        <div><h2>Routing from Page to Page</h2>
          <div><h3>Introduction</h3>
            <p>All modern front-end frameworks provide some sort of routing mechanism for defining routes and navigating
              between pages in your single-page app. Vue. js, of course, is no different. In this module, we'll explore
              how to do this with Vue. This will include:</p>
            <ul>
              <li>Adding routing to our app</li>
              <li>Linking to routed pages</li>
              <li>Styling links based on the active route</li>
              <li>Navigating from code</li>
              <li>Working with route params</li>
              <li>Using nested routes</li>
              <li>Using named views</li>
              <li>Enabling HTML5 History Mode</li>
              <li>Preventing navigation with navigation guards</li>
            </ul>
            <p>Our build-a-bot app really needs some routing love, so let's go check it out.
            </p>
          </div>
          <div><h3>Adding Routing to Your App</h3>
            <p>
              If we take a look at our App component, you can see we're importing the HomePage component and
              RobotBuilder component down here:</p>
            <figure>
              <img src="images/Fig04-001.png"/>
              <figcaption>Fig 04-001</figcaption>
            </figure>
            <p>but without routing the only way we've been able to see each of these pages is by replacing this element
              up here:</p>
            <figure>
              <img src="images/Fig04-002.png"/>
              <figcaption>Fig 04-002</figcaption>
            </figure>
            <p>What we really want do is make it so that we can get each of these pages and others by changing the URL
              or by clicking on links. In order to do that, we'll need to install routing.</p>
            <p>If you remember, when we first created our project with the Vue CLI, we had the option to select routing,
              but we opted not to. However, adding routing to an existing project is really quite easy.</p>
            <p>First, we just need to install the vue-router package. So over in my terminal, I'm going to stop my
              server from running, and then I'm going to type:</p>
            <figure>
              <pre><code class="language-command-line">npm install vue-router --save</code></pre>
              <figcaption>Fig 04-003</figcaption>
            </figure>
            <p>and then I'm going to save that. Okay, and then let's go ahead and start up our server again:</p>
            <figure>
              <pre><code class="language-command-line">npm run serve</code></pre>
              <figcaption>Fig 04-004</figcaption>
            </figure>
            <p>And then back over in our app, we just need to have a place where we can define all of the routes for our
              application, so let's create a new router folder, and inside there we'll create a new index.js file:</p>
            <figure>
              <img src="images/Fig04-005.png"/>
              <figcaption>Fig 04-005.png</figcaption>
            </figure>
            <p>
              Okay, now inside here we're just going to import Vue, and then we just need to import the router, and
              we'll import that from vue-router that we just installed:</p>
            <figure>
              <img src="images/Fig04-006.png"/>
              <figcaption>Fig 04-006</figcaption>
            </figure>
            <p>And now we just need to tell Vue to use the router like this:</p>
            <figure>
              <img src="images/Fig04-006A.png"/>
              <figcaption>Fig 04-006A</figcaption>
            </figure>
            <p>So now Vue is aware of the fact that our application is going to use routing. And then we just need to
              export a new router:</p>
            <figure>
              <img src="images/Fig04-007.png"/>
              <figcaption>Fig 04-007</figcaption>
            </figure>
            <p>And then we just need to define the routes in here, so we pass into this a router configuration object,
              and then it has a routes property, which is an array:</p>
            <figure>
              <img src="images/Fig04-008.png"/>
              <figcaption>Fig 04-008</figcaption>
            </figure>
            <p>Okay, now we're ready to add our first route. This will be a route to our HomePage, and it will look like
              this:</p>
            <figure>
              <img src="images/Fig04-009.png"/>
              <figcaption>Fig 04-009</figcaption>
            </figure>
            <p>So it's an object that has a path property, and this is the URL that when Vue sees that this is the URL
              in the browser it should navigate to this route. And we'll give this route a name; we'll call it Home:</p>
            <figure>
              <img src="images/Fig04-010.png"/>
              <figcaption>Fig 04-010</figcaption>
            </figure>
            <p>
              And then we need to tell it which component to load when this route is navigated to. So we're going to
              tell it to load our HomePage component. And then we'll just have to import that up here:</p>
            <figure>
              <img src="images/Fig04-010.png"/>
              <figcaption>Fig 04-010</figcaption>
            </figure>
            <p>Okay, so this is our first route. This just says when I navigate to this URL:</p>
            <figure>
              <img src="images/Fig04-011.png"/>
              <figcaption>Fig 04-011</figcaption>
            </figure>
            <p>then display this component:</p>
            <figure>
              <img src="images/Fig04-012.png"/>
              <figcaption>Fig 04-012</figcaption>
            </figure>
            <p>And then this:</p>
            <figure>
              <img src="images/Fig04-013.png"/>
              <figcaption>Fig 04-013</figcaption>
            </figure>
            <p>is just the name that we're giving to our route, and we can use that in various places in our code. So
              this is pretty simple. And while we're in here, let's go ahead and create a route to our RobotBuilder
              too.</p>
            <p>
              So let's copy this, and we'll add another one, paste that in here. And the route for our RobotBuilder is
              /build, and we'll name this route Build, and then we just need it to render the RobotBuilder component.
              And we'll just have to import that:</p>
            <figure>
              <img src="images/Fig04-014.png"/>
              <figcaption>Fig 04-014</figcaption>
            </figure>
            <p>Okay, so this is our routes file all built out for the two pages that we currently have in our
              application. Now we just need to pull these routes in when we create our Vue instance so that Vue is aware
              of them. So let's import our new router:</p>
            <figure>
              <img src="images/Fig04-015.png"/>
              <figcaption>Fig 04-015</figcaption>
            </figure>
            <p>and then we just need to add that to our Vue configuration object here:</p>
            <figure>
              <img src="images/Fig04-016.png"/>
              <figcaption>Fig 04-016</figcaption>
            </figure>
            <p>Okay, so now our Vue instance is aware of our routes. The last thing we need to do is tell our app where
              to display routed components. So over here in our App component, right here:</p>
            <figure>
              <img src="images/Fig04-017.png"/>
              <figcaption>Fig 04-017</figcaption>
            </figure>
            <p>where we've been hardcoding the component that we want to display, what we really want to do instead is
              display the component that matches our current route. We can do that by replacing the hardcoded component
              name with the router-view tag:</p>
            <figure>
              <img src="images/Fig04-018.png"/>
              <figcaption>Fig 04-018</figcaption>
            </figure>
            <p>So now Vue will display the component that matches the current route right. We don't need these imports
              anymore:</p>
            <figure>
              <img src="images/Fig04-019.png"/>
              <figcaption>Fig 04-019</figcaption>
            </figure>
            <p>and we don't need this components property anymore:</p>
            <figure>
              <img src="images/Fig04-020.png"/>
              <figcaption>Fig 04-020</figcaption>
            </figure>
            <p>Okay, cool, let's go check this out. So if we come over to our browser and put in this URL, we're
              navigating to the root of the website, you can see that it loads the home page:</p>
            <figure>
              <img src="images/Fig04-021.png"/>
              <figcaption>Fig 04-021</figcaption>
            </figure>
            <p>You may notice, however, that it also added a hash tag to the URL, and the part of the URL after the hash
              tag is currently what Vue is looking at for matching the routes. And we'll talk later in this module about
              how to get rid of that hashtag using the HTML5 history mode.</p>
            <p>But for now, I can navigate to my pages by changing the route here, so now I want to navigate to
              /build:</p>
            <figure>
              <img src="images/Fig04-022.png"/>
              <figcaption>Fig 04-022</figcaption>
            </figure>
            <p>and you can see that takes me to my robot builder page.</p>
            <p>Okay, awesome. So our routes are working great, but the only way we have to get around is by manually
              changing the URL. Let's go see how to create links to these routes.
            </p>
          </div>
          <div><h3>Linking to Routed Pages</h3>
            <p>Now that we have a couple of routed pages, let's see how to link between them. We'll start with this Get
              started link right here:</p>
            <figure>
              <img src="images/Fig04-023.png"/>
              <figcaption>Fig 04-023</figcaption>
            </figure>
            <p>So over in our HomePage component, you can see that we have this Get started link right here:</p>
            <figure>
              <img src="images/Fig04-024.png"/>
              <figcaption>Fig 04-024</figcaption>
            </figure>
            <p>and it's just an anchor tag. In order to link to a route, we instead need to use Vue's router-link
              element like this:</p>
            <figure>
              <img src="images/Fig04-025.png"/>
              <figcaption>Fig 04-025</figcaption>
            </figure>
            <p>And then instead of an href attribute, we use a to attribute, so we're going to route to this URL, or
              this route, and I'm going to just say /build here. So I can put in a string here that represents the URL
              for one of the routes that we've added, and then I just need to add the correct closing tag.</p>
            <p> And now if we go check this out, I can now click on this Get started link, and there we go, it navigated
              me to the build page:</p>
            <figure>
              <img src="images/Fig04-026.png"/>
              <figcaption>Fig 04-026</figcaption>
            </figure>
            <p>So that's working now, but how do we get back to the home page? Let's make this logo and text here:</p>
            <figure>
              <img src="images/Fig04-027.png"/>
              <figcaption>Fig 04-027</figcaption>
            </figure>
            <p>a link to the home page. This will give us chance to look at a little bit different syntax. So this is
              going to be in our App component, and that's up here in our nav section. So you can see here, here is my
              logo, and here is the Build-a-Bot text:</p>
            <figure>
              <img src="images/Fig04-028.png"/>
              <figcaption>Fig 04-028</figcaption>
            </figure>
            <p>so let's go ahead and add a router-link around the logo and text:</p>
            <figure>
              <img src="images/Fig04-029.png"/>
              <figcaption>Fig 04-029</figcaption>
            </figure>
            <p>And then in our last example, we just used to, and we bound that to a URL like this:</p>
            <figure>
              <img src="images/Fig04-030.png"/>
              <figcaption>Fig 04-030</figcaption>
            </figure>
            <p>Instead of using this syntax, let's actually use a binding here, and we're going to pass into it an
              object. And in this object, I'm going to specify the name of a route, so I want to navigate to the home
              route here:</p>
            <figure>
              <img src="images/Fig04-031.png"/>
              <figcaption>Fig 04-031</figcaption>
            </figure>
            <p>And if you remember, over in our router index file:</p>
            <figure>
              <img src="images/Fig04-032.png"/>
              <figcaption>Fig 04-032</figcaption>
            </figure>
            <p>each of our routes we gave a name, and so we're routing to the route that has a name of home, which is
              going to be the route highlighted in Fig 04-032.</p>
            <figure>
              <img src="images/Fig04-033.png"/>
              <figcaption>Fig 04-033</figcaption>
            </figure>
            <p>So let's go check that out. So over here, you can see that we have a link now for our text up here, and
              the logo, it's also a link. So if I click on that, you can see it takes me to the home page:</p>
            <figure>
              <img src="images/Fig04-034.png"/>
              <figcaption>Fig 04-034</figcaption>
            </figure>
            <p>The only problem is that we don't want this link styling that we have here:</p>
            <figure>
              <img src="images/Fig04-035.png"/>
              <figcaption>Fig 04-035</figcaption>
            </figure>
            <p>so let's go add a class for that. So back over here on our router-link object, let's add a class, and
              that class will be nav-link:</p>
            <figure>
              <img src="images/Fig04-036.png"/>
              <figcaption>Fig 04-036</figcaption>
            </figure>
            <p>So notice that I can put a class on a router-link element just like I can any other element. And then
              down here in the styles, let's just add that nav-link class:</p>
            <figure>
              <img src="images/Fig04-037.png"/>
              <figcaption>Fig 04-037</figcaption>
            </figure>
            <p>and we'll set text-decoration to none, and we'll tell the color to be inherited. So this will avoid
              changing the color of the link. Okay, so if we come back over here, there we go:</p>
            <figure>
              <img src="images/Fig04-038.png"/>
              <figcaption>Fig 04-038</figcaption>
            </figure>
            <p>now our link is styled so I can go back to the build page and then back again to the home page. And this
              looks great. So now that we know how to link to our routes, let's go see how to style the currently active
              link based on the current URL.
            </p>
          </div>
          <div><h3>Styling Links Based on the Active Route</h3>
            <p>It's really easy in Vue to set up a style that will be used on links that match the current route. It'll
              be helpful to demonstrate this if we have a couple of links up here in our nav bar:</p>
            <figure>
              <img src="images/Fig04-039.png"/>
              <figcaption>Fig 04-039</figcaption>
            </figure>
            <p>Right now we only have one for the home page, so let's add another one up here that goes to the build
              page, in addition to that Get started link.</p>
            <p>So in our App component, let's duplicate this list item:</p>
            <figure>
              <img src="images/Fig04-040.png"/>
              <figcaption>Fig 04-040</figcaption>
            </figure>
            <p>and paste it below, and we'll change its router link to link to the build route:</p>
            <figure>
              <img src="images/Fig04-041.png"/>
              <figcaption>Fig 04-041</figcaption>
            </figure>
            <p>and then we can get rid of this image here:</p>
            <figure>
              <img src="images/Fig04-042.png"/>
              <figcaption>Fig 04-042</figcaption>
            </figure>
            <p>and we will just call this Build:</p>
            <figure>
              <img src="images/Fig04-043.png"/>
              <figcaption>Fig 04-043</figcaption>
            </figure>
            <p>Okay, so now we have two links in our navigation area, a link that goes to the home page, and a link that
              goes to the build page. And you can see those here:</p>
            <figure>
              <img src="images/Fig04-044.png"/>
              <figcaption>Fig 04-044</figcaption>
            </figure>
            <p>so we have one that goes to the build page, and one that takes us back home. Now let's make it so that
              the link that corresponds to the current URL shows up in a different color.</p>
            <p>So we can easily do that over here in our template by adding a class down here in our styles. So I'm just
              going to add a router-link-active class:</p>
            <figure>
              <img src="images/Fig04-045.png"/>
              <figcaption>Fig 04-045</figcaption>
            </figure>
            <p>And this is a special class used by Vue, and I'm going to just tell it to change the color to white:</p>
            <figure>
              <img src="images/Fig04-046.png"/>
              <figcaption>Fig 04-046</figcaption>
            </figure>
            <p>So this is a class that Vue applies to any links that match the current route. So let's see how that's
              looking. So over here:</p>
            <figure>
              <img src="images/Fig04-047.png"/>
              <figcaption>Fig 04-047</figcaption>
            </figure>
            <p>you can see that the Build-a-Bot link, which links to the home route, is currently white because we are
              on the home page, but if I click on Build here:</p>
            <figure>
              <img src="images/Fig04-048.png"/>
              <figcaption>Fig 04-048</figcaption>
            </figure>
            <p>you can see that Build turned white. However, we have a small problem in that these are both white, and
              the home page one should not be white anymore. That's because Vue by default is using an inclusive match
              on the route. If you look at the URL, technically it includes both the HomePage route, which is just the
              slash, and the build route, which is /build, so they're both white.</p>
            <p>What we really want for this is for it to be an exact match on the full URL. We can do that back over in
              our template by adding an exact attribute to our router-link:</p>
            <figure>
              <img src="images/Fig04-049.png"/>
              <figcaption>Fig 04-049</figcaption>
            </figure>
            <p>So I'm going to add that on both of our router-links, and now over here that should be fixed:</p>
            <figure>
              <img src="images/Fig04-050.png"/>
              <figcaption>Fig 04-050</figcaption>
            </figure>
            <p>There we go. So now only the exact route that matches the URL is being highlighted, so that's working
              great.</p>
            <p>Now you might be wondering, what if I don't want my class name to be called router-link-active? So down
              here we called this router-link-active:</p>
            <figure>
              <img src="images/Fig04-051.png"/>
              <figcaption>Fig 04-051</figcaption>
            </figure>
            <p>which is required in order for this to work, but we can use our own class name here. So I'm going to use
              foo here:</p>
            <figure>
              <img src="images/Fig04-052.png"/>
              <figcaption>Fig 04-052</figcaption>
            </figure>
            <p>and then back up here I could add an active-class attribute here and set that to foo:</p>
            <figure>
              <img src="images/Fig04-053.png"/>
              <figcaption>Fig 04-053</figcaption>
            </figure>
            <p>So now it will use this as the active-class, and I will put that in the other router-link also. And that
              should be working just fine. But we don't really have a need for that; I kind of like just using the
              built-in router-link-active class, so we'll change it back to use that.</p>
            <p> Next, let's take a look at how to navigate to a route from JavaScript code.
            </p>
          </div>
          <div><h3>Navigating from Code</h3>
            <p>In order to demonstrate how to navigate to a route from within our JavaScript code, let's create a new
              page, and we'll use this page in the next few clips too, in order to demonstrate route params. But
              basically, we're going to create a page that, if we click on one of these parts like the head or this
              arm:</p>
            <figure>
              <img src="images/Fig04-054.png"/>
              <figcaption>Fig 04-054</figcaption>
            </figure>
            <p>
              it will take you to a page where it describes that part. So let's start by creating a parts folder, and
              then inside that folder we'll create a new component called PartInfo.</p>
            <figure>
              <img src="images/Fig04-055.png"/>
              <figcaption>Fig 04-055</figcaption>
            </figure>
            <p>And for that, we'll just have a basic template that looks like this:</p>
            <figure>
              <img src="images/Fig04-056.png"/>
              <figcaption>Fig 04-056</figcaption>
            </figure>
            <p>If you're following along, go ahead and pause this and type that in. And we'll have a pretty basic script
              section also that looks like this:</p>
            <figure>
              <img src="images/Fig04-057.png"/>
              <figcaption>Fig 04-057</figcaption>
            </figure>
            <p>So notice that we have a PartInfo component and that the data function is returning a part object, and
              that object has a title and a description.</p>
            <p>So this is just hardcoded to display this fixed text right now. We'll fix this later. Until then, let's
              go ahead and create a route for this and then update the PartSelector to navigate to this page</p>
            <p> So over in our routes file, by the way, you may have noticed that I'm navigating by, on Windows I can
              hit Ctrl+P and then type in the name of a file to navigate to. So let's add another route down here, and
              that will be the parts route, and it will load our new PartInfo component.</p>
            <figure>
              <img src="images/Fig04-058.png"/>
              <figcaption>Fig 04-058</figcaption>
            </figure>
            <p>So let's import that component up here:</p>
            <figure>
              <img src="images/Fig04-059.png"/>
              <figcaption>Fig 04-059</figcaption>
            </figure>
            <p>Okay, so now that we have a route for this, let's go ahead and go navigate to it from code. So in our
              PartSelector component, let's add a click handler on our img component:</p>
            <figure>
              <img src="images/Fig04-060.png"/>
              <figcaption>Fig 04-060</figcaption>
            </figure>
            <p>so @click, and we could use a router-link here. There's no reason not use a router-link here, but we're
              going to navigate from code in order to demonstrate this. And you'll find better use cases for this where
              you might want to do some sort of processing or something before you navigate, but this will work to
              demonstrate it.</p>
            <p>So we're going to have that call a showPartInfo function:</p>
            <figure>
              <img src="images/Fig04-061.png"/>
              <figcaption>Fig 04-061</figcaption>
            </figure>
            <p>which we'll add down here in the methods. And here's where we'll tap into Vue's router in order to
              navigate. Because we injected a router into our Vue instance in our main.js file, we have a router
              available to us here like this:</p>
            <figure>
              <img src="images/Fig04-062.png"/>
              <figcaption>Fig 04-062</figcaption>
            </figure>
            <p>And all we need to do in order to navigate is call push and pass in the URL of the route to navigate
              to:</p>
            <figure>
              <img src="images/Fig04-063.png"/>
              <figcaption>Fig 04-063</figcaption>
            </figure>
            <p>
              And just like the router-link element, I can either pass in a URL string here, or I can pass in an object.
              We'll leave this as a string for now, and we'll change it to an object when we explore how to pass route
              parameters.</p>
            <p>Okay, let's check this out. So back over here, at first it seems like this is not clickable because my
              cursor hasn't changed, but if I go ahead and click on this, you can see that it did navigate me to the
              parts page:</p>
            <figure>
              <img src="images/Fig04-064.png"/>
              <figcaption>Fig 04-064</figcaption>
            </figure>
            <p>And this is happening via our programmatic navigation. Okay, cool, let's just change our pointer styling
              so that it looks like this is clickable. So back in our PartSelector, you can see up here that we already
              have a class on here on this div that is surrounding the img, and it's class=part:</p>
            <figure>
              <img src="images/Fig04-065.png"/>
              <figcaption>Fig 04-065</figcaption>
            </figure>
            <p>So down here, we should find that class, a class that targets that already, right here, part img. So in
              here let's just add cursor: pointer:</p>
            <figure>
              <img src="images/Fig04-066.png"/>
              <figcaption>Fig 04-066</figcaption>
            </figure>
            <p>So now you can see I'm getting a pointer here:</p>
            <figure>
              <img src="images/Fig04-067.png"/>
              <figcaption>Fig 04-067</figcaption>
            </figure>
            <p>and when I click on it, it takes me to this page, but it's still displaying hardcoded information:</p>
            <figure>
              <img src="images/Fig04-068.png"/>
              <figcaption>Fig 04-068</figcaption>
            </figure>
            <p>
              This is not displaying information about the part that I click on. For that, we'll need to pass some route
              params to our parts component.</p>
            <p>So in the next clip, we'll start exploring working with router params.
            </p>
          </div>
          <div><h3>Working with Route Params</h3>
            <p>
              Our PartInfo component is just currently hardcoding the title and description here on the page. What we'd
              like to do is to be able to specify the part type, like heads:</p>
            <figure>
              <img src="images/Fig04-069.png"/>
              <figcaption>Fig 04-069</figcaption>
            </figure>
            <p>and the part index, and then use that information to look up that part and display its info. In order to
              do that, we're going to have to update our route to expect those parameters, and then we need to grab
              those parameters off of the route in our component.</p>
            <p>So let's update the route first. So first, we need to update the URL for this route to add the params and
              use a colon here followed by a variable name, so partType, and then :id</p>
            <figure>
              <img src="images/Fig04-070.png"/>
              <figcaption>Fig 04-070</figcaption>
            </figure>
            <p>So this route now expects a part type like head, arm, torso, etc., and then a part id. With this
              information, we'll be able to look up our part from our parts list and display its information. So now
              let's go over to our PartInfo component and update it to grab these route parameters.</p>
            <p>So first we'll import our parts data. We'll import parts from data/parts:</p>
            <figure>
              <img src="images/Fig04-071.png"/>
              <figcaption>Fig 04-071</figcaption>
            </figure>
            <p>And now we'll need a computed prop, so let's add computed, and we'll have a part property that is a
              computed prop:</p>
            <figure>
              <img src="images/Fig04-072.png"/>
              <figcaption>Fig 04-072</figcaption>
            </figure>
            <p>So we'll return an object here, and that will look like the one down here in data. I'm just going to cut
              this out of here and paste it into here:</p>
            <figure>
              <img src="images/Fig04-073.png"/>
              <figcaption>Fig 04-073</figcaption>
            </figure>
            <p>and now we can get rid of data:</p>
            <figure>
              <img src="images/Fig04-074.png"/>
              <figcaption>Fig 04-074</figcaption>
            </figure>
            <p>we don't need that anymore. And then this:</p>
            <figure>
              <img src="images/Fig04-075.png"/>
              <figcaption>Fig 04-075</figcaption>
            </figure>
            <p>is what we want to do the lookup for us from the params. So we want to look up the part and get the title
              and description for that part based on the params that are passed in on the URL. So the route params are
              available to us on the component's route property, so we can get the partType, for example, like this:</p>
            <figure>
              <img src="images/Fig04-076.png"/>
              <figcaption>Fig 04-076</figcaption>
            </figure>
            <p>
              We're going to say this. $route. params. partType. And then this partType right here:</p>
            <figure>
              <img src="images/Fig04-077.png"/>
              <figcaption>Fig 04-077</figcaption>
            </figure>
            <p>needs to match the parameter name over here:</p>
            <figure>
              <img src="images/Fig04-078.png"/>
              <figcaption>Fig 04-078</figcaption>
            </figure>
            <p>So with that information, Vue can parse the partType off of the URL, and then we can get the ID in the
              same way. So id = this.$route.params. id:</p>
            <figure>
              <img src="images/Fig04-079.png"/>
              <figcaption>Fig 04-079</figcaption>
            </figure>
            <p>Okay, and this is red because our linter is telling us that we should prefer destructuring here, and so I
              can change this to look like this, set partType and id using destructuring, and we'll set it to
              this.$route.params.:</p>
            <figure>
              <img src="images/Fig04-080.png"/>
              <figcaption>Fig 04-080</figcaption>
            </figure>
            <p>
              Okay, so now I can use this to look up the parts, so instead of returning this hardcoded object:</p>
            <figure>
              <img src="images/Fig04-081.png"/>
              <figcaption>Fig 04-081</figcaption>
            </figure>
            <p>I'm going to do a lookup on the parts array where the partType is the partType that I get off of the
              params:</p>
            <figure>
              <img src="images/Fig04-082.png"/>
              <figcaption>Fig 04-082</figcaption>
            </figure>
            <p>So remember that the parts object that we're getting, that we're importing, is a keyed object where the
              partType is the key, and then that returns an array of that partType, so then I'm going to do a find, and
              I'm going to find where the part.id equals the id from params:</p>
            <figure>
              <img src="images/Fig04-083.png"/>
              <figcaption>Fig 04-083</figcaption>
            </figure>
            <p>But actually, there's a problem here, and that's because the params that are pulled off a URL are always
              strings, whereas the id's on the parts in our data are integers. And so this triple equals actually isn't
              going to work because it's not going to find a part with an id that is a string.</p>
            <p>So we can fix that by casting id to be a number here.</p>
            <figure>
              <img src="images/Fig04-084.png"/>
              <figcaption>Fig 04-084</figcaption>
            </figure>
            <p>Okay, so now we have our router set up with params, and we have our component set up to use those params.
              The last thing that we need to do now is just pass the params from the PartSelector component. So over
              here in our PartSelector, down here in our showPartInfo function, we want to pass the URL parameters here
              for PartType and id:</p>
            <figure>
              <img src="images/Fig04-085.png"/>
              <figcaption>Fig 04-085</figcaption>
            </figure>
            <p>but we can't pass part params using the string syntax; we actually need to use the object syntax in order
              to pass parameters. So I'm going to change this to an object and use a named route where the name is
              Parts, and then I can pass params. And then I'm going to specify that the id param is this. selectedPart.
              id, and the part type is this. selectedPart. type.</p>
            <figure>
              <img src="images/Fig04-086.png"/>
              <figcaption>Fig 04-086</figcaption>
            </figure>
            <p>Okay, so now we are saying navigate to the parts route and pass in the params id and partType, and we're
              going to get those off of the currently selected part. Okay, let's go check that out.</p>
            <p> So back over here, now if I click on one of these parts:</p>
            <figure>
              <img src="images/Fig04-087.png"/>
              <figcaption>Fig 04-087</figcaption>
            </figure>
            <p>there we go. Now we are navigating to parts/head/1, and we get a description of that part, a Large
              Cyclops:</p>
            <figure>
              <img src="images/Fig04-088.png"/>
              <figcaption>Fig 04-088</figcaption>
            </figure>
            <p>And if I change this to this part:</p>
            <figure>
              <img src="images/Fig04-089.png"/>
              <figcaption>Fig 04-089</figcaption>
            </figure>
            <p>now it is the Friendly Bot head:</p>
            <figure>
              <img src="images/Fig04-090.png"/>
              <figcaption>Fig 04-090</figcaption>
            </figure>
            <p>Okay, before we wrap up on this, let's just demonstrate that this is also possible using links instead of
              code navigation by changing this link:</p>
            <figure>
              <img src="images/Fig04-091.png"/>
              <figcaption>Fig 04-091</figcaption>
            </figure>
            <p>to be a router-link rather than navigating from code. So back in our PartSelector up here, let's get rid
              of this click binding:</p>
            <figure>
              <img src="images/Fig04-092.png"/>
              <figcaption>Fig 04-092</figcaption>
            </figure>
            <p>and then let's wrap this img in a router-link:</p>
            <figure>
              <img src="images/Fig04-093.png"/>
              <figcaption>Fig 04-093</figcaption>
            </figure>
            <p>and then we'll use a to binding. And let's grab the route expression down here from this function:</p>
            <figure>
              <img src="images/Fig04-094.png"/>
              <figcaption>Fig 04-094</figcaption>
            </figure>
            <p>I'm going to cut this out of there, and then we don't need this function anymore:</p>
            <figure>
              <img src="images/Fig04-095.png"/>
              <figcaption>Fig 04-095</figcaption>
            </figure>
            <p>And then I'm just going to paste that expression in here. And I'm just missing a closing bracket here,
              there we go:</p>
            <figure>
              <img src="images/Fig04-096.png"/>
              <figcaption>Fig 04-096</figcaption>
            </figure>
            <p>Okay, so this is just the same as when we were navigating with code, so I can click on the links and go
              to the parts page with the params.</p>
            <p>Awesome. So this is working great, and we're passing parameters between components using router-link. But
              next we'll see how to decouple our PartInfo component from the router by passing the route params as props
              instead.
            </p>
          </div>
          <div><h3>Passing Params as Props</h3>
            <p>
              One downside of using this route expression:</p>
            <figure>
              <img src="images/Fig04-097.png"/>
              <figcaption>Fig 04-097</figcaption>
            </figure>
            <p>is that it couples this component to the router. What if we wanted to use this component as a child
              component somewhere else and pass the partType and id as props instead of pulling it off of the route
              params? Well, we can make this work both as a routed component and as a child component by updating the
              route for this component to pass the params as props. </p>
            <p>So we can do that over in the route simply by setting the props property to true on this route:</p>
            <figure>
              <img src="images/Fig04-098.png"/>
              <figcaption>Fig 04-098</figcaption>
            </figure>
            <p>So now Vue will pass the route params that it identifies on the path for this route as props instead of
              as route params. And with that simple change, we can come over to our PartInfo component and add props for
              the partType and id:</p>
            <figure>
              <img src="images/Fig04-099.png"/>
              <figcaption>Fig 04-099</figcaption>
            </figure>
            <p>and now instead of getting partType and id off of this.$route.params:</p>
            <figure>
              <img src="images/Fig04-100.png"/>
              <figcaption>Fig 04-100</figcaption>
            </figure>
            <p>we can just get it off of this:</p>
            <figure>
              <img src="images/Fig04-101.png"/>
              <figcaption>Fig 04-101</figcaption>
            </figure>
            <p>which is where the props are. And it's that easy to decouple our component from the route. You can see
              over here that that is still working just fine:</p>
            <figure>
              <img src="images/Fig04-102.png"/>
              <figcaption>Fig 04-102</figcaption>
            </figure>
            <p>But let's add a little bit of validation to these props. So we'll change the props to an object, and it
              will have a partType, and we want it to be of type: String, and it will have an id, which will be of type:
              Number:</p>
            <figure>
              <img src="images/Fig04-103.png"/>
              <figcaption>Fig 04-103</figcaption>
            </figure>
            <p>But the problem with this is that when this component is used as a routed component, this id will still
              be passed in as a string, so we need to allow either a number or a string:</p>
            <figure>
              <img src="images/Fig04-104.png"/>
              <figcaption>Fig 04-104</figcaption>
            </figure>
            <p>But just to be sure that nobody passes in an invalid value here, let's also add a validator. And then
              we'll just verify that this is a number:</p>
            <figure>
              <img src="images/Fig04-105.png"/>
              <figcaption>Fig 04-105</figcaption>
            </figure>
            <p>so we'll call Number. isInteger, and then we will cast the value to a Number. Okay, so now we have some
              validation around our props, and if we come back over to our RobotBuilder page, the routing should still
              be working just fine.</p>
            <p>Great, now we know how to use route params and how to pass those parameters in as props. Now let's
              explore nested routes.
            </p>
          </div>
          <div><h3>Using Nested Routes</h3>
            <p>
              In order to understand what we're going to build in order to look at nested routes, let's take a look at
              the final result. So we're going to be building this Browse Parts page:</p>
            <figure>
              <img src="images/Fig04-106.png"/>
              <figcaption>Fig 04-106</figcaption>
            </figure>
            <p>and notice up here the URL is parts/browse. And when we navigate to that, it shows us a list of all the
              different parts. But then as I click on each of the different part types, you can see that the bottom part
              of this page here is changing, but this top part that includes this menu:</p>
            <figure>
              <img src="images/Fig04-107.png"/>
              <figcaption>Fig 04-107</figcaption>
            </figure>
            <p>is not changing. And notice the URL at the top as I click on each of these is also changing. And so the
              URL is changing, but really all Vue is replacing is this bottom section.</p>
            <p>That is possible because of nested routes, so let's go take a look at how to build this. To get started,
              we'll create a new BrowseParts component:</p>
            <figure>
              <img src="images/Fig04-108.png"/>
              <figcaption>Fig 04-108</figcaption>
            </figure>
            <p>So I've created that here in the parts folder. Let's go grab the contents from that from our GitHub repo.
              So in the src folder, in the parts folder, there is the BrowseParts.vue file:</p>
            <figure>
              <img src="images/Fig04-109.png"/>
              <figcaption>Fig 04-109</figcaption>
            </figure>
            <p>So let's grab that and paste that into our BrowseParts.vue component. So there's not a lot going on here.
              We have a bit of CSS, and then up here:</p>
            <figure>
              <img src="images/Fig04-110.png"/>
              <figcaption>Fig 04-110</figcaption>
            </figure>
            <p>we have a menu for the different parts. And then I'm going to need a new page for each of the different
              types of parts, so I'm going to create a new RobotHeads.vue and a new RobotArms component, and a
              RobotTorsos, and finally a RobotBases:</p>
            <figure>
              <img src="images/Fig04-111.png"/>
              <figcaption>Fig 04-111</figcaption>
            </figure>
            <p>
              And then I'm going to get the contents for each of these out of our GitHub repo from their corresponding
              files also:</p>
            <figure>
              <img src="images/Fig04-112.png"/>
              <figcaption>Fig 04-112</figcaption>
            </figure>
            <p>So here's RobotArms, and I'll paste that into RobotArms here, RobotBases, paste that in here, and then
              RobotHeads, and finally, RobotTorsos.</p>
            <p>And each one of these is really quite similar where you have a title and a description of the type of
              parts that we're dealing with on this page. And then you can see here:</p>
            <figure>
              <img src="images/Fig04-113.png"/>
              <figcaption>Fig 04-113</figcaption>
            </figure>
            <p>that we have a v-for that is looping over all of the, in this case, all of the arms and displaying the
              title and description, whereas here, we're looping over bases and torsos and heads. And then in each one,
              you can see that there is a data function that's returning the corresponding part, so we have a heads
              property on the RobotHeads component:</p>
            <figure>
              <img src="images/Fig04-114.png"/>
              <figcaption>Fig 04-114</figcaption>
            </figure>
            <p>and we have an arms property on the RobotArms component, etc.</p>
            <p>So now the trick is how do we get each one of these pages to be viewed on the browse page underneath this
              menu:</p>
            <figure>
              <img src="images/Fig04-115.png"/>
              <figcaption>Fig 04-115</figcaption>
            </figure>
            <p>whenever we click each one of the links for the different part types? Well, it starts with adding another
              router-view. You'll remember that we have a router-view already in our App component, and so we're adding
              a second one here:</p>
            <figure>
              <img src="images/Fig04-116.png"/>
              <figcaption>Fig 04-116</figcaption>
            </figure>
            <p>And now we can add routes for each one of these individual pages, RobotArms, RobotBases, etc. This is
              going to consist of a parent route for the BrowseParts page and child routes for each of the
              PartTypes.</p>
            <p>So in our routes in index.js we're going to create a BrowseParts route, and it's important that this goes
              above the existing parts route. I'll explain that in a second here. So right here I'm going to create a
              new route, and it's going to have a path of /parts/browse and a name of BrowseParts. And the component is
              going to be the BrowseParts component:</p>
            <figure>
              <img src="images/Fig04-117.png"/>
              <figcaption>Fig 04-117</figcaption>
            </figure>
            <p>and we'll need to import that:</p>
            <figure>
              <img src="images/Fig04-118.png"/>
              <figcaption>Fig 04-118</figcaption>
            </figure>
            <p>And that has to have the. vue extension on it. Okay, now back to why it was important where this goes.
              Notice that this parts path where we're navigating to a particular part that it has parts followed by a
              partType:</p>
            <figure>
              <img src="images/Fig04-119.png"/>
              <figcaption>Fig 04-119</figcaption>
            </figure>
            <p>Vue has no idea when we type in browse here:</p>
            <figure>
              <img src="images/Fig04-120.png"/>
              <figcaption>Fig 04-120</figcaption>
            </figure>
            <p>
              that we're not trying to type in a partType. So if we had put the BrowseParts route below the PartInfo
              route it would've got picked up first by the PartInfo route, and so the order is important.</p>
            <p>Okay, so now we have this BrowseParts route, and we're going to need to add the child routes now for the
              individual part types. We do that by adding a children array like this:</p>
            <figure>
              <img src="images/Fig04-121.png"/>
              <figcaption>Fig 04-121</figcaption>
            </figure>
            <p>So the BrowseParts route now has child routes, and then we just need to specify the child route for each
              part type:</p>
            <figure>
              <img src="images/Fig04-122.png"/>
              <figcaption>Fig 04-122</figcaption>
            </figure>
            <p>So we're going to have BrowseHeads, and that's going to have a path of heads, and resolve to the
              component RobotHeads. And one for BrowseArms, the path will be arms. Notice that this path is relative to
              the browse path, so the full path for arms is parts/browse/arms:</p>
            <figure>
              <img src="images/Fig04-123.png"/>
              <figcaption>Fig 04-123</figcaption>
            </figure>
            <p>And that will use the RobotArms component, and then we have BrowseTorsos, and the RobotTorsos component,
              and then finally BrowseBases. That's the bases path and the RobotBases component. So now let's go ahead
              and import each of those:</p>
            <figure>
              <img src="images/Fig04-124.png"/>
              <figcaption>Fig 04-124</figcaption>
            </figure>
            <p>Okay, so now we've created our nested routes, so we have our BrowseParts that has child routes for each
              one of the parts pages. Now all we have to do is create links for each one of these on the browse
              page.</p>
            <p>So back over here in the BrowseParts page, I just need to add a router-link around each one of these menu
              items. So, have a router-link, and then I'm going to use a to binding, and here I'm just going to specify
              the name of a route.</p>
            <figure>
              <img src="images/Fig04-125.png"/>
              <figcaption>Fig 04-125</figcaption>
            </figure>
            <p>
              And notice here that I can just provide the name of the child route. Okay, now we just want to do a
              similar thing around the rest of these:</p>
            <figure>
              <img src="images/Fig04-126.png"/>
              <figcaption>Fig 04-126</figcaption>
            </figure>
            <p>Okay, so we should be good to go. So we added a BrowseParts route, and it had child routes, and then we
              linked to each of the child routes here.</p>

            <p>Okay, so let's take a look. So instead of build here, we're going to navigate to parts/browse, and here
              we go:</p>
            <figure>
              <img src="images/Fig04-127.png"/>
              <figcaption>Fig 04-127</figcaption>
            </figure>
            <p>So now I can go to Heads and Arms and Torsos and Bases, and you can see that the data for the correct
              corresponding parts is loading down below:</p>
            <figure>
              <img src="images/Fig04-128.png"/>
              <figcaption>Fig 04-128</figcaption>
            </figure>
            <p>Awesome. So pretty simple to add child routes. Now let's go take a look at one more place where we can
              use a router-view, and that's with named views.
            </p>
          </div>
          <div><h3>Using Named Views</h3>
            <p>We just looked at nested child routes; now let's take a look at named views. You can almost think of
              named views as sibling routes. Whereas nested routes have a parent-child relationship, named views allow
              you to have multiple router-views on a single component, and the route for the component specifies which
              two or more views to display. </p>
            <p>To demonstrate that, let's add a sidebar to our app that will show up here on the left of every page:</p>
            <figure>
              <img src="images/Fig04-129.png"/>
              <figcaption>Fig 04-129</figcaption>
            </figure>
            <p>
              And each route in our app will be able to specify a different sidebar to display. Right now in our App
              component we have this main section down here that as a router-view in it:</p>
            <figure>
              <img src="images/Fig04-130.png"/>
              <figcaption>Fig 04-130</figcaption>
            </figure>
            <p>Let's also add an aside that we'll show to the left of this main section. So we'll give that a class of
              aside. And we'll wrap both of these in a container div:</p>
            <figure>
              <img src="images/Fig04-131.png"/>
              <figcaption>Fig 04-131</figcaption>
            </figure>
            <p>And let's go ahead and add those classes, so we have a container, and it's going to be display: flex with
              a margin of 10px auto 0 auto. And we will set justify-content to center:</p>
            <figure>
              <img src="images/Fig04-132.png"/>
              <figcaption>Fig 04-132</figcaption>
            </figure>
            <p>And then we need an aside class, and it's going to have a 30-pixel padding a background-color that is
              gray, 100-pixel width, and a min-height of 300 pixels, which matches the min-height of our main content
              area</p>
            <figure>
              <img src="images/Fig04-133.png"/>
              <figcaption>Fig 04-133</figcaption>
            </figure>
            <p> Okay, as we add these asides to our site, we're going to have to make a couple of other small CSS
              adjustments in order to fit those in. So on our main element we're going to remove the margin auto, and
              we're going to change its width to 964 pixels:</p>
            <figure>
              <img src="images/Fig04-134.png"/>
              <figcaption>Fig 04-134</figcaption>
            </figure>
            <p>And then we're going to change the width of the header to 1184 pixels:</p>
            <figure>
              <img src="images/Fig04-135.png"/>
              <figcaption>Fig 04-135</figcaption>
            </figure>
            <p>Okay, that should take care of the styling. So now up here in the aside, we'll go ahead and add another
              router-view:</p>
            <figure>
              <img src="images/Fig04-136.png"/>
              <figcaption>Fig 04-136</figcaption>
            </figure>
            <p>However, so that we can target this router-view, let's give it a name. So we're going to add a name
              attribute, and we will name it sidebar:</p>
            <figure>
              <img src="images/Fig04-137.png"/>
              <figcaption>Fig 04-137</figcaption>
            </figure>
            <p>And we can leave the other one without a name which by default, if we don't give it a name, it has the
              name default.</p>
            <p>Okay, now we need some content to display in this sidebar. So let's create a sidebars folder, and in
              here, I will create a SidebarStandard component, and I will also create a SidebarBuild component:</p>
            <figure>
              <img src="images/Fig04-138.png"/>
              <figcaption>Fig 04-138</figcaption>
            </figure>
            <p>So the build page will have its own sidebar. And our standard sidebar is just going to look like
              this:</p>
            <figure>
              <img src="images/Fig04-139.png"/>
              <figcaption>Fig 04-139</figcaption>
            </figure>
            <p>So if you're following along, go ahead and pause this, if you'd like to type it in. And the only content
              up here is just the text, Standard Sidebar, and we have a sidebar class here that is giving it a font size
              of 50 pixels and rotating it 90 degrees. And that's really all that's going on here. And then let's copy
              and paste this into the build sidebar:</p>
            <figure>
              <img src="images/Fig04-140.png"/>
              <figcaption>Fig 04-140</figcaption>
            </figure>
            <p>and we'll just change this to say Build Sidebar, and we will name it Build. And just to make it stand out
              a little bit, let's give it a green font color.</p>
            <p>Okay, now let's come over to our routes, and up here on the route for our HomePage, we're going to change
              this component property to components, plural, and then we'll change that from a simple property to a
              keyed object. And this will have two properties, default and sidebar:</p>
            <figure>
              <img src="images/Fig04-141.png"/>
              <figcaption>Fig 04-141</figcaption>
            </figure>
            <p>Remember that these names now correspond to the names of our router views. This one has a name of
              sidebar, and this one has a name of default. So when our home page is displayed, we want the default
              router-view to display our home page. And then we want the sidebar router-view to display our standard
              sidebar, and we'll need to import that up here:</p>
            <figure>
              <img src="images/Fig04-142.png"/>
              <figcaption>Fig 04-142</figcaption>
            </figure>
            <p>And then let's do the same thing for our build route, except that the default router-view will display
              the RobotBuilder, and in this case, we want to display the build sidebar:</p>
            <figure>
              <img src="images/Fig04-143.png"/>
              <figcaption>Fig 04-143</figcaption>
            </figure>
            <p>so let's import that also:</p>
            <figure>
              <img src="images/Fig04-144.png"/>
              <figcaption>Fig 04-144</figcaption>
            </figure>
            <p>Okay, cool. So now because our main App component has two router-views, we have to specify them both, or
              we can specify them both, and we can indicate in the route which content to display in each one. So let's
              go take a look at this. And it looks like we have an error in our CSS:</p>
            <figure>
              <img src="images/Fig04-145.png"/>
              <figcaption>Fig 04-145</figcaption>
            </figure>
            <p>so let's go back to our App component, and down here in the styles I'm missing a colon right here:</p>
            <figure>
              <img src="images/Fig04-146.png"/>
              <figcaption>Fig 04-146</figcaption>
            </figure>
            <p>it looks like. Okay, let's check this out:</p>
            <figure>
              <img src="images/Fig04-147.png"/>
              <figcaption>Fig 04-147</figcaption>
            </figure>
            <p>Okay, there we go. So we are on the build page and notice that on the build route that I have my robot
              builder, and I have the green build sidebar. And yet, if I go home, I have a different sidebar:</p>
            <figure>
              <img src="images/Fig04-148.png"/>
              <figcaption>Fig 04-148</figcaption>
            </figure>
            <p>This is the standard sidebar. And notice that if I go to the parts/browse page:</p>
            <figure>
              <img src="images/Fig04-149.png"/>
              <figcaption>Fig 04-149</figcaption>
            </figure>
            <p>that there actually is no sidebar here, or I should say there is no content in that sidebar. So this gray
              background is coming from the aside in our App component, which exists right here:</p>
            <figure>
              <img src="images/Fig04-150.png"/>
              <figcaption>Fig 04-150</figcaption>
            </figure>
            <p>So we have the aside here, and that has a gray background. But there is no content in it because we
              didn't give it a router-view on that page. So our route is not specifying a component for the sidebar
              router-view, and so it's blank.</p>
            <p>So it is optional to provide data here, but this is how you use named views in order to specify different
              content for different parts of the same page.</p>
            <p>Next let's go take a look at how to get rid of this hash sign in our URLs.
            </p>
          </div>
          <div><h3>Enabling HTML5 History Mode</h3>
            <p>
              All of our URLs so far have had this hashtag in them. That's because we're not yet using HTML5 history
              mode. So let's turn that on, and then we'll talk about a challenge that is presented by using it. So all
              we have to do to turn it on is to come over to our routes, and in our router configuration object we just
              need to set the mode to history:</p>
            <figure>
              <img src="images/Fig04-151.png"/>
              <figcaption>Fig 04-151</figcaption>
            </figure>
            <p>And that's it. Now if we come over here and start navigating around our site, you can see that there are
              no longer any hash signs in our URL:</p>
            <figure>
              <img src="images/Fig04-152.png"/>
              <figcaption>Fig 04-152</figcaption>
            </figure>
            <p>I really like this approach because the URLs look more professional, but there is one consequence to this
              that you need to be aware of.</p>
            <p>Imagine somebody comes to this part/heads/1 URL, and then they bookmark it. And then they come back, they
              close their browser, and they come back later, and the click on that bookmark. Or let's just say they open
              a new browser and they type in this URL. Well, this works locally in development because behind the scenes
              we're using web pack DevServer in order to serve this, and it can handle this.</p>
            <p>But imagine you have this running on your server, and a user types in this URL or clicks on a bookmark to
              this URL, it's going to request this full URL from your server, so it's going to request /parts/heads/1
              from your server. And your server doesn't actually have a document at that location. It has an index.html
              and some other files that are used for serving up your Vue.js single-page application, and your Vue.js
              application knows how to serve this URL, but your server doesn't actually know how to use it. And so you
              would actually get a 404 when you try to run this if you have not configured your server correctly.</p>
            <p>And that is not the case if you're using hashtag routing because only the part before the hashtag is sent
              to the server. Everything after the hashtag is handled client side. And so this is a problem only when you
              turn on history mode routing. So if you don't configure your server correctly, all of these URLs that
              people deep-link to will 404 when they try to hit them.</p>
            <p>Basically, you need to set up your server to always return the main index.html file whenever you load any
              URL like this. The way to do this varies depending on which webserver you're using. So the Vue
              documentation contains some instructions for some popular webservers. I'll talk more about this later in
              the Deploying to Production module in the clip on handling deep linking. I'll demonstrate how to do this
              with Express. But just be aware that when you turn on the HTML5 history mode that this is a concern that
              you have to take care of on the server.</p>
            <p>Next, we're going to take a look at navigation guards and how we can prevent users from navigating to or
              away from certain pages.
            </p>
          </div>
          <div><h3>Preventing Pages from Loading with Navigation Guards</h3>
            <p>
              Navigation guards allow you to either prevent a page from loading or prevent a user from leaving a page
              based on specific criteria. We'll take a look at both of these scenarios. Let's start with a beforeEnter
              guard. To demonstrate this, let's prevent this PartInfo page from loading if the id that's passed in is
              :</p>
            <figure>
              <img src="images/Fig04-153.png"/>
              <figcaption>Fig 04-153</figcaption>
            </figure>
            <p>You might think that we've already taken care of this when we added a prop validator that required the
              prop to be numeric, but this doesn't prevent the page from loading; it is more of a dev time warning that
              just throws errors in the console if the id isn't valid. We'd like to actually prevent navigation from
              happening.</p>

            <p>Notice that if we come over to our PartSelector and change id so that instead of passing in a valid id,
              it's just passing in a string:</p>
            <figure>
              <img src="images/Fig04-154.png"/>
              <figcaption>Fig 04-154</figcaption>
            </figure>
            <p>You can see that if I then try to navigate to this that it actually does navigate:</p>
            <figure>
              <img src="images/Fig04-155.png"/>
              <figcaption>Fig 04-155</figcaption>
            </figure>
            <p>You can see my URL has changed, but I just have a blank page. This is not ideal. What I'd like to do is
              to prevent the navigation from occurring completely. So let's go back here and change that back:</p>
            <figure>
              <img src="images/Fig04-156.png"/>
              <figcaption>Fig 04-156</figcaption>
            </figure>
            <p>and let's add a route guard to prevent this. So we can add that on a component or on a route. Let's see
              how to add one on a route.</p>
            <p>So we'll come over here, and right here in our PartInfo route:</p>
            <figure>
              <img src="images/Fig04-157.png"/>
              <figcaption>Fig 04-157</figcaption>
            </figure>
            <p>I'm going to add a beforeEnter function. And that takes three parameters, the route being navigated to,
              the route being navigated from, and a next function:</p>
            <figure>
              <img src="images/Fig04-158.png"/>
              <figcaption>Fig 04-158</figcaption>
            </figure>
            <p>And if we want to allow the navigation to proceed, we call this next function with a value of true. If we
              want to prevent the navigation, then we call it with false. So inside the beforeEnterFunction, we want to
              prevent navigation if the id is not numeric. So to get the id, we can get that off of the to route, and
              then on there, there is a params object, and that should contain the id parameter:</p>
            <figure>
              <img src="images/Fig04-159.png"/>
              <figcaption>Fig 04-159</figcaption>
            </figure>
            <p>So basically, if this is a valid integer, we want to allow the route to proceed. So I'm going to set a
              variable where const isValidId equal to true if the number is a valid integer. So we can do that like
              this, Number.isInteger, and we cast this to a Number. And now isValidId will be true is the id param is a
              valid integer.</p>
            <figure>
              <img src="images/Fig04-160.png"/>
              <figcaption>Fig 04-160</figcaption>
            </figure>
            <p>So now we just need to call next, and we need to call it with false if the id is not a valid integer. So
              we can just pass in isValidId here, and then if that's false, it will prevent the navigation. Otherwise,
              it will allow it:</p>
            <figure>
              <img src="images/Fig04-161.png"/>
              <figcaption>Fig 04-161</figcaption>
            </figure>
            <p>So this should still be working normally now:</p>
            <figure>
              <img src="images/Fig04-162.png"/>
              <figcaption>Fig 04-162</figcaption>
            </figure>
            <p>I should be able to navigate to each of the parts:</p>
            <figure>
              <img src="images/Fig04-163.png"/>
              <figcaption>Fig 04-163</figcaption>
            </figure>
            <p>and that's working fine.</p>
            <p>But if we come back over to our PartSelector and change this again to a string:</p>
            <figure>
              <img src="images/Fig04-164.png"/>
              <figcaption>Fig 04-164</figcaption>
            </figure>
            <p>and then try to navigate, when you click on the various Robot Part, nothing is happening, and that's
              because our route guard is stepping in and preventing the navigation because the id is not valid.</p>
            <p>So before we forget, let's go undo this and put that back how it was.</p>
            <figure>
              <img src="images/Fig04-165.png"/>
              <figcaption>Fig 04-165</figcaption>
            </figure>
            <p>And you can see how creating this route guard was super easy, and it can be really handy. We could've
              defined this on the component instead, or we could even define it globally.</p>
            <p>In the next clip, we'll create a beforeLeave navigation guard to prevent the user from leaving a page,
              and we'll do that in the component so you can see how that works.
            </p>
          </div>
          <div><h3>Preventing Navigation Away from Pages with Navigation Guards</h3>
            <p>Sometimes we want to prevent or warn a user before they leave a page. For example, imagine I spent some
              time configuring the perfect robot that I want here:</p>
            <figure>
              <img src="images/Fig04-166.png"/>
              <figcaption>Fig 04-166</figcaption>
            </figure>
            <p>and then I click the home link up here to navigate away. This could cause me to lose all of my progress
              on the robot I've built, so I may want to warn the user before they lose their progress. Let's create a
              beforeLeave route guard to handle this.</p>
            <p>This route guard is going to need some information from the component, so we'll create this one inside of
              the component rather than on the route like we did with the beforeEnter guard in the last clip.</p>
            <p>So over here in the RobotBuilder, we're going to add a beforeRouteLeave function right here:</p>
            <figure>
              <img src="images/Fig04-167.png"/>
              <figcaption>Fig 04-167</figcaption>
            </figure>
            <p>and notice that this has the word route in it. So we could add a beforeRouteEnter here:</p>
            <figure>
              <img src="images/Fig04-168.png"/>
              <figcaption>Fig 04-168</figcaption>
            </figure>

            <p>but you may remember that when we were adding this on a route as opposed to in a component, we actually
              didn't have the word route in here.</p>
            <p>So this is different when you're adding it on a component. So we want a beforeRouteLeave guard, and
              again, this has the to, from, and next parameters:</p>
            <figure>
              <img src="images/Fig04-169.png"/>
              <figcaption>Fig 04-169</figcaption>
            </figure>
            <p>And basically, we want to warn the user if they try to leave the page without adding the robot to the
              cart first.</p>
            <p>So let's add a property in our data function down here that will track whether they've added it to the
              cart. So we'll create an addedToCart property, and we will default that to false:</p>
            <figure>
              <img src="images/Fig04-170.png"/>
              <figcaption>Fig 04-170.png</figcaption>
            </figure>
            <p>And now up here in our route guard, we will check to see if that's true, so if this. addedToCart. And if
              it is true, we will allow them to leave the page:</p>
            <figure>
              <img src="images/Fig04-171.png"/>
              <figcaption>Fig 04-171</figcaption>
            </figure>
            <p>So we'll call next, passing in true, which will allow the navigation. Otherwise, we'll use a confirm
              dialog to ask them if they want to leave or not. So I'm going to set, I'm going to say const response
              equals, and then we're going to use confirm, and here we're going to say You have not added your robot to
              your cart, are you sure you want to leave?</p>
            <p>So if you're not familiar with confirm, it'll pop up a dialog kind of like an alert, but it has an OK and
              a cancel button. If they click OK, it returns true. Otherwise, it returns false. So if they click OK, then
              they're saying that they want to leave, and so we will pass response into next:</p>
            <figure>
              <img src="images/Fig04-172.png"/>
              <figcaption>Fig 04-172</figcaption>
            </figure>
            <p>And this is all we need. However, our linter is getting angry because it doesn't like us using confirm.
              Generally, alerts and confirms are not a great idea, but this is good for demoing this. And it's not bad
              to use it in the cases where it makes sense. And we're also getting an error because we're using a global
              function, so we're just going to disable those alerts here:</p>
            <figure>
              <img src="images/Fig04-173.png"/>
              <figcaption>Fig 04-173</figcaption>
            </figure>
            <p>So I'll just put in these two ESLint directives here, and now it's stopped complaining. There's just one
              last thing that we need to do here. Remember, we're checking to see if adddedToCart is true, and it's
              always going to be false right now because that's what we defaulted it to. So down in the addToCart
              function, once they've added to their cart, then we're going to set this. addedToCart = true:</p>
            <figure>
              <img src="images/Fig04-174.png"/>
              <figcaption>Fig 04-174</figcaption>
            </figure>
            <p>Okay, let's go check this out. So when I first load this page, if I try to navigate away, I should get a
              warning:</p>
            <figure>
              <img src="images/Fig04-175.png"/>
              <figcaption>Fig 04-175</figcaption>
            </figure>
            <p>There we go. You have not added your robot to your cart. Are you sure that you want to leave? And if I
              say Cancel, then it does not navigate away, but if I say OK, then it does navigate away, so that's working
              great.</p>
            <p> And if we go ahead and configure a robot and add it to our cart, then addedToCart is set to true, and
              now we can navigate away without a warning.</p>
            <p>Great, so now we know how to use route guards to prevent users from leaving a page.
            </p>
          </div>
          <div><h3>Summary</h3>
            <p>In this module, we learned all about routing in Vue, including adding routing to our app, linking to
              routed pages, styling links based on the active route, navigating from code, working with route params,
              using nested routes, using named views, enabling HTML5 history mode, and preventing navigation with
              navigation guards.</p>
            <p>In the next module, we'll learn how to manage state with Vuex.
            </p>
          </div>
        </div>
        <div><h2>Managing State and Server Communication with Vuex</h2>
          <div><h3>Introduction</h3>
            <p>
              Welcome to this module on managing state and server communication with Vuex. In this module, we'll explore
              how to reliably handle data in a Vue application using Vuex. Vuex helps us by creating a central store
              where we can store and retrieve data in a way that works well with change detection across an entire Vue
              application. At the heart of Vuex state management is the Vuex store:</p>
            <figure>
              <img src="images/Fig05-001.png"/>
              <figcaption>Fig 05-001</figcaption>
            </figure>
            <p>The store provides not just a storage mechanism, but an interface for mutating data, requesting
              asynchronous mutations to data, and managing complex logic for fetching computed data with getters. The
              interface it provides ensures a shared data store for your application that will work well with Vue's
              change detection. At the heart of the Vuex store is the shared state tree:</p>
            <figure>
              <img src="images/Fig05-002.png"/>
              <figcaption>Fig 05-002</figcaption>
            </figure>
            <p>This is essentially a single object that contains all of the data for your entire application. When you
              first create your store, you provide an initial state object with reasonable defaults. This is important
              to Vue's change detection. We'll talk more about that later, but just know that the store contains a
              single state object that can be accessed throughout your application.</p>
            <p>Once the store is created, if you want to make changes to data in the store you do so by committing
              mutations.</p>
            <figure>
              <img src="images/Fig05-003.png"/>
              <figcaption>Fig 05-003</figcaption>
            </figure>
            <p>Mutations are synchronous and shouldn't be confused with actions, which are asynchronous.</p>
            <p>You might wonder what the purpose of a synchronous mutation is. Why not just change the state directly?
              Essentially, by telling the store to commit a mutation it keeps everything within the store consistent and
              working well with change detection. If you want to kick off an asynchronous call that will eventually
              mutate the store, such as making a call to an API to fetch data, that's where actions come in:</p>
            <figure>
              <img src="images/Fig05-004.png"/>
              <figcaption>Fig 05-004</figcaption>
            </figure>
            <p>Actions contain asynchronous calls using constructs like promises or async/await, which when finished
              commit mutations to the store. Actions and mutations work hand in hand to make asynchronous calls and then
              mutate the state. Sometimes when you want to access data from the store, you want to perform some complex
              calculation logic before returning the data.</p>
            <p>For example, you may have an array of unicorns in your store and perhaps it's common in your application
              to want to retrieve only unicorns who can heal fatal wounds. Well, all over your application you could
              retrieve the list of unicorns from your store and then filter it as needed. But this distributes and
              duplicates the logic all throughout your application. For purposes like this, Vuex provides getters:</p>
            <figure>
              <img src="images/Fig05-005.png"/>
              <figcaption>Fig 05-005</figcaption>
            </figure>
            <p>Getters are basically functions in your store that fetch data from the state and do some sort of
              calculation on or manipulation of the data before returning it. So these four items, state, mutations,
              actions, and getters make up a Vuex store.</p>
            <p>In this module, we'll cover all the fundamentals of working with Vuex including:</p>
            <ul>
              <li>Creating a Vuex store</li>
              <li>Changing state with mutations</li>
              <li>Retrieving data from the state</li>
              <li>Using getters to return calculated data from the state</li>
              <li>using actions to work with asynchronous data</li>
              <li>using modules to organize a store</li>
              <li>using built-in helpers to work with the store.</li>
            </ul>
            <p>This will really help us turn our Build-a-Bot app into a full-feature Vue application. So let's get
              started.</p>
          </div>
          <div><h3>Creating a Vuex Store</h3>
            <p>The first need that we have in our app for state management is a place to store our cart. As it is right
              now, we've had to have our cart on our build page because we've had no way to manage state across pages.
              What we really want though is to create a cart page and then be able to add a robot to the cart from the
              build page and then have it show up on the cart page.</p>
            <p>Vuex will allow us to do that, but we'll first need to create a Vuex store. So let's create that. But
              first, we need to install Vuex. So, I'm going to stop my server here, and then I'm going to type:</p>
            <figure>
              <pre><code class="language-command-line">npm install vuex --save</code></pre>
              <figcaption>Fig 05-006</figcaption>
            </figure>
            <p>And then we'll save that. Now typically, this is all you'll do to install Vuex. But for this course, if
              you're following along, go ahead and specify version 3. 0. 1:</p>
            <figure>
              <pre><code class="language-command-line">npm install vuex@3.0.1 --save</code></pre>
              <figcaption>Fig 05-006</figcaption>
            </figure>
            <p>This will just make sure that you don't have any inconsistencies with different Vuex versions in the
              future. So let's go ahead and run that. Alright, now let's go ahead and start our server up again. Okay,
              and now to create our Vuex store.</p>
            <p>So, back over in our project here let's create a new folder. We'll call that store. And then inside that
              store we'll create a new index.js file:</p>
            <figure>
              <img src="images/Fig05-006.png"/>
              <figcaption>Fig 05-006</figcaption>
            </figure>
            <p>Okay, now in our store file we're just going to go ahead and import Vue, and we're going to import
              Vuex:</p>
            <figure>
              <img src="images/Fig05-007.png"/>
              <figcaption>Fig 05-007</figcaption>
            </figure>
            <p>And now we just need to tell Vue to use Vuex like this. So now our Vue instance is aware that we're using
              Vuex. And then finally, we'll just export a new Vuex store like this:</p>
            <figure>
              <img src="images/Fig05-008.png"/>
              <figcaption>Fig 05-008.png</figcaption>
            </figure>
            <p>Alright. And we'll come back to this and add more to this shortly. But first we need to come back over to
              our main.js and configure our Vue instance to use our new store. So let's import that up here:</p>
            <figure>
              <img src="images/Fig05-009.png"/>
              <figcaption>Fig 05-009</figcaption>
            </figure>
            <p>And then we'll just use it down here like this:</p>
            <figure>
              <img src="images/Fig05-010.png"/>
              <figcaption>Fig 05-010</figcaption>
            </figure>
            <p>Okay, so now we have a new store that we can start working with. In the next clip, we'll see how to start
              adding data to our store using mutations.
            </p>
          </div>
          <div><h3>Changing Vuex Store State with Mutations</h3>
            <p>Alright, now that we have a store let's start storing data in it. If we look at our RobotBuilder, we have
              the addToCart method. And right now, it's just storing the cart items in this array:</p>
            <figure>
              <img src="images/Fig05-011.png"/>
              <figcaption>Fig 05-011</figcaption>
            </figure>
            <p>We'd like to instead add that to our store so that it can be accessed by other components. Specifically,
              by a cart page component when we create it in the next clip.</p>
            <p>First off, our store needs a state object.</p>
            <figure>
              <img src="images/Fig05-012.png"/>
              <figcaption>Fig 05-012</figcaption>
            </figure>
            <p>
              The state object is where we'll store all of our data. So, we're going to create a cart property in our
              state object and default it to an empty array:</p>
            <figure>
              <img src="images/Fig05-013.png"/>
              <figcaption>Fig 05-013</figcaption>
            </figure>
            <p>This step is surprisingly important. You might think that we could just add this cart array to our state
              object somewhere else in our code later. Like, say, when we first mutate the state to add stuff to a cart.
              But it's important for Vue's change detection that you start with a default value for everything that you
              add to the store. This is because Vue's change detection works by tapping into the getters and setters of
              objects in the store. If you don't add a default property to the state to start with Vue won't even notice
              changes when you add that data later. So, for everything that you're going to store in the state you need
              to add a default property for it here in the state object.</p>
            <p>Okay, so now that we have a default cart object, let's go ahead and add a mutation. So we'll just add a
              mutations object:</p>
            <figure>
              <img src="images/Fig05-014.png"/>
              <figcaption>Fig 05-014</figcaption>
            </figure>
            <p>And as we discussed previously, all changes to data in a store must happen through a mutation. You can't
              just access the store's state directly and start changing data. All changes must go through a
              mutation.</p>
            <p>So we're going to add an addRobotToCart method here:</p>
            <figure>
              <img src="images/Fig05-015.png"/>
              <figcaption>Fig 05-015.png</figcaption>
            </figure>
            <p>This addRobotToCart mutation will be called from our RobotBuilder component. And the first parameter of a
              mutation is the state. And then the remaining parameters, if any, are the data that you want to pass in to
              the mutation. So we're going to add a robot parameter. And in our function we say
              state.cart.push(robot).</p>
            <p>So we're accessing the state through the parameter that was passed in to the mutation. And then we're
              accessing the cart on the state, which is an empty array initially because we defaulted it up above. And
              then we just push the robot that's passed in to the mutation onto that array.</p>
            <p>So this is all we need in order to add data to the store. Now let's go call this mutation. So back over
              here in our RobotBuilder, instead of pushing our robot onto this local cart array:</p>
            <figure>
              <img src="images/Fig05-016.png"/>
              <figcaption>Fig 05-016</figcaption>
            </figure>
            <p>we're going to access our store. And we can access it like this:</p>
            <figure>
              <img src="images/Fig05-017.png"/>
              <figcaption>Fig 05-017</figcaption>
            </figure>
            <p>because our global view instance is aware of our store, and so it's made available to our components. So,
              on the store I'm going to call commit. And then the first thing that we pass in to commit is the name of
              the mutation in our store.</p>
            <p>So this was the name of this function here:</p>
            <figure>
              <img src="images/Fig05-018.png"/>
              <figcaption>Fig 05-018</figcaption>
            </figure>
            <p>addRobotToCart. So we're going to paste that in here:</p>
            <figure>
              <img src="images/Fig05-019.png"/>
              <figcaption>Fig 05-019</figcaption>
            </figure>
            <p>So we're going to commit the addRobotToCart mutation, and then the next parameter that we pass in is the
              data that we want to pass to that mutation. And so that's our robot, which is this expression here:</p>
            <figure>
              <img src="images/Fig05-020.png"/>
              <figcaption>Fig 05-020</figcaption>
            </figure>
            <p>
              Alright, now we can delete this line:</p>
            <figure>
              <img src="images/Fig05-021.png"/>
              <figcaption>Fig 05-021</figcaption>
            </figure>
            <p>Okay, so this is now adding a robot to our cart in our Vuex store using a mutation. And this happens when
              we click the Add to Cart button on our RobotBuilder. But we can't see this at work until we display the
              data from the store somewhere else.</p>
            <p>So in the next clip, were going to create a simple cart page and see how to retrieve the cart data from
              the store. And then you'll be able to see this working.</p>
          </div>
          <p>
          <h3>Retreiving Items from the Vuex Store</h3>
          <p>Okay, so we've used this addRobotToCart mutation:</p>
          <figure>
            <img src="images/Fig05-022.png"/>
            <figcaption>Fig 05-022</figcaption>
          </figure>
          <p>in order to add our robot to the store. And now to demonstrate how to retrieve data from the store, let's
            create a cart page:</p>
          <figure>
            <img src="images/Fig05-023.png"/>
            <figcaption>Fig 05-023</figcaption>
          </figure>
          <p>So first, we'll create a cart folder and then we'll create a ShoppingCart component. And let's get the
            basic content for this from our GitHub repo. So, in the src cart folder we have this ShoppingCart.vue
            file.</p>
          <figure>
            <img src="images/Fig05-024.png"/>
            <figcaption>Fig 05-024</figcaption>
          </figure>
          <p>Let's go ahead and grab that and paste that into here. Okay, so nothing too fancy going on here. Just a bit
            of HTML here with an HTML table. And down here on line 16 we have this v-for:</p>
          <figure>
            <img src="images/Fig05-025.png"/>
            <figcaption>Fig 05-025</figcaption>
          </figure>
          <p>that we're looping over to display each of the items in the cart. This may look familiar. We did the same
            thing on the RobotBuilder page. And we'll delete that soon. And you can see here that our v-for is looping
            over a cart array:</p>
          <figure>
            <img src="images/Fig05-026.png"/>
            <figcaption>Fig 05-026</figcaption>
          </figure>
          <p>But that doesn't exist yet in our component. We want to get that off of our new Vuex store. For that, we'll
            use a computed property. So down here, let's create a computed section:</p>
          <figure>
            <img src="images/Fig05-027.png"/>
            <figcaption>Fig 05-027</figcaption>
          </figure>
          <p>And in here we're going to create a computed property called cart. And then, although you can't mutate a
            Vuex store state directly, you can access the state directly to read from it. And so, we're just going to
            access the cart on the store like this:</p>
          <figure>
            <img src="images/Fig05-028.png"/>
            <figcaption>Fig 05-028</figcaption>
          </figure>
          <p>So we're just going to return this. $store.state.cart. And that's it. Now we are adding items to the cart
            in the Vuex store from our RobotBuilder and then accessing it here in our cart component.</p>
          <p>So let's just go add a route and link to our cart page so we can see this working. So over in our routes,
            down at the bottom, let's add a new route. And the path for that will just be /cart. And we will name it
            cart. And that will use the ShoppingCart component:</p>
          <figure>
            <img src="images/Fig05-030.png"/>
            <figcaption>Fig 05-030</figcaption>
          </figure>
          <p>
            This needs to go right here. Okay, so now we just need to import our ShoppingCart. So right here we will
            import ShoppingCart from cart/ShoppingCart.vue:</p>
          <figure>
            <img src="images/Fig05-031.png"/>
            <figcaption>Fig 05-031</figcaption>
          </figure>
          <p>Okay, so we have a route for it. Now let's go over to our App component and add a link to it. So let's copy
            this existing menu item:</p>
          <figure>
            <img src="images/Fig05-032.png"/>
            <figcaption>Fig 05-032</figcaption>
          </figure>
          <p>
            And in addition to this nav-item class let's add a cart class:</p>
          <figure>
            <img src="images/Fig05-033.png"/>
            <figcaption>Fig 05-033</figcaption>
          </figure>
          <p>We're going to go ahead and pull this nav-item over to the right-hand side so there's a cart link in the
            top right-hand corner of our application. So we'll use this cart class for that.</p>
          <p>And then we're going to just go ahead and link to a simple /cart route here:</p>
          <figure>
            <img src="images/Fig05-034.png"/>
            <figcaption>Fig 05-034</figcaption>
          </figure>
          <p>And then since that's just a URL string we don't need to bind. And then right here we'll just change this
            to Cart. Okay, cool.</p>

          <p>So now down here in our styles, next to our other nav-item, we will add a nav-item. cart class. And we'll
            position this relative with a margin-left: auto and a border-right of none:</p>
          <figure>
            <img src="images/Fig05-035.png"/>
            <figcaption>Fig 05-035</figcaption>
          </figure>
          <p>Alright, we're ready to go check this all out. so just as a reminder, from our last clip we added a robot
            to our store using the addRobotToCart mutation:</p>
          <figure>
            <img src="images/Fig05-036.png"/>
            <figcaption>Fig 05-036</figcaption>
          </figure>
          <p>And that exists in our store right here:</p>
          <figure>
            <img src="images/Fig05-037.png"/>
            <figcaption>Fig 05-037</figcaption>
          </figure>
          <p>And that mutation is just pushing the robot onto our cart in our store. And then in our ShoppingCart we are
            using a computed property in order to get the cart out of the store:</p>
          <figure>
            <img src="images/Fig05-038.png"/>
            <figcaption>Fig 05-038</figcaption>
          </figure>
          <p>So let's go check that out. So, here we have our cart link:</p>
          <figure>
            <img src="images/Fig05-039.png"/>
            <figcaption>Fig 05-039</figcaption>
          </figure>
          <p>So, let's go ahead and add this robot to a cart and then we'll also add our friendly robot to our cart:</p>
          <figure>
            <img src="images/Fig05-040.png"/>
            <figcaption>Fig 05-040</figcaption>
          </figure>
          <p>
            And then let's go ahead and click on the cart to go to the cart page. And there we go:</p>
          <figure>
            <img src="images/Fig05-041.png"/>
            <figcaption>Fig 05-041</figcaption>
          </figure>
          <p>So you can see that we have our large cyclops and friendly bot robots that we just added from our build
            page, and it's accessible to us here on our cart page. So just to make it a little bit more obvious that
            this is being added to our cart when we click this button:</p>
          <figure>
            <img src="images/Fig05-042.png"/>
            <figcaption>Fig 05-042</figcaption>
          </figure>
          <p>let's add a little indicator up here on our cart link:</p>
          <figure>
            <img src="images/Fig05-043.png"/>
            <figcaption>Fig 05-043</figcaption>
          </figure>
          <p>that shows how many items are in the cart. So, back over in our App component, let's add a computed
            property here:</p>
          <figure>
            <img src="images/Fig05-044.png"/>
            <figcaption>Fig 05-044</figcaption>
          </figure>
          <p>to also get our cart off of the store like we did in the cart page. So add a computed section that will
            have a cart and that will just return this. $store.state.cart. And then up here right next to our cart link
            inside the list item, we're going to add a new div. And it will have a class, and we'll call that class
            cart-items:</p>
          <figure>
            <img src="images/Fig05-045.png"/>
            <figcaption>Fig 05-045</figcaption>
          </figure>
          <p>And then right in here we're exposing cart from our component. So we'll just say cart.length here:</p>
          <figure>
            <img src="images/Fig05-046.png"/>
            <figcaption>Fig 05-046</figcaption>
          </figure>
          <p>So this will display the number of items in the cart. And then we just need to add this cart-items class,
            so let's just come down to the bottom her:</p>
          <figure>
            <img src="images/Fig05-047.png"/>
            <figcaption>Fig 05-047</figcaption>
          </figure>
          <p>And you can see we're just positioning this absolute in the top right-hand corner next to the cart link,
            and we are giving it a border radius so it will be like a round pill. And then just a background color of
            sea green.</p>
          <p>Okay, so let's go see how that's working. Here we go, we can see that we have two items in our cart:</p>
          <figure>
            <img src="images/Fig05-048.png"/>
            <figcaption>Fig 05-048</figcaption>
          </figure>
          <p>If we go to our cart you can see that we do have two things in our cart:</p>
          <figure>
            <img src="images/Fig05-049.png"/>
            <figcaption>Fig 05-049</figcaption>
          </figure>
          <p>And we'll go back to Build, and let's add another item to our cart:</p>
          <figure>
            <img src="images/Fig05-050.png"/>
            <figcaption>Fig 05-050</figcaption>
          </figure>
          <p>And you can see immediately that changed to three. I'll click it again here, it'll change to four:</p>
          <figure>
            <img src="images/Fig05-051.png"/>
            <figcaption>Fig 05-051</figcaption>
          </figure>
          <p>So now we are accessing data from our store across three different components. It's being added from our
            RobotBuilder component and then it's being accessed by our cart and App components.</p>
          <p> Okay, that's awesome. So, let's just go clean up this extra cart stuff here:</p>
          <figure>
            <img src="images/Fig05-052.png"/>
            <figcaption>Fig 05-052</figcaption>
          </figure>
          <p>that we're not using any more on our RobotBuilder page. So, here in our RobotBuilder, down here at the
            bottom we have this table data, table header, and cost classes that we can delete:</p>
          <figure>
            <img src="images/Fig05-053.png"/>
            <figcaption>Fig 05-053</figcaption>
          </figure>
          <p>And then up in the HTML, we have this whole cart section here that we can delete:</p>
          <figure>
            <img src="images/Fig05-054.png"/>
            <figcaption>Fig 05-054.png</figcaption>
          </figure>
          <p>Okay. So, that is gone now from our RobotBuilder page, and when we add items to our cart they are showing
            on our cart. So accessing data from the state is pretty simple.</p>
          <p>Next, we'll take a look at how to add getter functions to the store so that we can compute derived state in
            the store when necessary.
          </>
        </div>
        <div><h3>Using Vuex Getters to Return Calculated Data</h3>
          <p>So far, we've been accessing state on the store directly just like this:</p>
          <figure>
            <img src="images/Fig05-055.png"/>
            <figcaption>Fig 05-055</figcaption>
          </figure>
          <p>Sometimes you want to have a computed property on the state that returns a value that is a calculation or
            derived value of some sort based on data that's in the state. This is what Vuex getters are for. To explore
            this, let's create a getter on our store that will return only items from the cart that are on sale.</p>
          <p>
            This is going to be based on this cart value from the state:</p>
          <figure>
            <img src="images/Fig05-056.png"/>
            <figcaption>Fig 05-056</figcaption>
          </figure>
          <p>but will basically filter the cart for just the items that are on sale. We could just do this in the
            component, but sometimes you want to reuse logic like this, and encapsulating logic like this in the store
            can be helpful.</p>
          <p>So first, let's go back over to our shopping cart and we will duplicate our cart here. So we'll grab this
            header and this table:</p>
          <figure>
            <img src="images/Fig05-057.png"/>
            <figcaption>Fig 05-057</figcaption>
          </figure>
          <p>and we'll just duplicate it. And then let's change this to h2. And we'll change this to say You saved money
            on these robots. And then let's just add a class on this h2 called saleItems.:</p>
          <figure>
            <img src="images/Fig05-058.png"/>
            <figcaption>Fig 05-058</figcaption>
          </figure>
          <p> And then that class just looks like this. So it'll have a margin on the top to separate it from the normal
            part. And we'll give it a font size of 18px. And we'll give it a red color since it's sale items:</p>
          <figure>
            <img src="images/Fig05-059.png"/>
            <figcaption>Fig 05-059</figcaption>
          </figure>
          <p>Okay, now back up in our HTML, instead of looping over the cart we're going to loop over a new computed
            property and that will be called cartSaleItems:</p>
          <figure>
            <img src="images/Fig05-060.png"/>
            <figcaption>Fig 05-060</figcaption>
          </figure>
          <p>Okay. And then let's add a computed property down here for that. So this will be cartSaleItems:</p>
          <figure>
            <img src="images/Fig05-061.png"/>
            <figcaption>Fig 05-061.png</figcaption>
          </figure>
          <p>And then again, we could just grab the cart from the store and then filter it right here, but we want to do
            this in a getter in the store so it's reusable. So let's go back over to the store and we'll add a new
            section for getters. And then we'll add our cartSaleItems getter:</p>
          <figure>
            <img src="images/Fig05-062.png"/>
            <figcaption>Fig 05-062</figcaption>
          </figure>
          <p>And the first parameter for getters is the state. And now we can do whatever calculations from the state
            that we want to do here. So, we'll go ahead and return state.cart.filter. And then we'll filter that for
            just the items where the head is on sale:</p>
          <figure>
            <img src="images/Fig05-063.png"/>
            <figcaption>Fig 05-063</figcaption>
          </figure>
          <p>Of course, a robot would be on sale if other parts are on sale, but this is simple and you get the idea.
            You can go ahead and enhance this if you'd like.</p>
          <p>So now you can see that we're just filtering for any items where the robot's head is on sale. And this
            calculation is based on data that's in the state and then exposed as a cartSaleItems getter. And now this
            logic is nicely encapsulated here. So now the only question is how do we access it?</p>
          <p>Well that's pretty simple. So back over here in our cart where we created our computed property we can
            access it just like we do with the state, this.$store. But instead of saying. state we'll say. getters. And
            we'll ask for cartSaleItems.</p>
          <figure>
            <img src="images/Fig05-064.png"/>
            <figcaption>Fig 05-064</figcaption>
          </figure>
          <p>Okay, let's go see how that's working. So, here's our cart and here's our new section:</p>
          <figure>
            <img src="images/Fig05-065.png"/>
            <figcaption>Fig 05-065</figcaption>
          </figure>
          <p>Although it is not styled correctly, so let's come back over here and see what we did. Oh, here we go. This
            should be class:</p>
          <figure>
            <img src="images/Fig05-066.png"/>
            <figcaption>Fig 05-066</figcaption>
          </figure>
          <p>You probably saw that when I first did it and I was probably driving you nuts. But now that that's styled
            let's go take a look. Okay, there we go:</p>
          <figure>
            <img src="images/Fig05-067.png"/>
            <figcaption>Fig 05-067</figcaption>
          </figure>
          <p>So that's working now. So let's go ahead and add this robot that is not on sale. Now you can see we now
            have one item in our cart.</p>
          <figure>
            <img src="images/Fig05-068.png"/>
            <figcaption>Fig 05-068</figcaption>
          </figure>
          <p>And now let's go ahead and add this one that's on sale:</p>
          <figure>
            <img src="images/Fig05-069.png"/>
            <figcaption>Fig 05-069</figcaption>
          </figure>
          <p>And now let's go take a look at our cart. There we go. So you can see that we have two items in our cart
            and only one of them is on sale:</p>
          <figure>
            <img src="images/Fig05-070.png"/>
            <figcaption>Fig 05-070</figcaption>
          </figure>
          <p>So using getters is really easy and a nice way to encapsulate any calculation logic into your store</p>
          <p>
            Next, we'll start exploring how to access data from a remote API. And that get a little bit more interesting
            due to the asynchronous nature of HTTP calls.
          </p>
        </div>
        <div><h3>Using Actions to Work with APIs and Asynchronous Data</h3>
          <p>Everything that we've done so far with Vuex has been synchronous, simply modifying and reading from the
            local state. But of course, most web applications today deal with asynchronous HTTP calls to fetch and
            update data from a remote API. With Vuex we can accomplish that with actions. But first, we'll need an API
            to work with.</p>
          <p>To make this easy I've already created this API over here:</p>
          <figure>
            <img src="images/Fig05-071.png"/>
            <figcaption>Fig 05-071</figcaption>
          </figure>
          <p>So, let's clone this by copying the remote URL here. And then over here in our bash console I'm going to
            open a new tab and change directory to where I keep my projects. And then I'm going to go ahead and git
            clone that:</p>
          <figure>
            <img src="images/Fig05-072.png"/>
            <figcaption>Fig 05-072</figcaption>
          </figure>
          <p>And if you're using this same bash console, you paste by right-clicking. So I'll paste my remote URL in
            here and go ahead and clone that. Okay, so let's change directory into that new directory. And then I'm just
            going to do a npm install:</p>
          <figure>
            <img src="images/Fig05-073.png"/>
            <figcaption>Fig 05-073</figcaption>
          </figure>
          <p>Alright, now we can go ahead and start up this server by just saying npm start:</p>
          <figure>
            <img src="images/Fig05-074.png"/>
            <figcaption>Fig 05-074</figcaption>
          </figure>
          <p>Okay, now you can see we have a server listening at port 8081. So if I come back over to my browser and go
            to localhost port 8081 then I have an endpoint right here that I can hit, api/parts:</p>
          <figure>
            <img src="images/Fig05-075.png"/>
            <figcaption>Fig 05-075</figcaption>
          </figure>
          <p>And there we go. So you can see now that this parts endpoint on our new API is returning all of our robot
            parts data that we previously have had hard decoded in our application.</p>
          <p>And now it's time to finally start getting this from the real API, so we'll do that with a Vuex action. So,
            back over in our store let's add an action section:</p>
          <figure>
            <img src="images/Fig05-076.png"/>
            <figcaption>Fig 05-076</figcaption>
          </figure>
          <p>And in here we create our first action which we call getParts.</p>
          <p>And the first parameter to an action function is a context object:</p>
          <figure>
            <img src="images/Fig05-077.png"/>
            <figcaption>Fig 05-077</figcaption>
          </figure>
          <p>The context exposes several items for working with the state. So instead of passing in this we could
            actually deconstruct it to grab what we want. It provides things like state, getters, a commit function, and
            a dispatch function:</p>
          <figure>
            <img src="images/Fig05-078.png"/>
            <figcaption>Fig 05-078</figcaption>
          </figure>
          <p>But all we really need right now is the commit function so that's all I'm going to deconstruct out of the
            context object. The commit function is how we call mutations on the store. You may recall that we're already
            using the commit function in the RobotBuilder currently to call the addRobotToCart mutation. So, we'll use
            this commit function in just a minute. First, we need a way to make HTTP calls.</p>
          <p>Vue doesn't provide any of its own custom Ajax or data access methods or libraries. Instead, they allow you
            to use whatever you want to make HTTP calls. So we're going to use Axios, which means we need to install
            it.</p>
          <p>
            So, back over in our console, on the tab that's running our Build-a-Bot app, let's go ahead and stop it. And
            then I'm going to npm install axios:</p>
          <figure>
            <img src="images/Fig05-079.png"/>
            <figcaption>Fig 05-079</figcaption>
          </figure>
          <p>And we'll save that. Okay, let's go ahead and start our server back up:</p>
          <figure>
            <img src="images/Fig05-080.png"/>
            <figcaption>Fig 05-080</figcaption>
          </figure>
          <p>And then back over in our app, we're going to go ahead and import Axios:</p>
          <figure>
            <img src="images/Fig05-081.png"/>
            <figcaption>Fig 05-081</figcaption>
          </figure>
          <p>And now down in our getParts function I can use Axios to get data. So I'm going to say axios.get:</p>
          <figure>
            <img src="images/Fig05-082.png"/>
            <figcaption>Fig 05-082</figcaption>
          </figure>
          <p>And then the axios.get function takes a URL for the endpoint that you want to hit. But what can we put
            here? Our API endpoint that we created is right here. So we could put http://localhost:8081/api/parts:</p>
          <figure>
            <img src="images/Fig05-083.png"/>
            <figcaption>Fig 05-083</figcaption>
          </figure>
          <p>
            But, of course, there are a couple of problems with this. First of all, we're going to get CORS issues if we
            do this because we're accessing a different port than what our application was running under. But also,
            localhost is not going to work in production. And in production, this is typically solved by hosting your
            application and your API on the same domain and port. But we don't have that luxury in development without
            some effort.</p>
          <p> That's not a problem though because Vue provides a way for us to configure a built-in proxy so that we can
            proxy the API through our dev server that our Vue app is being served from. This will solve our issues
            locally and enable us to just use a relative URL like this:</p>
          <figure>
            <img src="images/Fig05-084.png"/>
            <figcaption>Fig 05-084</figcaption>
          </figure>
          <p>So, in order for this to work we need to configure the Vue proxy to proxy our API. We can do that by
            creating a file at the root of our project named vue.config.j s. So I'm just going to right-click here and
            create a new file, vue.config.js:</p>
          <figure>
            <img src="images/Fig05-085.png"/>
            <figcaption>Fig 05-085</figcaption>
          </figure>
          <p>And then in here we just need to configure the proxy like this. So, we'll do a module.exports and we'll
            just export an object from here. And in here we'll just provide a devServer configuration. And we'll
            configure the proxy. And we want our proxy to be running at /api:</p>
          <figure>
            <img src="images/Fig05-086.png"/>
            <figcaption>Fig 05-086</figcaption>
          </figure>
          <p>So now we can configure this API to be proxied to where our server is running. So, the target for API is
            going to be http://localhost:8081:</p>
          <figure>
            <img src="images/Fig05-087.png"/>
            <figcaption>Fig 05-087</figcaption>
          </figure>
          <p>And then we just specify changeOrigin, and we'll set that to true.</p>
          <p>So this is actually webpack. config. And Vue, behind the scenes, is using the webpack-dev-server. So that's
            why we're using webpack. config here. So this is how you configure the webpack-dev-server.</p>
          <p>So now, we have a proxy running at /api that will proxy all requests from /api to http://localhost, port
            8081. So now this api/parts URL will get proxied to our API that's running on port 8081. So now that that's
            set up we can continue working on our action.</p>
          <p>So, when this axios call:</p>
          <figure>
            <img src="images/Fig05-088.png"/>
            <figcaption>Fig 05-088</figcaption>
          </figure>
          <p>finishes we want to commit the data to our store. But before we can do that we need to add a default value
            to our state. So up here I'm going to set parts by default to just null:</p>
          <figure>
            <img src="images/Fig05-089.png"/>
            <figcaption>Fig 05-089</figcaption>
          </figure>
          <p>
            Remember, anything that you add to your state you need to add here at a default value for it to start with.
            And, again, when this axios call finishes we want to mutate our state. But we can't do that directly. We do
            that through mutations. So let's add a mutation next for updateParts:</p>
          <figure>
            <img src="images/Fig05-090.png"/>
            <figcaption>Fig 05-090</figcaption>
          </figure>
          <p>And that takes in state and our parts. And then we'll just set state.parts equal to the parts being passed
            in here.</p>
          <p>Okay. And then notice something interesting with this mutation. ESLint is saying that we're violating the
            no-param-reassign rule:</p>
          <figure>
            <img src="images/Fig05-091.png"/>
            <figcaption>Fig 05-091</figcaption>
          </figure>
          <p>This rule says that you should never mutate a parameter that is passed in to a function. This helps avoid
            mutation-related bugs. However, Vue's whole change detection relies on mutations within the store. It's
            actually intended that you will mutate this state object when it's passed in. So for that reason, let's
            update our ESLint RC file to allow this.</p>
          <p>So, here we have our eslintrc.js file:</p>
          <figure>
            <img src="images/Fig05-092.png"/>
            <figcaption>Fig 05-092</figcaption>
          </figure>
          <p>And then right here in rules all we have to do is add another rule for no-param-reassign. And we'll set
            that to 0:</p>
          <figure>
            <img src="images/Fig05-093.png"/>
            <figcaption>Fig 05-093</figcaption>
          </figure>
          <p>And now ESLint should stop warning us. Yep, sure enough. Looks good now:</p>
          <figure>
            <img src="images/Fig05-094.png"/>
            <figcaption>Fig 05-094</figcaption>
          </figure>
          <p>Okay, so finally back to our action here. When our axios call finishes we want to then commit the data to
            the store. So, we'll take in our result here from our axios call and then we will call commit that we've
            de-structured there from our parameters. And we want to commit the updateParts mutation. And then we'll pass
            in the data that we get back from our API calls. So that will be result.data. So Axios returns a result
            object and it has a data object that has the payload that was returned.</p>
          <figure>
            <img src="images/Fig05-095.png"/>
            <figcaption>Fig 05-095</figcaption>
          </figure>
          <p>
            Okay, cool. And then in the event that an error occurs I'll catch it and then I'll just pass that to
            console.error:</p>
          <figure>
            <img src="images/Fig05-096.png"/>
            <figcaption>Fig 05-096</figcaption>
          </figure>
          <p>Of course, you might want to do something more useful than this in a real application, but for now I'll
            just log any errors to the console.</p>
          <p>Okay, so with all of this in place we use Axios to call our API:</p>
          <figure>
            <img src="images/Fig05-097.png"/>
            <figcaption>Fig 05-097</figcaption>
          </figure>
          <p>And then we commit:</p>
          <figure>
            <img src="images/Fig05-098.png"/>
            <figcaption>Fig 05-098</figcaption>
          </figure>
          <p>the returned data to our store:</p>
          <figure>
            <img src="images/Fig05-099.png"/>
            <figcaption>Fig 05-099</figcaption>
          </figure>
          <p>through the updateParts mutation:</p>
          <figure>
            <img src="images/Fig05-100.png"/>
            <figcaption>Fig 05-100</figcaption>
          </figure>
          <p>Okay, cool. So now wherever we need this data, we need to first dispatch to this action and then get the
            parts from the store instead of from the hard-coded parts. json file we're currently using.</p>
          <p>So, let's start in the RobotBuilder. So, first up here we are importing availableParts from this parts
            file:</p>
          <figure>
            <img src="images/Fig05-101.png"/>
            <figcaption>Fig 05-101</figcaption>
          </figure>
          <p>So let's delete that. And then in order to kick of the axios call we need to dispatch an action. And then
            we want to dispatch that action as soon as this component is created. So, let's go ahead and add a created
            hook:</p>
          <figure>
            <img src="images/Fig05-102.png"/>
            <figcaption>Fig 05-102</figcaption>
          </figure>
          <p>And then in here I'm going to access the store with this. $store. And then there's a new function we
            haven't used on the store yet and that's called dispatch. And we're just going to tell it to dispatch the
            getParts action:</p>
          <figure>
            <img src="images/Fig05-103.png"/>
            <figcaption>Fig 05-103</figcaption>
          </figure>
          <p>So you use commit to commit mutations and you use dispatch to kick off actions.</p>
          <p>Okay, so that will kick off our axios action, which is asynchronous. And then all we need to do is create a
            computed property that will return the parts from the store when the axios call is finished. So down here in
            computed, let's add a new computed property called availableParts. And this will just return
            this.$store.state.parts.</p>
          <figure>
            <img src="images/Fig05-104.png"/>
            <figcaption>Fig 05-104</figcaption>
          </figure>
          <p>Okay, and then this is just complaining because we have availableParts declared in two places. We don't
            need it in data anymore since it's now a computed prop:</p>
          <figure>
            <img src="images/Fig05-105.png"/>
            <figcaption>Fig 05-105</figcaption>
          </figure>
          <p>So our created lifecycle hook now dispatches the axios call and then once that's available this computed
            prop will get updated whenever that data returns. And now up here in our template, in all these places that
            we're calling availableParts:</p>
          <figure>
            <img src="images/Fig05-106.png"/>
            <figcaption>Fig 05-106</figcaption>
          </figure>
          <p>will now get availableParts from the computed property. Okay, so this is pretty much it. We've dispatched
            our call and then we're getting the data off the store after the action in the store has committed the data
            via a mutation. But we still have one problem.</p>
          <p>So if we come over here, you can see our build page is not rendering. And if we look in here we have
            errors:</p>
          <figure>
            <img src="images/Fig05-107.png"/>
            <figcaption>Fig 05-107</figcaption>
          </figure>
          <p>Notice that it says here Cannot read property "heads" of null. So back over here, That's right here:</p>
          <figure>
            <img src="images/Fig05-108.png"/>
            <figcaption>Fig 05-108</figcaption>
          </figure>
          <p>So it's saying that it cannot read property heads of null. So availableParts is null. And that's going to
            happen everywhere below where we're using availableParts also. Well, that's because over in our store here
            our default value for parts is null:</p>
          <figure>
            <img src="images/Fig05-109.png"/>
            <figcaption>Fig 05-109</figcaption>
          </figure>
          <p>And so, because our action is asynchronous, when the component first loads the store returns null for
            availableParts or for this parts property. And we could fix this in two different ways.</p>
          <p>We could provide an empty object as the default value in our store or we could prevent the RobotBuilder
            page from rendering until the availableParts is populated. I'm going to go with the later solution because
            the first solution would have some other cascading problems with an empty object.</p>
          <p>So, let's just use a v-if on this outer div here. And we will just say v-if, and we will only show this if
            availableParts is truthy:</p>
          <figure>
            <img src="images/Fig05-110.png"/>
            <figcaption>Fig 05-110</figcaption>
          </figure>
          <p>So this won't render if it's null. So this should be working now. If we come back over here and refresh.
            Okay, and now we're getting a 404 error:</p>
          <figure>
            <img src="images/Fig05-111.png"/>
            <figcaption>Fig 05-111</figcaption>
          </figure>
          <p>but that's just because when we created our proxy, updated our proxy config, we needed to restart our
            server. So I'm going to stop my server and start it again:</p>
          <figure>
            <img src="images/Fig05-112.png"/>
            <figcaption>Fig 05-112</figcaption>
          </figure>
          <p>And now let's go ahead and refresh here. There we go. No more errors here:</p>
          <figure>
            <img src="images/Fig05-113.png"/>
            <figcaption>Fig 05-113</figcaption>
          </figure>
          <p>And you can see that we are getting our robot parts just fine:</p>
          <figure>
            <img src="images/Fig05-114.png"/>
            <figcaption>Fig 05-114</figcaption>
          </figure>
          <p>And now it's coming from an API call. So if I look in Network over here and refresh this page, you can see
            that I made this call to port 8080/api/parts:</p>
          <figure>
            <img src="images/Fig05-115.png"/>
            <figcaption>Fig 05-115</figcaption>
          </figure>
          <p>and that got rewritten by our proxy server to port 8081. Alright, awesome. So we have now dispatched an
            action, which kicked off an asynchronous API call and then we're getting that data.</p>
          <p>Now we just need to update the other places in our app where we were importing that old parts.json file and
            use the action instead. So, let's start with these four files in the parts folder:</p>
          <figure>
            <img src="images/Fig05-116.png"/>
            <figcaption>Fig 05-116</figcaption>
          </figure>
          <p>So this is for the part info pages that display information about each of the parts. And these four files
            are very similar. And they're all going to need to dispatch the getParts action. And th en they'll each need
            to have a computer prop to get the parts off the store. And since that will be repeated across all four of
            these components, let's create a mixin to do it and then we'll reuse it.</p>
          <p>So, we'll create a new file and we'll name it get-parts-mixin.js:</p>
          <figure>
            <img src="images/Fig05-117.png"/>
            <figcaption>Fig 05-117</figcaption>
          </figure>
          <p>And then this will just export a component options object. And in here we'll add a created hook. And this
            will dispatch the getParts action:</p>
          <figure>
            <img src="images/Fig05-118.png"/>
            <figcaption>Fig 05-118</figcaption>
          </figure>
          <p>And then we just want a computed prop. And that computed prop will be called parts. And it will return
            this.$store.state.parts:</p>
          <figure>
            <img src="images/Fig05-119.png"/>
            <figcaption>Fig 05-119</figcaption>
          </figure>
          <p>And actually, I'd like this computed prop to do a little bit more than just this. I'd like to make it so
            that we don't have to do a v-if check in all of our components while we wait for the parts action to
            complete.</p>
          <p>So, we'll return the parts unless it's null. In which case, we'll return a default object. So, that default
            object will just look like this. It'll have heads, which is an empty array, arms, and torsos, and bases:</p>
          <figure>
            <img src="images/Fig05-120.png"/>
            <figcaption>Fig 05-120</figcaption>
          </figure>
          <p>Okay, so this is dispatching the getParts action and then returning parts from the store or a reasonable
            default object if the parts are not in the store. Okay, so let's just go use that mixin in each of these
            components. So, here in the robot arms we'll get rid of this import:</p>
          <figure>
            <img src="images/Fig05-121.png"/>
            <figcaption>Fig 05-121</figcaption>
          </figure>
          <p>And we can delete our data function:</p>
          <figure>
            <img src="images/Fig05-122.png"/>
            <figcaption>Fig 05-122</figcaption>
          </figure>
          <p>since our mixin is going to handle that via computed props. And let's go ahead and import our mixin,
            getPartsMixin from ./get-parts-mixin.</p>
          <figure>
            <img src="images/Fig05-123.png"/>
            <figcaption>Fig 05-123</figcaption>
          </figure>
          <p>Okay. And then our mixin we use down here by specifying mixins and passing that in in the array:</p>
          <figure>
            <img src="images/Fig05-124.png"/>
            <figcaption>Fig 05-124</figcaption>
          </figure>
          <p>Okay, and then up here we just need our v-for to loop over parts.arms instead of just arms:</p>
          <figure>
            <img src="images/Fig05-125.png"/>
            <figcaption>Fig 05-125</figcaption>
          </figure>
          <p>Okay, so now let's do the same thing for RobotBases. Specify the mixin. And then up here this will be
            parts.bases:</p>
          <figure>
            <img src="images/Fig05-126.png"/>
            <figcaption>Fig 05-126</figcaption>
          </figure>
          <p>And then same thing here in the RobotHeads:</p>
          <figure>
            <img src="images/Fig05-127.png"/>
            <figcaption>Fig 05-127</figcaption>
          </figure>
          <p>And then finally on RobotTorsos:</p>
          <figure>
            <img src="images/Fig05-128.png"/>
            <figcaption>Fig 05-128</figcaption>
          </figure>
          <p>There we go. Okay, so now all of these parts components are updated, and you can see how helpful a mixin
            was in this case. It's made these four components incredibly simple.</p>
          <p>And actually, we can use that mixin in one more place. This PartInfo component also needs parts. So we can
            get rid of this import here:</p>
          <figure>
            <img src="images/Fig05-129.png"/>
            <figcaption>Fig 05-129</figcaption>
          </figure>
          <p>and import the mixin instead:</p>
          <figure>
            <img src="images/Fig05-130.png"/>
            <figcaption>Fig 05-130</figcaption>
          </figure>
          <p>and add mixins:</p>
          <figure>
            <img src="images/Fig05-131.png"/>
            <figcaption>Fig 05-131</figcaption>
          </figure>
          <p>And then down here we just need to change this to this.parts since that's a computer prop now from our
            mixin:</p>
          <figure>
            <img src="images/Fig05-132.png"/>
            <figcaption>Fig 05-132</figcaption>
          </figure>
          <p>Okay, and that wraps up our changes. So now our whole application is getting parts data from the API via a
            Vuex action. And that means that we don't need this data folder anymore:</p>
          <figure>
            <img src="images/Fig05-133.png"/>
            <figcaption>Fig 05-133</figcaption>
          </figure>
          <p>Okay, cool. This should all be working now so let's go check it out. So our RobotBuilder page is working.
            And if I click on one of these parts you can see that this is working looking up the part information:</p>
          <figure>
            <img src="images/Fig05-134.png"/>
            <figcaption>Fig 05-134</figcaption>
          </figure>
          <p>And if I go to the parts/browse then you can see that I'm getting the heads information, arms information,
            torsos, and bases etc:</p>
          <figure>
            <img src="images/Fig05-135.png"/>
            <figcaption>Fig 05-135</figcaption>
          </figure>
          <p>
            Awesome. So that was a fair amount of work to retrofit our application to use the new action and API. But
            the amount of work that was actually involved in creating the action on our store, which we can see again
            over here:</p>
          <figure>
            <img src="images/Fig05-136.png"/>
            <figcaption>Fig 05-136</figcaption>
          </figure>
          <p>was not that much work. And accessing it in each of the components wasn't that much work either. Just felt
            like a lot of work because we were retrofitting a bunch of places. But you can see that creating actions and
            making asynchronous calls is actually pretty straight forward.</p>
          <p>So, in the next clip we'll take a look at how to use actions to save data to our API.
          </p>
        </div>
        <div><h3>Using Actions to Save Data to an API</h3>
          <p>
            We just learned how to use actions to retrieve data. Now let's look at using actions to save data to an API.
            The concept is fairly similar. We'll start by creating a new action in our store and we'll call it the
            addRobotToCart action:</p>
          <figure>
            <img src="images/Fig05-138.png"/>
            <figcaption>Fig 05-138</figcaption>
          </figure>
          <p>And again, we'll need the commit function. And then we'll also want to de-structure the state off of our
            contacts parameter. We'll use this here in a minute.</p>
          <p>And then unlike our getParts action, which doesn't take any other parameters, we're going to pass in a
            robot to our addRobotToCart action so that we can pass that along to our axios call and add it to our
            state:</p>
          <figure>
            <img src="images/Fig05-139.png"/>
            <figcaption>Fig 05-139</figcaption>
          </figure>
          <p>Okay, so our API takes in a fully populated cart. So, we're going to need to get the current cart off of
            the state, append this one, and then pass it to our API endpoint. So let's create a new cart variable, and
            we'll set that to an array, which contains all of the items from the old cart plus our new robot:</p>
          <figure>
            <img src="images/Fig05-140.png"/>
            <figcaption>Fig 05-140</figcaption>
          </figure>
          <p>Okay, so this is what our new cart looks like. Now let's save it to the API with an axios. post. And that
            hits the api/cart endpoint. And we are going to pass in our new cart:</p>
          <figure>
            <img src="images/Fig05-141.png"/>
            <figcaption>Fig 05-141</figcaption>
          </figure>
          <p>So we're posting to the api/cart endpoint and then we're passing the cart object as the body. And when this
            post finishes I want to update my local Vuex state to include the robot that was saved, but I don't want to
            do that until the axios. post is successful. And we need to add it to our local state. Otherwise, we'll save
            it to the server, but our app won't reflect that we have a new item in our cart.</p>
          <p>So, let's go ahead and add a.then here:</p>
          <figure>
            <img src="images/Fig05-142.png"/>
            <figcaption>Fig 05-142</figcaption>
          </figure>
          <p>So axios post returns a promise. And then we basically want to just call our addToCart mutation to add this
            robot to the cart. If you remember, we do that with commit. So, I'm going to create a new function here:</p>
          <figure>
            <img src="images/Fig05-143.png"/>
            <figcaption>Fig 05-143</figcaption>
          </figure>
          <p>And this function is just going to call commit and commit an addRobotToCart mutation. And that needs the
            robot to be added.</p>
          <p>Okay, so now we have an action that will save our robot to the cart on the server and then also insert it
            into the cart on our local store after that succeeds. Now we just need to call the action.</p>
          <p>So we'll do that over here in our RobotBuilder. So we have our addToCart function here. And right now, the
            addToCart method is just calling the commit function on the store to commit a mutation:</p>
          <figure>
            <img src="images/Fig05-144.png"/>
            <figcaption>Fig 05-144</figcaption>
          </figure>
          <p>And we want to use our action now. So instead of commit we'll use dispatch:</p>
          <figure>
            <img src="images/Fig05-145.png"/>
            <figcaption>Fig 05-145</figcaption>
          </figure>
          <p>And we'll now dispatch the addRobotToCart action instead of calling the mutation. And the rest of this is
            just the same. So we're calling the addRobotToCart action and we're passing in the robot to add.</p>
          <p>So basically, the only difference between calling a mutation and an action is that you commit mutations
            whereas you dispatch actions. Okay, let's go check out how our app is working now.</p>
          <p>So, if you watch this indicator up here on the cart, when I click Add to Cart you'll notice that there is
            now a delay as it makes the call to the server:</p>
          <figure>
            <img src="images/Fig05-146.png"/>
            <figcaption>Fig 05-146</figcaption>
          </figure>
          <p>And then only when it succeeds do we add it to our cart locally. And then if I open my dev tools and on the
            Network tab I click the Add to Cart button again then you can see that we're calling the api/cart
            endpoint:</p>
          <figure>
            <img src="images/Fig05-147.png"/>
            <figcaption>Fig 05-147</figcaption>
          </figure>
          <p>
            And down here, you can see that for the payload we are passing along the cart array. Excellent. We're now
            using an action to save data to our API. In the next clip, we'll see how to tap in to the promises that are
            returned by actions.
          </p>
        </div>
        <div><h3>Returning Promises from Actions</h3>
          <p>
            If we look at our addToCart method in our RobotBuilder:</p>
          <figure>
            <img src="images/Fig05-148.png"/>
            <figcaption>Fig 05-148</figcaption>
          </figure>
          <p>we're dispatching an action, but we have no idea here when it finishes. What I would like to do is redirect
            to the cart page after adding the robot to the cart succeeds. But how can I know when the action has
            completed successfully?</p>
          <p>Well, over here in the store in our addRobotToCart action, all we have to do is return this axios.post
            call:</p>
          <figure>
            <img src="images/Fig05-149.png"/>
            <figcaption>Fig 05-149</figcaption>
          </figure>
          <p>Axios.post returns a promise and we can return that from our action. And now that this returns a promise
            over here in the RobotBuilder.vue addToCart method, I can add a .then to my dispatch call:</p>
          <figure>
            <img src="images/Fig05-150.png"/>
            <figcaption>Fig 05-150</figcaption>
          </figure>
          <p>And so when that action completes successfully then I'm going to call this.$router.push. And I'm just going
            to navigate to the cart URL.</p>
          <p>
            And now when I add an item to my cart you can see that there's a little bit of a delay as it goes out to the
            server. And then when it succeeds it navigates to my cart page:</p>
          <figure>
            <img src="images/Fig05-151.png"/>
            <figcaption>Fig 05-151</figcaption>
          </figure>
          <p>So, even though we're calling dispatch here, we're not actually calling our addRobotToCart function
            directly, the promise return from our action still gets returned to us from this dispatch call, making it
            easy to respond to the asynchronous event when it finishes or even to catch errors when it fails.</p>
          <p>So that was easy. Next, we'll take a look at how to organize our store into modules.
          </p>
        </div>
        <div><h3>Organizing the Store with Modules</h3>
          <p>So far, we've been adding all of our actions, mutations, getters, and state objects to the single store
            file. This has been fine for this small application, but imagine a larger application with dozens or even
            hundreds or thousands of items in it. A single file would quickly become unmanageable. This is where modules
            come in. They allow us to break up a single store into multiple modules for maintainability. </p>
          <p>So let's imagine that our application had need for some other actions in here related to users, such as a
            sign-in action for example. We could change our store to have two modules, a robots module and a users
            module. So let's create a robots module, that's easy.</p>
          <p>First we'll create a modules folder inside our store folder. And then we'll create a new file for our
            module. I'll call it robots.js:</p>
          <figure>
            <img src="images/Fig05-152.png"/>
            <figcaption>Fig 05-152</figcaption>
          </figure>
          <p>And then I'm going to move all of this that is all related to robots, starting with state all the way down
            to my getters:</p>
          <figure>
            <img src="images/Fig05-153.png"/>
            <figcaption>Fig 05-153</figcaption>
          </figure>
          <p>I'm going to cut that out of here. And then over here in robots.js I'll export a different object:</p>
          <figure>
            <img src="images/Fig05-154.png"/>
            <figcaption>Fig 05-154</figcaption>
          </figure>
          <p>and I'll paste that in here:</p>
          <figure>
            <img src="images/Fig05-155.png"/>
            <figcaption>Fig 05-155</figcaption>
          </figure>
          <p>And we'll need our axios import. And we won't need it over here in index.js anymore so I'll move it from
            here and import it here in robots.js:</p>
          <figure>
            <img src="images/Fig05-156.png"/>
            <figcaption>Fig 05-156</figcaption>
          </figure>
          <p>And then back in my store file I'll import my new robots module:</p>
          <figure>
            <img src="images/Fig05-157.png"/>
            <figcaption>Fig 05-157</figcaption>
          </figure>
          <p>So import robotsModule from modules/robots. And then finally, in my configuration object down here for my
            store, I'll just add a modules section.:</p>
          <figure>
            <img src="images/Fig05-158.png"/>
            <figcaption>Fig 05-158</figcaption>
          </figure>
          <p>And then you just add a property for each of the modules. So I'm going to create a robots module and that
            will use my new robotsModule:</p>
          <figure>
            <img src="images/Fig05-159.png"/>
            <figcaption>Fig 05-159</figcaption>
          </figure>
          <p>Okay, we'll come back and add a users module in just a sec. But for now, let's go take a look at our site.
            Okay, this is not looking great. So, if we look at our console:</p>
          <figure>
            <img src="images/Fig05-160.png"/>
            <figcaption>Fig 05-160</figcaption>
          </figure>
          <p>you can see that we are getting this error, Cannot read property "length" of undefined. And that's
            happening in our App component. So, if we come back over here and look at our App component, we come up to
            the template up here. That error is occurring right here where we're trying to show the number of items in
            the cart:</p>
          <figure>
            <img src="images/Fig05-161.png"/>
            <figcaption>Fig 05-161</figcaption>
          </figure>
          <p>So the problem is that the cart is undefined here. And if we go down to our computer property for that you
            can see that we're getting it from this.$store.state.cart:</p>
          <figure>
            <img src="images/Fig05-162.png"/>
            <figcaption>Fig05-162</figcaption>
          </figure>
          <p>But we just added a robots module. And if we go look at that robots module you can see that the cart is in
            the robots module state:</p>
          <figure>
            <img src="images/Fig05-163.png"/>
            <figcaption>Fig 05-163</figcaption>
          </figure>
          <p>not in our root store state. And so, over here in App.vue we need to access our cart with
            state.robots.cart:</p>
          <figure>
            <img src="images/Fig05-164.png"/>
            <figcaption>Fig 05-164</figcaption>
          </figure>
          <p>Notice that robots matches the name that we gave our module over here on line 10:</p>
          <figure>
            <img src="images/Fig05-165.png"/>
            <figcaption>Fig 05-165</figcaption>
          </figure>
          <p>Okay, so that should fix our error. And you see our site's rendering. If I refresh we have no errors
            here:</p>
          <figure>
            <img src="images/Fig05-166.png"/>
            <figcaption>Fig 05-166</figcaption>
          </figure>
          <p>
            So we're now working fine again. And we are accessing the cart through our robots module.</p>
          <p>So I want to call out something important here and that is that we still have a single state tree or a
            single state object. So we still have a single state object:</p>
          <figure>
            <img src="images/Fig05-167.png"/>
            <figcaption>Fig 05-167</figcaption>
          </figure>
          <p>and on that state object we have a robots module:</p>
          <figure>
            <img src="images/Fig05-168.png"/>
            <figcaption>Fig 05-168</figcaption>
          </figure>
          <p>Okay, so we've fixed this here, but there are actually several places in our app that we need to fix this.
            And right now, everything is in the robots module. So I'm going to undo the change we made in Fig 05-168 and
            then I'm going to do a global search and replace, which you can do by hitting Ctrl+Shift+H if you're using
            VS code. And I'm going to replace this.$store.state with this.$store.state.robots:</p>
          <figure>
            <img src="images/Fig05-169.png"/>
            <figcaption>Fig 05-169</figcaption>
          </figure>
          <p>And that should be good. Then I'm going to go ahead and replace everything here. Oh, you have to execute
            the search first and then I will replace everything. There we go. So that updated four occurrences across
            four files.</p>
          <p>So now everything that was accessing state is now accessing the robots state, which is where all of our
            state currently is. Okay, so now everywhere on our site should be working. We get our robot parts and we can
            add to the cart. And we're getting our cart data here:</p>
          <figure>
            <img src="images/Fig05-170.png"/>
            <figcaption>Fig 05-170</figcaption>
          </figure>
          <p>And that data's all coming through the state in our robots module. Now, you might be wondering about the
            fact that we have fixed everywhere where we're accessing state, but we didn't go in and add robots to the
            places where we're calling actions and mutations and getters. We'll talk about that more in the next module,
            but just realize that state is a little bit different than those other pieces of the store when it comes to
            modules. Okay, so just keep that in mind.</p>
          <p> Now, back over in our store we currently have a single robots module. In order to see just what it looks
            like if you have two modules and also to set us up for working with namespaced modules in our next clip,
            let's add a second module. We'll call that users:</p>
          <p>So, I'm going to hit Ctrl+Shift+E to get my explorer back here. And then in my modules folder I'm going to
            create a new file and that will be users.js:</p>
          <figure>
            <img src="images/Fig05-171.png"/>
            <figcaption>Fig 05-171</figcaption>
          </figure>
          <p>And then we'll get the contents of this from our GitHub repo. So over here in the repo I'm going to click
            on src and then store/modules and users. And let's grab the contents of that and paste it in here:</p>
          <figure>
            <img src="images/Fig05-172.png"/>
            <figcaption>Fig 05-172</figcaption>
          </figure>
          <p>
            Alright, now we have a users module, and notice that it has a sign-in action:</p>
          <figure>
            <img src="images/Fig05-173.png"/>
            <figcaption>Fig 05-173</figcaption>
          </figure>
          <p>And the sign-in action commits the updateCurrentUser mutation:</p>
          <figure>
            <img src="images/Fig05-174.png"/>
            <figcaption>Fig 05-174</figcaption>
          </figure>
          <p>And that mutation just puts the user returned from the axios call on the state.</p>
          <p>By the way, it's worth mentioning that with async/await it's expected that in the future mutations and
            actions will be combined into a single action. But for now, they're separate.</p>
          <p>Now, don't worry too much about what's happening in this users module. We just needed a couple of modules
            to demonstrate a few things. So let's go add this to the store. So back here in our store we will import it.
            We'll just copy this one and we will import the usersModule from modules/users:</p>
          <figure>
            <img src="images/Fig05-175.png"/>
            <figcaption>Fig 05-175</figcaption>
          </figure>
          <p>And then we can just add that down here:</p>
          <figure>
            <img src="images/Fig05-176.png"/>
            <figcaption>Fig 05-176</figcaption>
          </figure>
          <p>So we'll create a users module and paste in usersModule here. Okay, and this is it. So we now have a store
            with multiple modules in it.</p>
          <p>And in the next clip we're going to take a look at namespacing our modules, which will separate these two
            even further from each other.
          </p>
        </div>
        <div><h3>Namespacing Modules</h3>
          <p>There are a few nuances to working with modules in the store that we should cover. First of all, let's take
            a look at how actions are dispatched. If we take a look at the RobotBuilder component, you can see that when
            we add an item to the cart we dispatch this addRobotToCart method:</p>
          <figure>
            <img src="images/Fig05-177.png"/>
            <figcaption>Fig 05-177</figcaption>
          </figure>
          <p>And you can see in the app that this is working. So if I click Add to Cart then the robot does indeed get
            added to the cart:</p>
          <figure>
            <img src="images/Fig05-178.png"/>
            <figcaption>Fig 05-178</figcaption>
          </figure>
          <p>But if you look at our store we have two modules, right? And they each have their own set of actions. So
            robots has a set of actions here:</p>
          <figure>
            <img src="images/Fig05-179.png"/>
            <figcaption>Fig 05-179</figcaption>
          </figure>
          <p>and users has a set of actions here:</p>
          <figure>
            <img src="images/Fig05-180.png"/>
            <figcaption>Fig 05-180</figcaption>
          </figure>
          <p>And if you think about this for a moment you might wonder how in the world is this dispatch:</p>
          <figure>
            <img src="images/Fig05-181.png"/>
            <figcaption>Fig 05-181</figcaption>
          </figure>
          <p>working because we never told it which module to dispatch this action to. We updated all of our state calls
            to get data from the robots module, but we didn't update any of our dispatch calls. How in the world did Vue
            know that the robots module should be the one to handle this? Well, the answer is Vue didn't know.</p>
          <p>As we have it configured now, both modules will respond to this dispatched action as long as they have an
            action that corresponds to this addRobotToCart name. We can demonstrate this by adding an action to the
            users module. So right here:</p>
          <figure>
            <img src="images/Fig05-182.png"/>
            <figcaption>Fig 05-182</figcaption>
          </figure>
          <p>I'm going to create an addRobotToCart method. And we'll just have that log to the console so that we can
            see that it's getting called. So I'll add that to console. log, and I'm just going to say Users
            addRobotToCart called.</p>
          <p>Alright, so now if we come back over here to our builder and open our console, now you can see that if I
            click the Add to Cart button it did get added to the cart:</p>
          <figure>
            <img src="images/Fig05-183.png"/>
            <figcaption>Fig 05-183</figcaption>
          </figure>
          <p>So, it had to have gone through the robots module to do that. But it also logged to the console the "Users
            addRobotToCart called".</p>
          <p>So you might be asking yourself what good are Vuex modules then if it doesn't keep things separated?
            Especially in a larger application, you could easily make the mistake of giving two actions in different
            modules the same name and not even realize it.</p>
          <p>Well, don't worry. Vue can keep them separated if we tell it to. That's where namespaced modules come into
            play. So, over here in our robots module I am going to set it to be a namespaced module by just setting here
            namespaced to true:</p>
          <figure>
            <img src="images/Fig05-184.png"/>
            <figcaption>Fig 05-184</figcaption>
          </figure>
          <p>So now over here in the robots module I need to add the namespace to the action name that I'm dispatching.
            So this will be robots/addRobotToCart:</p>
          <figure>
            <img src="images/Fig05-185.png"/>
            <figcaption>Fig 05-185.png</figcaption>
          </figure>
          <p>I need to change this for all of my actions throughout the app. So, let's do this in a global search and
            replace again. So I'll hit Ctrl+Shift+H. And again, since the robots module is the only one that we're
            using, that we're dispatching actions to, I can just update all of my dispatches. So this is going to
            replace this. $store. dispatch with an apostrophe. We'll replace that with this. $store. dispatch with an
            apostrophe and then we will prefix everything with robots/:</p>
          <figure>
            <img src="images/Fig05-186.png"/>
            <figcaption>Fig 05-186</figcaption>
          </figure>
          <p>Make sure you get all of the periods and apostrophes and everything here correctly. And then I'll execute
            that search and do that replace. Okay, and then let's just make sure we do a Save All after that.</p>
          <p>Alright, now if we go back to our app here, and now if we go add another robot to our cart you can see it
            got added to the cart but it did not log the message from the users module:</p>
          <figure>
            <img src="images/Fig05-187.png"/>
            <figcaption>Fig 05-187</figcaption>
          </figure>
          <p>So now we are successfully only dispatching items from the namespaced robots module.</p>
          <p>Okay, so it's important to note here, I mentioned this earlier and I'll probably mention it again, so the
            state on a module is always namespaced whether the module is namespaced or not. You may remember that when
            we first added our robots module we had to immediately go and add robots. to everywhere where we were
            accessing the state. And that was before we namespaced this module. So state is always namespaced even if
            your module is not set to namespaced.</p>
          <p>But mutations, actions, and getters are only namespaced if you set namespaced to true. That caught me up a
            few times when I was first learning Vue so that's important to note. Okay, so now we know how to create a
            namespace module and who accessed the actions on namespaced modules.</p>
          <p>Next let's take a look at how to access namespaced getters.
          </p>
        </div>
        <div><h3>Accessing Namespaced Getters</h3>
          <p>If you remember on our cart page, we're displaying down here:</p>
          <figure>
            <img src="images/Fig05-188.png"/>
            <figcaption>Fig 05-188</figcaption>
          </figure>
          <p>any robots that are currently on sale. But that's actually broken currently. If we go add a robot that's on
            sale, like this friendly robot:</p>
          <figure>
            <img src="images/Fig05-189.png"/>
            <figcaption>Fig 05-189</figcaption>
          </figure>
          <p>to our cart and then come over here, you can see that it's not showing up down here:</p>
          <figure>
            <img src="images/Fig05-190.png"/>
            <figcaption>Fig 05-190</figcaption>
          </figure>
          <p>This is because we namespaced our robots module. But we never actually updated the way that we're accessing
            the getter right here:</p>
          <figure>
            <img src="images/Fig05-191.png"/>
            <figcaption>Fig 05-191</figcaption>
          </figure>
          <p>And if you look at the way we're accessing state up here:</p>
          <figure>
            <img src="images/Fig05-192.png"/>
            <figcaption>Fig 05-192</figcaption>
          </figure>
          <p>you might think that we would access it the same way. And we could just say robots right here:</p>
          <figure>
            <img src="images/Fig05-193.png"/>
            <figcaption>Fig 05-193</figcaption>
          </figure>
          <p>But getters.robots is not actually defined. You have to actually access getters using this notation here
            where we use a string to access the property and then we preface the name of the getter with robots/:</p>
          <figure>
            <img src="images/Fig05-194.png"/>
            <figcaption>Fig 05-194</figcaption>
          </figure>
          <p>So now if we go take a look at our cart you can see that we are getting our sale robot down here:</p>
          <figure>
            <img src="images/Fig05-195.png"/>
            <figcaption>Fig 05-195</figcaption>
          </figure>
          <p>So our getter is working now. So, a slightly different syntax for accessing getters in namespace
            modules.</p>
          <p>
            Next, let's take a closer look at how our Vuex state is structured and used inside of our modules when using
            namespace modules.
          </p>
        </div>
        <div><h3>Understanding Global and Namespaced State</h3>
          <p>
            We've discussed how we have one single state tree or state object, but to remind ourselves of how that state
            is structured let's add a couple of variables to our state. First, we'll add a state object on our root
            store config:</p>
          <figure>
            <img src="images/Fig05-196.png"/>
            <figcaption>Fig 05-196</figcaption>
          </figure>
          <p>So, we add state here and then we're going to put a variable in here call foo. And it will just be set to
            root-foo. Okay, so we now have a foo property in our store. And this is called the root state because it's
            not in a namespaced module. So it's part of the root state. And actually, any state that you add to
            non-namespaced modules is also part of the root state.</p>
          <p>Now let's add this same property to the other modules. So, we'll add a foo property here, but it will be
            set to robots-foo:</p>
          <figure>
            <img src="images/Fig05-197.png"/>
            <figcaption>Fig 05-197</figcaption>
          </figure>
          <p>And then we'll do the same thing in the users module. This will be called users-foo:</p>
          <figure>
            <img src="images/Fig05-198.png"/>
            <figcaption>Fig 05-198</figcaption>
          </figure>
          <p>Okay, and then let's do something similar with a getter at each level. So in our root store let's add a
            getter. So we need a getters section:</p>
          <figure>
            <img src="images/Fig05-199.png"/>
            <figcaption>Fig 05-199</figcaption>
          </figure>
          <p>And we'll create a foo getter. And we will return root-getter/ and then the value from the state property,
            state.foo:</p>
          <figure>
            <img src="images/Fig05-200.png"/>
            <figcaption>Fig 05-200</figcaption>
          </figure>
          <p>So this is just prepending root-getter to that string and returning it. Now let's do the same thing for
            getters in the robots module. So down here we'll add a foo-getter, but it will prepend robots-getter:</p>
          <figure>
            <img src="images/Fig05-201.png"/>
            <figcaption>Fig 05-201</figcaption>
          </figure>
          <p>And then we'll do the same thing for users:</p>
          <figure>
            <img src="images/Fig05-202.png"/>
            <figcaption>Fig 05-202</figcaption>
          </figure>
          <p>So right here in getters we'll add a foo getter and it will prepend users-getter.</p>
          <figure>
            <img src="images/Fig05-203.png"/>
            <figcaption>Fig 05-203</figcaption>
          </figure>
          <p>Okay, so now we have a foo property on the state at each level and a foo-getter at each level. This will
            help us demonstrate some interesting things about how state works across different modules. </p>
          <p>So, let's go print those out in our App component here, and we'll put it right here at the top. So I'm just
            going to print each of these out like this:</p>
          <figure>
            <img src="images/Fig05-204.png"/>
            <figcaption>Fig 05-204</figcaption>
          </figure>
          <p>So you can see that here I'm printing out each of the foo properties from the state. And then down here I'm
            going to print out each of the foo getters from the state in each of the modules. So we'll need some
            computed props for that. So down here in computed I'm going to create a rootFoo computed property:</p>
          <figure>
            <img src="images/Fig05-205.png"/>
            <figcaption>Fig 05-205</figcaption>
          </figure>
          <p>And that will return this.$state.foo.</p>
          <p>And then we'll do the same thing for each of the modules. So robotsFoo, and the same thing for
            usersFoo:</p>
          <figure>
            <img src="images/Fig05-206.png"/>
            <figcaption>Fig 05-206</figcaption>
          </figure>
          <p>
            Okay, and now I just need computed props for each of the getters. So I'm going to have a rootGetterFoo going
            to return this.$store.getters.foo, the same thing for robots but it will return this.$store.getters and the
            string syntax robots/foo. And then same thing for users:</p>
          <figure>
            <img src="images/Fig05-207.png"/>
            <figcaption>Fig 05-207</figcaption>
          </figure>
          <p>Okay, so let's go take a look at this, see what it looks like. Okay. So there's something interesting at
            the top here in these first three variables that we're printing out:</p>
          <figure>
            <img src="images/Fig05-208.png"/>
            <figcaption>Fig 05-208</figcaption>
          </figure>
          <p>So these are the items that we got directly off of state. Notice that users does indeed have its own
            namespaced state even though it is not a namespace module. So, in our App component we're accessing it with
            this.$store.state.users.foo:</p>
          <figure>
            <img src="images/Fig05-209.png"/>
            <figcaption>Fig 05-209</figcaption>
          </figure>
          <p>which is a thing. So, even though users is not a namespace module it does have its own namespaced state. So
            again, just a reminder that state is always namespaced in a module even if the module itself is not set to
            be namespaced:</p>
          <p>And then another point to make is that root state is not inherited by modules. And so if I get rid of this
            foo property here:</p>
          <figure>
            <img src="images/Fig05-210.png"/>
            <figcaption>Fig 05-210</figcaption>
          </figure>
          <p>and save it on the users module and then come back and look at this it is empty:</p>
          <figure>
            <img src="images/Fig05-211.png"/>
            <figcaption>Fig 05-211</figcaption>
          </figure>
          <p>So, this.$store.state.users.foo is not set to anything. So it is not inherited from the root state. Now
            let's go ahead and put that back:</p>
          <figure>
            <img src="images/Fig05-212.png"/>
            <figcaption>Fig 05-212</figcaption>
          </figure>
          <p>Okay, so let's come back and look at this. And let's look at the getters:</p>
          <figure>
            <img src="images/Fig05-213.png"/>
            <figcaption>Fig 05-213</figcaption>
          </figure>
          <p>So first of all, notice that the users getter did not return anything. And that's because in our App
            module, in the computed prop, we were accessing it with this.$store.getters users/foo:</p>
          <figure>
            <img src="images/Fig05-214.png"/>
            <figcaption>Fig 05-214</figcaption>
          </figure>
          <p>And so, we're trying to access a namespaced getter on a module that is not namespaced. So that's not too
            surprising that that's not showing up. But what might be surprising is if we look at the console here:</p>
          <figure>
            <img src="images/Fig05-215.png"/>
            <figcaption>Fig 05-215</figcaption>
          </figure>
          <p>you can see that we're getting this error, duplicate getter key: foo. This is because the users module and
            the root store are sharing the same namespace. And yet over here you can see that we've created, in our
            users module, a foo getter:</p>
          <figure>
            <img src="images/Fig05-216.png"/>
            <figcaption>Fig 05-216</figcaption>
          </figure>
          <p>And we also have, on our root store, a foo getter:</p>
          <figure>
            <img src="images/Fig05-217.png"/>
            <figcaption>Fig 05-217</figcaption>
          </figure>
          <p>And so, we're getting an error because we've created a getter with the same name in two different places
            that share the same namespace, specifically the root namespace. So let's see what happens if we get rid of
            this getter that's at the root level.</p>
          <figure>
            <img src="images/Fig05-218.png"/>
            <figcaption>Fig 05-218</figcaption>
          </figure>
          <p>And so now if we go back to here it shouldn't be too surprising that when we called the root getter we got
            the users getter value:</p>
          <figure>
            <img src="images/Fig05-219.png"/>
            <figcaption>Fig 05-219</figcaption>
          </figure>
          <p>And so, in our computed property in our App module, the root getter is calling this.$store.getters.foo:</p>
          <figure>
            <img src="images/Fig05-220.png"/>
            <figcaption>Fig 05-220</figcaption>
          </figure>
          <p>
            And in the users computed property we're calling getters users/foo. And we've already talked about that this
            is not a thing. This is not defined. So it's interesting that the root getter is getting the value from the
            users module:</p>
          <figure>
            <img src="images/Fig05-221.png"/>
            <figcaption>Fig 05-221</figcaption>
          </figure>
          <p>And that's because this is not a namespaced module and so its getters are shared with the root store. And
            so, the root store doesn't have a getter, but we added one in the users module which technically means we're
            adding that to the root namespace. And so when we requested the foo getter from the root namespace it
            retrieved the one in Fig 05-221 even though it was defined in the users module. </p>
          <p>Okay, now let's explore something else with this getter. So, I'm going to remove this foo property off of
            our users state:</p>
          <figure>
            <img src="images/Fig05-222.png"/>
            <figcaption>Fig 05-222</figcaption>
          </figure>
          <p>and then I'm going to come back over here. And let's see what we're getting:</p>
          <figure>
            <img src="images/Fig05-223.png"/>
            <figcaption>Fig 05-223</figcaption>
          </figure>
          <p>Okay, so now when we call the foo getter we're getting users-getter/undefined. And so that's kind of
            interesting because we've already established that we would get into this getter here:</p>
          <figure>
            <img src="images/Fig05-224.png"/>
            <figcaption>Fig 05-224</figcaption>
          </figure>
          <p>because we don't have one defined on the root and they're shared. But why is state.foo undefined?</p>
          <p>If the users module is not namespaced why are we not getting the value here from state.foo:</p>
          <figure>
            <img src="images/Fig05-225.png"/>
            <figcaption>Fig 05-225</figcaption>
          </figure>
          <p>Well, remember, state is always namespaced. And the state that's passed in to getters and other places like
            actions and mutations:</p>
          <figure>
            <img src="images/Fig05-226.png"/>
            <figcaption>Fig 05-226</figcaption>
          </figure>
          <p>within the module, it is always that local module's state. And so this is trying to get state.foo off of
            our users module and there is nothing. And so that is printing undefined</p>
          <p>So that's the other important point is that the state that's passed in to mutations, getters, and actions
            is always the local state from that module. But what if we did want to access the root state from this
            getter:</p>
          <figure>
            <img src="images/Fig05-227.png"/>
            <figcaption>Fig 05-227</figcaption>
          </figure>
          <p>Well, that's available to us as the third parameter in our getter function. So, the second parameter is the
            getters and the third parameter is rootState:</p>
          <figure>
            <img src="images/Fig05-228.png"/>
            <figcaption>Fig 05-228</figcaption>
          </figure>
          <p>So, in a non-namespace module this is all the getters in the entire store including getters from namespace
            modules. In a namespace module, these getters are only the local getters in case you need access to them
            inside another getter.</p>
          <p>And then we have the rootState. So let's use that here.</p>
          <figure>
            <img src="images/Fig05-229.png"/>
            <figcaption>Fig 05-229</figcaption>
          </figure>
          <p>Okay, and now if we go take a look at this, there we go:</p>
          <figure>
            <img src="images/Fig05-230.png"/>
            <figcaption>Fig 05-230</figcaption>
          </figure>
          <p> Perfect. So we are now getting --- From the getter inside the users modules we are now getting the value
            from the rootState. And that remains true even if we come back over here and put a foo property on here set
            to users-foo:</p>
          <figure>
            <img src="images/Fig05-231.png"/>
            <figcaption>Fig 05-231</figcaption>
          </figure>
          <p>Over here, you can see we're still getting root-foo:</p>
          <figure>
            <img src="images/Fig05-232.png"/>
            <figcaption>Fig 05-232</figcaption>
          </figure>
          <p>and that's because we're using the rootState here:</p>
          <figure>
            <img src="images/Fig05-233.png"/>
            <figcaption>Fig 05-233</figcaption>
          </figure>
          <p>And everything that we've said here about getters is also true of actions and mutations except that
            rootState is not actually available to mutations. So it is not passed in to mutation functions.</p>
          <p>But in an action, I can get access to rootState by de-structuring it just like we do everything else off of
            the context object. And then you can access rootState here:</p>
          <figure>
            <img src="images/Fig05-234.png"/>
            <figcaption>Fig 05-234</figcaption>
          </figure>
          <p> But we don't have a need for that so we'll remove it. So as a reminder, rootState is not actually
            available to mutations. There's been some discussion about whether it should be added, but for now if you
            need access to the rootState in a mutation do it in an action, not the mutation.</p>
          <p>Hopefully this has helped create a little bit more clarity around some of the nuances with what data and
            methods exist where in a namespaced and non-namespaced modules.</p>
          <p>Next, we're going to take a look at some helper functions that Vuex provides to make it a little less
            verbose to access items from the store in our components.
          </p>
        </div>
        <div><h3>Using the Vuex MapState Helper</h3>
          <p>
            If we take a look at the methods that we just added on our app component you can see that there's a lot of
            boilerplate here just to get these three props off of state:</p>
          <figure>
            <img src="images/Fig05-235.png"/>
            <figcaption>Fig 05-235</figcaption>
          </figure>
          <p>Vuex provides a mapState helper to simplify this. So let's import that helper:</p>
          <figure>
            <img src="images/Fig05-236.png"/>
            <figcaption>Fig 05-236</figcaption>
          </figure>
          <p>So up here I'm just going to import mapState from Vuex. And then we can just use mapState right down here
            in the computed section. So, the most simple form of mapState looks like this. So you spread the results of
            calling the mapState function and then we pass along to that an array of strings:</p>
          <figure>
            <img src="images/Fig05-237.png"/>
            <figcaption>Fig 05-237</figcaption>
          </figure>
          <p>So this is basically saying take the foo property off of the rootState and provide it as a computed prop
            with the same name. So it basically replaces this syntax down here:</p>
          <figure>
            <img src="images/Fig05-238.png"/>
            <figcaption>Fig 05-238</figcaption>
          </figure>
          <p>except that we're actually renaming this property to rootFoo. If you want to give your computed prop a
            different name than what it's called in the state, like rootFoo in this case, then you need to use an object
            syntax instead of the simple array syntax. And if I had additional props here with the array syntax I could
            just add the other props here. But if I want to rename it I need to use a different syntax. So instead of an
            array I'm going to use an object:</p>
          <figure>
            <img src="images/Fig05-239.png"/>
            <figcaption>Fig 05-239</figcaption>
          </figure>
          <p>and I'm going to set to rootFoo on that object to foo. So this is a short-hand syntax that now is exactly
            equivalent to the syntax below. So we can remove this:</p>
          <figure>
            <img src="images/Fig05-240.png"/>
            <figcaption>Fig 05-240</figcaption>
          </figure>
          <p>We'll just need a comma here. Okay, but what about this robot's foo? We would like to be able to just say
            robotsFoo here, but what would we pass in here:</p>
          <figure>
            <img src="images/Fig05-241.png"/>
            <figcaption>Fig 05-241</figcaption>
          </figure>
          <p>since this is coming from the robots module? Unfortunately, this requires a little bit more verbose syntax.
            So, we set this to a function and then we can pull whatever off the state we want to like this:</p>
          <figure>
            <img src="images/Fig05-242.png"/>
            <figcaption>Fig 05-242</figcaption>
          </figure>
          <p>And then we can delete this right here:</p>
          <figure>
            <img src="images/Fig05-243.png"/>
            <figcaption>Fig 05-243</figcaption>
          </figure>
          <p>So now we have our mapState function boiled down to just a single line, whereas it was six lines before.
            Granted this is wrapping and, frankly, we should probably clean this up by moving this down here like
            this:</p>
          <figure>
            <img src="images/Fig05-244.png"/>
            <figcaption>Fig 05-244</figcaption>
          </figure>
          <p>
            So that syntax is a little bit more verbose when you are working with modules, but you can see this is still
            a lot cleaner than it was when it was two separate properties and we were using six lines. But actually,
            there's another syntax that we can use when working with modules. So let's use this other method for this
            usersFoo property.</p>
          <p>So I'm just going to use a second mapState call here, but this time the first parameter is going to be the
            name of the module:</p>
          <figure>
            <img src="images/Fig05-245.png"/>
            <figcaption>Fig 05-245</figcaption>
          </figure>
          <p>So now this mapState function will work with anything on the users module. And since we're renaming foo to
            usersFoo then I can just pass in an object, usersFoo, and set that to foo. So this syntax is now equivalent
            to this code here. So we can delete this code:</p>
          <figure>
            <img src="images/Fig05-246.png"/>
            <figcaption>Fig 05-246</figcaption>
          </figure>
          <p>So that's a pretty clean syntax that we could use. And we could use that up here for robotsFoo also, but
            we'll leave this how it is so that you can see the different examples. And actually, this is plural,
            users:</p>
          <figure>
            <img src="images/Fig05-247.png"/>
            <figcaption>Fig 05-247</figcaption>
          </figure>
          <p>
            However, we have a small problem here. If we go over here and look at our site, you can see usersFoo is not
            rendering:</p>
          <figure>
            <img src="images/Fig05-248.png"/>
            <figcaption>Fig 05-248.png</figcaption>
          </figure>
          <p>And if I look at my console you can see module namespace not found in mapState, and it's referencing our
            users module:</p>
          <figure>
            <img src="images/Fig05-249.png"/>
            <figcaption>Fig 05-249</figcaption>
          </figure>
          <p>Well, the problem is, and I think this is kind of unfortunate, but the problem is that this syntax only
            works with namespaced modules:</p>>
          <figure>
            <img src="images/Fig05-250.png"/>
            <figcaption>Fig 05-250</figcaption>
          </figure>
          <p>And so, we're actually going to be forced to use this syntax for the usersFoo property:</p>
          <figure>
            <img src="images/Fig05-251.png"/>
            <figcaption>Fig 05-251</figcaption>
          </figure>
          <p>So I'll use the function syntax state. users. foo. But we could use this syntax for robots since it is a
            namespace module:</p>
          <figure>
            <img src="images/Fig05-252.png"/>
            <figcaption>Fig 05-252</figcaption>
          </figure>
          <p>Now if we go take a look at this, now everything is rendering correctly:</p>
          <figure>
            <img src="images/Fig05-253.png"/>
            <figcaption>Fig 05-253</figcaption>
          </figure>
          <p>And if I refresh we don't have any errors here:</p>
          <figure>
            <img src="images/Fig05-254.png"/>
            <figcaption>Fig 05-254</figcaption>
          </figure>
          <p>So just keep in mind that this syntax can only be used for namespaced modules. Okay, cool. So, just like
            there is a mapState function there's also a mapGetters helper. So let's go take a look at that next.
          </p>
        </div>
        <div><h3>Using the Vuex MapGetters Helper</h3>
          <p>Using mapGetters is identical to using mapState. So let's go ahead and import that up here also:</p>
          <figure>
            <img src="images/Fig05-255.png"/>
            <figcaption>Fig 05-255</figcaption>
          </figure>
          <p>And then we can use it in the exact same way. So down here I'm going to spread mapGetters. And then for the
            rootGetter I will just use the object syntax because I want to rename it to rootGetterFoo. And that is going
            to grab the foo getter off of the root store. And then I will use the module syntax for the robotsGetter
            like this:</p>
          <figure>
            <img src="images/Fig05-256.png"/>
            <figcaption>Fig 05-256</figcaption>
          </figure>
          <p>And then we can delete these two functions here:</p>
          <figure>
            <img src="images/Fig05-257.png"/>
            <figcaption>Fig 05-257</figcaption>
          </figure>
          <p>And actually, this usersGetterFoo is leftover code from an earlier demo:</p>
          <figure>
            <img src="images/Fig05-258.png"/>
            <figcaption>Fig 05-258</figcaption>
          </figure>
          <p>We're not actually using that so we can delete that there. And we can delete the binding for it up here
            also:</p>
          <figure>
            <img src="images/Fig05-259.png"/>
            <figcaption>Fig 05-259</figcaption>
          </figure>
          <p>Okay. And that should be working fine. There we go:</p>
          <figure>
            <img src="images/Fig05-260.png"/>
            <figcaption>Fig 05-260</figcaption>
          </figure>
          <p>The getters are now working just as we'd expect. And again, this code is a lot less verbose than it was
            before, and so these helpers are nice. And next, we'll do the same thing for actions. Although mapActions is
            a little bit different so let's take a look at that.
          </p>
        </div>
        <div><h3>Using the Vuex MapActions Helper</h3>
          <p>
            MapActions is similar to mapState and mapGetters, but it has a little bit different syntax. So, first of
            all, we will import mapActions right here from Vuex:</p>
          <figure>
            <img src="images/Fig05-261.png"/>
            <figcaption>Fig 05-261</figcaption>
          </figure>
          <p>And then the first difference with mapActions is that instead of using it in the computed section we will
            use it in the methods section. So right here I'm going to spread mapActions:</p>
          <figure>
            <img src="images/Fig05-262.png"/>
            <figcaption>Fig 05-262</figcaption>
          </figure>
          <p>And there are a couple of actions in here that we want to map, and both of them are in the robots module.
            The first one is up here in this created hook. It is this dispatch right here:</p>
          <figure>
            <img src="images/Fig05-263.png"/>
            <figcaption>Fig 05-263</figcaption>
          </figure>
          <p>where we're dispatching getParts. And the second one that we want to use is this addRobotToCart action down
            here:</p>
          <figure>
            <img src="images/Fig05-264.png"/>
            <figcaption>Fig 05-264</figcaption>
          </figure>
          <p>So, we'll map both of these actions here. And we'll start out by specifying the robots module since it's a
            namespaced module. And then we don't need to rename these actions at all so we'll just use the array syntax
            and we'll pass in getParts and addRobotToCart:</p>
          <figure>
            <img src="images/Fig05-265.png"/>
            <figcaption>Fig 05-265</figcaption>
          </figure>
          <p>So actually, this syntax is identical to the other helpers, but we're putting it in the methods section of
            our component. And the way we call them is interesting for actions. And this is in the methods section so
            that means that these are now methods on our component named getParts and addRobotToCart.</p>
          <p> >So, if we go up here to where we dispatch our getParts call we can just call this.getParts:</p>
          <figure>
            <img src="images/Fig05-266.png"/>
            <figcaption>Fig 05-266</figcaption>
          </figure>
          <p>And the interesting thing about this is that notice that we're not calling dispatch anywhere anymore.
            Calling dispatch is taken care of for us by the mapActions helper. So that makes using it really nice.</p>
          <p>And now we can do the same thing for addRobotToCart down here in our addToCart function. So we can just
            call this.addRobotToCart. And then we'll delete all of this:</p>
          <figure>
            <img src="images/Fig05-267.png"/>
            <figcaption>Fig 05-267</figcaption>
          </figure>
          <p>but we'll still pass in our robot:</p>
          <figure>
            <img src="images/Fig05-268.png"/>
            <figcaption>Fig 05-268</figcaption>
          </figure>
          <p>Cool. So now we're not having to worry about any dispatch details, and this feels a lot cleaner. So let's
            go check this out.</p>
          <p>So, over here in our RobotBuilder, our robot builder is getting its parts:</p>
          <figure>
            <img src="images/Fig05-269.png"/>
            <figcaption>Fig 05-269</figcaption>
          </figure>
          <p>And I can still add to cart here:</p>
          <figure>
            <img src="images/Fig05-270.png"/>
            <figcaption>Fig 05-270</figcaption>
          </figure>
          <p>Awesome, this is working great. Let's go clean this up so that we don't have this extra stuff up here
            anymore. So, in our App. vue component I'm just going to comment this out in case you want to reference it
            later:</p>
          <figure>
            <img src="images/Fig05-271.png"/>
            <figcaption>Fig 05-271</figcaption>
          </figure>
          <p>
            And there, now our site's looking decent:</p>
          <figure>
            <img src="images/Fig05-272.png"/>
            <figcaption>Fig 05-272</figcaption>
          </figure>
          <p>Cool. So now we've talked about mapState, mapGetters, and mapActions. So the last helper that we'll talk
            about is the mapMutations helper.
          </p>
        </div>
        <div><h3>Using the Vuex MapMutations Helper</h3>
          <p>MapMutations is not any different than all the other helpers. We don't have any mutations that we're using
            outside of the store, but I can show you how we'd use it if we did. So we'll just import mapMutations:</p>
          <figure>
            <img src="images/Fig05-273.png"/>
            <figcaption>Fig 05-273.png</figcaption>
          </figure>
          <p>
            And then down here in methods we'd map mutations just like everything else. So we spread mapMutations, and
            then add the module name if necessary, and then the array of mutations that you want to map over:</p>
          <figure>
            <img src="images/Fig05-274.png"/>
            <figcaption>Fig 05-274</figcaption>
          </figure>
          <p>Of course, we could use the object syntax here also just like we did with mapState if we wanted to rename
            the method locally. And that really is all there is to using mapMutations. It's just like using any of the
            other map helpers. But, of course, we don't have any mutations so I'm going to go ahead and delete the code
            I just added.</p>
          <p>So with that, we've covered all of the different Vuex map helpers. And, in fact, this concludes our
            discussion of Vuex.
          </p>
        </div>
        <div><h3>Summary</h3>
          <p>In this module, we learned how to use Vuex to manage all of our applications state. And this included:</p>
          <ul>
            <li>Creating a Vuex store,</li>
            <li>Changing state with mutations</li>
            <li>Retrieving data from the state</li>
            <li>Using getters to return calculated data from the state</li>
            <li>Using actions to work with asynchronous data</li>
            <li>Using modules to organize a store</li>
            <li>Using built-in helpers to work with a store.</li>
          </ul>
          <p>In the next module, we'll learn how to create our own custom directives and how to create and use filters.
          </p>
        </div>
        <div><h2>Creating Custom Directives and Filters</h2>
          <div><h3>Introduction</h3>
            <p>Welcome to this module on creating custom directives and filters. In this module we'll learn how to
              create and use our own directives similar to directives we've already been using, such as v-if. We'll also
              learn about view filters and how to create and use them. We'll learn about:</p>
            <ul>
              <li>Creating and using custom directives,</li>
              <li>Passing data to directives</li>
              <li>Declaring directives locally versus declaring them globally,</li>
              <li>Creating and using filters</li>
              <li>Declaring filters locally versus declaring them globally</li>
            </ul>
            <p>Alright, let's check it out.</p>
          </div>
          <div><h3>Creating a Custom Directive</h3>
            <p>View comes with a handful of built in directives that we've been using already in our application. For
              example, this v-if attribute:</p>
            <figure>
              <img src="images/Fig06-001.png"/>
              <figcaption>Fig 06-001</figcaption>
            </figure>
            <p>is actually a directive. Same with v-show and v-for. But what if we want to create our own directives?
              Let's explore how to do that. If we take a look at our robot builder, when we select a part that's on
              sale, it shows this sale icon down here:</p>
            <figure>
              <img src="images/Fig06-002.png"/>
              <figcaption>Fig 06-002</figcaption>
            </figure>
            <p>This is happening in our part selector. If we go take a look at that it's this span right here:</p>
            <figure>
              <img src="images/Fig06-003.png"/>
              <figcaption>Fig 06-003</figcaption>
            </figure>
            <p>And this span is being displayed in the bottom right hand corner using CSS. Imagine though if I had a
              common need for pinning an element down in the bottom right hand corner. Instead of having to always
              create a class that absolute positions the element in the bottom right hand corner, I could just create a
              directive that does it for me. Let's do that for this sale element.</p>
            <p>So to start with let's come down to the CSS and remove the positioning attributes out of this sale class.
              So we'll remove position, bottom, and right:</p>
            <figure>
              <img src="images/Fig06-004.png"/>
              <figcaption>Fig 06-004</figcaption>
            </figure>
            <p>And then I want to be able to pin an element to the bottom right hand corner just by adding a directive
              like this. So here I want to be able to just say v-pin:</p>
            <figure>
              <img src="images/Fig06-005.png"/>
              <figcaption>Fig 06-005</figcaption>
            </figure>
            <p>And then just because I added this directive, this element will be pinned in the bottom right hand
              corner. So let's go create this directive. So in the shared folder I'm going to create a new file and
              we'll call that pin-directive.js:</p>
            <figure>
              <img src="images/Fig06-006.png"/>
              <figcaption>Fig 06-006</figcaption>
            </figure>
            <p>Alright, and then to start with this is just going to export an object:</p>
            <figure>
              <img src="images/Fig06-007.png"/>
              <figcaption>Fig 06-007</figcaption>
            </figure>
            <p>And then a directive has a handful of methods that act as hooks. One of the most commonly used hooks is
              the bind hook:</p>
            <figure>
              <img src="images/Fig06-008.png"/>
              <figcaption>Fig 06-008</figcaption>
            </figure>
            <p>So this is just a function that we put on this object. And then this gets called as soon as the directive
              is bound to its parent component. And the first parameter that gets passed in here is the element
              itself:</p>
            <figure>
              <img src="images/Fig06-009.png"/>
              <figcaption>Fig 06-009</figcaption>
            </figure>
            <p>
              So in the case of our part selector that's going to be this span element right here:</p>
            <figure>
              <img src="images/Fig06-010.png"/>
              <figcaption>Fig 06-010</figcaption>
            </figure>
            <p>And this pin directive is going to be really simple. I just want to apply some styles to the element that
              is being passed in. So I can do that by just grabbing this element and then setting the style.position
              property to absolute. And then I'll also set the bottom and right attributes to five pixels. And then the
              same thing for the right attribute:</p>
            <figure>
              <img src="images/Fig06-011.png"/>
              <figcaption>Fig 06-011</figcaption>
            </figure>
            <p>And then that's it. That's all there is to creating this directive. Now in our parts selector component
              we need to import our new directive, so import pin directive from shared pin directive:</p>
            <figure>
              <img src="images/Fig06-012.png"/>
              <figcaption>Fig 06-012</figcaption>
            </figure>
            <p>And then we can just declare this locally in our component with a directive section here and then that
              takes an object where the key is the name of the directive that you're going to use in your template, and
              then the directive that we imported, so pin directive</p>
            <figure>
              <img src="images/Fig06-013.png"/>
              <figcaption>Fig 06-013</figcaption>
            </figure>
            <p>And now because we've defined this as a directive here and named it pin, I can now use that up here in my
              directive like this:</p>
            <figure>
              <img src="images/Fig06-014.png"/>
              <figcaption>Fig 06-014</figcaption>
            </figure>
            <p>So notice that v- is pre pended to the name of the directive that we created. Okay, this should be
              working just fine so let's go check it out:</p>
            <figure>
              <img src="images/Fig06-015.png"/>
              <figcaption>Fig 06-015</figcaption>
            </figure>
            <p>There we go. So it's showing in the bottom right hand corner and then just to demonstrate that this is
              coming from the directive, let's remove the directive from this element:</p>
            <figure>
              <img src="images/Fig06-016.png"/>
              <figcaption>Fig 06-016</figcaption>
            </figure>
            <p>and then refresh here:</p>
            <figure>
              <img src="images/Fig06-017.png"/>
              <figcaption>Fig 06-017</figcaption>
            </figure>
            <p>And then there you go. You can see the positioning is off. So let's go ahead and put that back. Awesome,
              that was really simple.</p>
            <p>Now let's go take a look at how we can pass some data into our directive.
            </p>
          </div>
          <div><h3>Passing Data to Directives</h3>
            <p>Our new pin directive is kind of cool but it's not very flexible. It's always going to pin items to the
              bottom right corner. Let's make it so that we can tell the directive where to pin itself. There are a
              couple of different ways that we can pass information to a directive. So let's explore them both.</p>
            <p>The first is through the use of args. So back over here where we're using our directive, we can use args
              to tell our pin directive we want it to be pinned to the top right like this:</p>
            <figure>
              <img src="images/Fig06-018.png"/>
              <figcaption>Fig 06-018</figcaption>
            </figure>
            <p>So here I'm using args to say I want to position this in the top right corner. It's fairly expressive and
              to the point. The first part of this expression:</p>
            <figure>
              <img src="images/Fig06-019.png"/>
              <figcaption>Fig 06-019</figcaption>
            </figure>
            <p>position, is called the arg and the parts that follow it, separated by periods:</p>
            <figure>
              <img src="images/Fig06-020.png"/>
              <figcaption>Fig 06-020</figcaption>
            </figure>
            <p>are called modifiers. So position is the arg and top right are the modifiers. And then back over here in
              our directive we can get access to that information through the second parameter, which is binding:</p>
            <figure>
              <img src="images/Fig06-021.png"/>
              <figcaption>Fig 06-021</figcaption>
            </figure>
            <p>And the binding has a couple of properties that we're interested in, arg and modifiers. So let's just
              console.log those out for a second to see what those look like:</p>
            <figure>
              <img src="images/Fig06-022.png"/>
              <figcaption>Fig 06-022</figcaption>
            </figure>
            <p>So we'll console.log the arg and then the modifiers. Okay and let's go look at that:</p>
            <figure>
              <img src="images/Fig06-023.png"/>
              <figcaption>Fig 06-023</figcaption>
            </figure>
            <p>So if we open our console here there we can see that we're getting a couple of things logged out. So arg
              is positioned and modifiers is an object with two properties, right, which is set to true, and top that is
              set to true. So modifiers is an object that contains each modifier set to true if they exist.</p>
            <p>So back in our directive, we'll check the first arg to make sure that it's set to position and if not
              we'll just do nothing, so get rid of our console. log here and then we'll just say if binding. arg does
              not equal position, then we'll just return and do nothing because the data being passed in is not in the
              format that we expect:</p>
            <figure>
              <img src="images/Fig06-024.png"/>
              <figcaption>Fig 06-024</figcaption>
            </figure>
            <p>And then basically I want to loop over each of the modifiers and apply the style that pins the element to
              the corresponding position:</p>
            <figure>
              <img src="images/Fig06-025.png"/>
              <figcaption>Fig 06-025</figcaption>
            </figure>
            <p>So to do that I'm going to use object.keys, which enumerates all the keys on an object. And so we want to
              enumerate over all the keys on the binding modifiers object. And then for each of those we will call this
              function and then the key will be passed in and then for each key in the keys here are going to be top and
              right, I just want to set element.style with that key equal to five pixels. So this will set
              element.style.top to five pixels and element.style.right to five pixels if those are the modifiers that
              are passed in.</p>

            <p>Okay and then we can get rid of these down here:</p>
            <figure>
              <img src="images/Fig06-026.png"/>
              <figcaption>Fig 06-026</figcaption>
            </figure>
            <p>So we'll always set the position to absolute and then we will set the top and right and in this case,
              because we're passing in top and right here:</p>
            <figure>
              <img src="images/Fig06-027.png"/>
              <figcaption>Fig 06-027</figcaption>
            </figure>
            <p>we will set top and right to five pixels. If we send in something else other than top and right those
              will get set to five pixels. Okay, let's go see how this is working:</p>
            <figure>
              <img src="images/Fig06-028.png"/>
              <figcaption>Fig 06-028</figcaption>
            </figure>
            <p>
              So if we look at a sale item, there we go. It is pinned to the top right now. Alright, let's go see what
              happens if we change this to be pinned to the bottom left:</p>
            <figure>
              <img src="images/Fig06-029.png"/>
              <figcaption>Fig 06-029</figcaption>
            </figure>
            <p>And let's refresh that. And you'll notice that you saw some really weird behavior there when we came back
              here before we refreshed:</p>
            <figure>
              <img src="images/Fig06-030.png"/>
              <figcaption>Fig 06-030</figcaption>
            </figure>
            <p>And we'll get into that in a minute here. But notice if I do a full refresh on my page that it is now in
              the bottom left:</p>
            <figure>
              <img src="images/Fig06-031.png"/>
              <figcaption>Fig 06-031</figcaption>
            </figure>
            <p>So when I first came back to here before I refreshed, keep in mind that hot module replacement is at work
              here and so as we're making changes, hot module replacement, which is part of the web hack server, is
              applying those changes to our website without doing a full page refresh. And what was happening here:</p>
            <figure>
              <img src="images/Fig06-032.png"/>
              <figcaption>Fig 06-032</figcaption>
            </figure>
            <p>is hot module replacement was still doing its job but our directive wasn't noticing all of the changes.
              And that's why it was pinned actually to the top right and the bottom left and so it made the entire image
              red. So in the next clip we'll cover why it wasn't noticing those changes.</p>
            <p>But first I had mentioned that there are a couple of ways to pass data into a directive, so let's look at
              the other way. The second way isn't quite as expressive but it's much more flexible. So instead of using
              args and modifiers we're going to pass everything in as an object. So I'm going to set v-pin equal to an
              expression and that expression is going to be an object:</p>
            <figure>
              <img src="images/Fig06-033.png"/>
              <figcaption>Fig 06-033</figcaption>
            </figure>
            <p>And we'll use that object to define the position. So let's say we want this to be pinned to the bottom
              with 10 pixels of spacing, and to the right with five pixels of spacing:</p>
            <figure>
              <img src="images/Fig06-034.png"/>
              <figcaption>Fig 06-034</figcaption>
            </figure>
            <p>So this object is going to be passed into the directive and you can see how this is more flexible than
              the args notation because I can actually pass values for each one of the arguments that I want to pass
              into the directive. </p>
            <p>So over in our directive we can access that with binding.value.:</p>
            <figure>
              <img src="images/Fig06-035.png"/>
              <figcaption>Fig 06-035</figcaption>
            </figure>
            <p>Okay and then we're going to delete this check here for binding.arg. And then we're going to change our
              loop to loop over the keys in binding.value:</p>
            <figure>
              <img src="images/Fig06-036.png"/>
              <figcaption>Fig 06-036</figcaption>
            </figure>
            <p>So binding.value is set to whatever we passed into our directive here. So it's this bottom right
              object:</p>
            <figure>
              <img src="images/Fig06-037.png"/>
              <figcaption>Fig 06-037</figcaption>
            </figure>
            <p>
              And then we will set that to binding. value.position where position is the value being passed in here. So
              let's rename this to position just to be a little bit more clear:</p>
            <figure>
              <img src="images/Fig06-038.png"/>
              <figcaption>Fig 06-038</figcaption>
            </figure>
            <p>So for example, in this example here where we're passing in bottom 10 pixels and right 10 pixels, then
              position here is going to be bottom and right. So we're going to set element.style.bottom to
              binding.value.bottom. So this would set bottom to 10 pixels in this case. Okay, let's go check that out.
              There we go. Now you can see that this is showing in the bottom right but you can see there's 10 pixels
              from the bottom and five pixels from the right:</p>
            <figure>
              <img src="images/Fig06-039.png"/>
              <figcaption>Fig 06-039</figcaption>
            </figure>
            <p>Okay and to show that we can now configure it let's come back over here and let's change right to 50
              pixels and see what that does.</p>
            <figure>
              <img src="images/Fig06-040.png"/>
              <figcaption>Fig 06-040</figcaption>
            </figure>
            <p>Okay notice that again, we changed it, but we're not seeing any change here:</p>
            <figure>
              <img src="images/Fig06-041.png"/>
              <figcaption>Fig 06-041</figcaption>
            </figure>
            <p>and we won't see that change until we refresh. So there, now we can see that it's 50 pixels to the
              right:</p>
            <figure>
              <img src="images/Fig06-042.png"/>
              <figcaption>Fig 06-042</figcaption>
            </figure>
            <p>So the question is, why are we not seeing this unless we refresh? Because our hot module replacement is
              working. But this is actually a problem with our directive where our directive is not noticing the
              changes. So in the next clip let's take a look at the different directive hook functions. This will help
              us fix this problem.</p>
          </div>
          <div><h3>Using Directive Lifecycle Hooks</h3>
            <p>You may have noticed throughout this course that we've had hot module replacement working, which causes
              our dev changes to be immediately rendered without having to refresh the browser. And you may have also
              noticed that our changes to our directive have been requiring us to hit refresh, and this is due to the
              life cycle hook that we're binding to in the directive. So over here in our directive you can see that
              we're using the bind life cycle hook:</p>
            <figure>
              <img src="images/Fig06-043.png"/>
              <figcaption>Fig 06-043</figcaption>
            </figure>
            <p>This hook gets fired when the directive is first bound to the element. So this code only gets fired once.
              But demonstrating this with hot module replacement is obscuring the issue, so let's create a better way to
              demonstrate the problem.</p>
            <p>So over here in our part selector component, instead of hard coding the padding here, let's bind to it.
              We'll use a new pin padding property. And we'll use that in both places here:</p>
            <figure>
              <img src="images/Fig06-044.png"/>
              <figcaption>Fig 06-044</figcaption>
            </figure>
            <p>
              And then to help demonstrate that let's also just display that pin padding right here:</p>
            <figure>
              <img src="images/Fig06-045.png"/>
              <figcaption>Fig 06-045</figcaption>
            </figure>
            <p>And then let's just make it so that when we click on this sale element it sets the pin padding to 30
              pixels:</p>
            <figure>
              <img src="images/Fig06-046.png"/>
              <figcaption>Fig 06-046</figcaption>
            </figure>
            <p>Okay, so the attributes for our bottom and right are set to pin padding and then when you click on this
              element we set pin padding to 30 pixels. In order for this to work we need to add it to our data function
              down here. So we'll add pin padding and let's default that to 10 pixels.:</p>
            <p>So when the component first loads this will be set to 10 pixels and then when we click on the sale
              element it will change it to 30 pixels. Okay, so let's go take a look at this.</p>
            <p> So let's refresh and then over here, so you can see that the pin padding is set to 10 pixels:</p>
            <figure>
              <img src="images/Fig06-047.png"/>
              <figcaption>Fig 06-047</figcaption>
            </figure>
            <p>and actually, where we place this is not very easy to see so let's move this interpolation up here to the
              top:</p>
            <figure>
              <img src="images/Fig06-048.png"/>
              <figcaption>Fig 06-048</figcaption>
            </figure>
            <p>That should make it easier. There we go. So you can see that our padding is set to 10 pixels. And when I
              click on this element it will change it to 30 pixels:</p>
            <figure>
              <img src="images/Fig06-049.png"/>
              <figcaption>Fig 06-049</figcaption>
            </figure>
            <p>There you can see it changed it to 30 pixels up here but notice that our directive didn't get updated.
              And this is because we are only binding to the bind life cycle hook in our directive. So there is another
              life cycle hook that we can bind to and it's the update hook.</p>
            <p>So right here let's add an update life cycle hook and that takes in element and binding also:</p>
            <figure>
              <img src="images/Fig06-050.png"/>
              <figcaption>Fig 06-050</figcaption>
            </figure>
            <p>And then this update function is actually going to do the exact same thing as our bind function. So let's
              extract this out here:</p>
            <figure>
              <img src="images/Fig06-051.png"/>
              <figcaption>Fig 06-051</figcaption>
            </figure>
            <p>We're going to cut this out of here and we'll create a new function called applyStyle and that will take
              in element and binding. And then we'll just paste that code in here:</p>
            <figure>
              <img src="images/Fig06-052.png"/>
              <figcaption>Fig 06-052</figcaption>
            </figure>
            <p>Okay so now we have this apply style and we can actually call that from bind and from update:</p>
            <figure>
              <img src="images/Fig06-053.png"/>
              <figcaption>Fig 06-053</figcaption>
            </figure>
            <p>Okay so now our directive will also get updated whenever its parent component is updated, which includes
              when the directive's bindings are updated. So let's go check this out. So come back over here now and
              let's refresh one last time and then come over here. Now notice when I click on this that the directive is
              updated:</p>
            <figure>
              <img src="images/Fig06-054.png"/>
              <figcaption>Fig 06-054</figcaption>
            </figure>
            <p>So the directive is noticing changes now on the bindings of its parent element. Okay now there are three
              other life cycle hooks that can be tapped into including inserted, which fires whenever the bound element
              has been inserted into its parent node.</p>
            <p>componentUpdated, which like update, fires when the containing component has been updated. But with the
              update hook it could get fired before the containing component's children are updated. The component
              updating method fires only after all children have been updated.</p>
            <p>And then the last hook is unbind, which gets called when the directive is unbound from its parent
              component.</p>
            <p>We're not going to demonstrate these three life cycle hooks in this course because they're much less
              common. The bind and update hooks are by far the most common. In fact, it's actually so common to use bind
              and update together that there is a shorthand for creating a directive that hooks into both the bind and
              update hooks. And since that's what our directive is doing let's change ours to shorthand syntax.</p>
            <p>So here instead of exporting an object we're going to export a function. And that function is going to
              take in the element and binding parameters:</p>
            <figure>
              <img src="images/Fig06-055.png"/>
              <figcaption>Fig 06-055</figcaption>
            </figure>
            <p>and then the body of this is just going to be this function here:</p>
            <figure>
              <img src="images/Fig06-056.png"/>
              <figcaption>Fig 06-056</figcaption>
            </figure>
            <p>so we'll cut this out here and paste it in here. And then we can delete the rest of this:</p>
            <figure>
              <img src="images/Fig06-057.png"/>
              <figcaption>Fig 06-057</figcaption>
            </figure>
            <p>And we can delete our reply style function:</p>
            <figure>
              <img src="images/Fig06-058.png"/>
              <figcaption>Fig 06-058</figcaption>
            </figure>
            <p>Cool, so you can see how this is much more to the point and a lot less ceremony going on in here:</p>
            <figure>
              <img src="images/Fig06-059.png"/>
              <figcaption>Fig 06-059</figcaption>
            </figure>
            <p>
              And we are now binding to both the bind and update life cycle hooks. So this is a really common way to
              write directives. And that should still be working fine. So let's refresh this. And there we go:</p>
            <figure>
              <img src="images/Fig06-060.png"/>
              <figcaption>Fig 06-060</figcaption>
            </figure>
            <p>Our directive is still working as expected. Alright, awesome. And that's how we create directives. Now
              let's go clean up this extra 30 pixels display here:</p>
            <figure>
              <img src="images/Fig06-061.png"/>
              <figcaption>Fig 06-061</figcaption>
            </figure>
            <p>We don't need that. There we go.:</p>
            <figure>
              <img src="images/Fig06-062.png"/>
              <figcaption>Fig 06-062</figcaption>
            </figure>
            <p>Cool, so now let's go take a look at how to make directives available globally.
            </p>
          </div>
          <div><h3>Making Directives Available Globally</h3>
            <p>So far we've only been making our directive available to a single component by importing it here:</p>
            <figure>
              <img src="images/Fig06-063.png"/>
              <figcaption>Fig 06-063</figcaption>
            </figure>
            <p>
              This is a good idea if the directive is really only related to a single component or just a couple of
              components. But often we'll want to create directives that we want to use throughout our app on lots of
              different components. When we do that it's better to declare the directive globally so we don't have to
              declare it in every component like we have here. So let's see how to do that with our pin directive. It's
              really quite easy.</p>

            <p>So we'll delete this directives section here and we'll delete the import:</p>
            <figure>
              <img src="images/Fig06-064.png"/>
              <figcaption>Fig 06-064</figcaption>
            </figure>
            <p>And now of course if we look at our site that directive is no longer working:</p>
            <figure>
              <img src="images/Fig06-065.png"/>
              <figcaption>Fig 06-065</figcaption>
            </figure>
            <p>Otherwise this would be pinned in the bottom right. And if we go look at the console, you can see that
              we're getting errors:</p>
            <figure>
              <img src="images/Fig06-066.png"/>
              <figcaption>Fig 06-066</figcaption>
            </figure>
            <p>Failed to resolve directive pin, so our component doesn't know about this directive. So now let's go
              declare it globally. We just do that in our main.js file. So if I come in here, let's import our directive
              here:</p>
            <figure>
              <img src="images/Fig06-067.png"/>
              <figcaption>Fig 06-067</figcaption>
            </figure>
            <p>So import pin directive from shared pin directive. Okay now we can make our view application aware of
              this directive by just calling Vue.directive and then we will pass in our pin directive but first we have
              to give it a name. So this is the pin directive and then we pass in our imported pinDirective:</p>
            <figure>
              <img src="images/Fig06-068.png"/>
              <figcaption>Fig 06-068</figcaption>
            </figure>
            <p>
              Cool, and that's it. This directive should now be available for use in all components in our app. So if we
              go check that out over here you can see we're no longer getting an error here and if we come over here,
              there we go. It's pinned to the bottom right:</p>
            <figure>
              <img src="images/Fig06-069.png"/>
              <figcaption>Fig 06-069</figcaption>
            </figure>
            <p>Awesome, so directives are really quite simple to create and they can be really useful for sharing some
              functionality on elements around your site. Next let's take a look at using filters in view.
            </p>
          </div>
          <div><h3>Creating a Custom Filter</h3>
            <p>View filters allow you to easily transform data in your templates but sometimes the name can be a little
              misleading. Sometimes when we think of a filter we think of something that takes a list and filters out
              items from the list. While view filters can certainly be used to do that, that's not all they do.</p>
            <p>When you think of the word filter, maybe it's easy to compare them to a filter on a camera, which takes a
              photo and transforms the way it looks in some way. View filters do something similar for data. They take
              data in as input and output something different. To demonstrate how to create and use a filter let's
              create a currency filter.</p>
            <p>You could see here on our cart page that we're displaying the cost of each robot:</p>
            <figure>
              <img src="images/Fig06-070.png"/>
              <figcaption>Fig 06-070</figcaption>
            </figure>
            <p>But it's not formatted very nicely so we'll create a currency filter to format it. To do that we'll
              create a currency filter here in our shared folder. So I'm going to create a new file here and we'll call
              this currencyfilter.js:</p>
            <figure>
              <img src="images/Fig06-071.png"/>
              <figcaption>Fig 06-071</figcaption>
            </figure>
            <p>And a filter is really just a function so we will export a function here:</p>
            <figure>
              <img src="images/Fig06-072.png"/>
              <figcaption>Fig 06-072</figcaption>
            </figure>
            <p>And a filter always has a minimum of one parameter and this is the input for the filter so we're going to
              specify amount here because this is a currency filter. And then our filter is just going to return a
              string. We'll use a string template here. And our string template is just going to pre pend a $ to the
              amount:</p>
            <figure>
              <img src="images/Fig06-073.png"/>
              <figcaption>Fig 06-073</figcaption>
            </figure>
            <p>So this looks a little bit weird because we have two $$ but this is just the string template syntax and
              then we're pre pending a dollar sign here to this amount variable.</p>
            <p>And then we're just going to format this amount with two decimal points. So we'll just say to fixed here,
              pass in two decimal points:</p>
            <figure>
              <img src="images/Fig06-074.png"/>
              <figcaption>Fig 06-074</figcaption>
            </figure>
            <p>
              Alright, now we can add this filter to our component like we did with directives. So over here in our
              shopping cart component we're going to import our currency filter from shared currency filter:</p>
            <figure>
              <img src="images/Fig06-075.png"/>
              <figcaption>Fig 06-075</figcaption>
            </figure>
            <p>And then we'll just add a filter section and we'll add a currency filter and set that to our currency
              filter:</p>
            <figure>
              <img src="images/Fig06-076.png"/>
              <figcaption>Fig 06-076</figcaption>
            </figure>
            <p>Alright now up here in our template we can use that right here inside this interpolation expression, so
              right after cost I'm going to add a pipe and then the name of our filter, so, currency:</p>
            <figure>
              <img src="images/Fig06-077.png"/>
              <figcaption>Fig 06-077</figcaption>
            </figure>
            <p>So as you can see here the first parameter that has passed into the filter is the value that precedes the
              pipe. So robot.cost is going to be passed in as the first parameter of our currency filter. And then we'll
              just copy this here and paste it down here where we're showing the cost also:</p>
            <figure>
              <img src="images/Fig06-078.png"/>
              <figcaption>Fig 06-078</figcaption>
            </figure>
            <p>Okay that should do it. Let's go take a look. There we go. So we have our currency format here and if we
              add a robot that's on sale then that's getting formatted down here also:</p>
            <figure>
              <img src="images/Fig06-079.png"/>
              <figcaption>Fig 06-079</figcaption>
            </figure>
            <p>Excellent. So that's formatting really nicely and that was really easy. But what if we wanted to be able
              to specify our currency symbol here? Right now we have it hard coded at the $. Well we could do that by
              passing a second parameter to our filter. So let's see how to do that.</p>
            <p>So back over here in our currency filter let's add a second parameter called symbol. And we'll use that
              down here instead of this $:</p>
            <figure>
              <img src="images/Fig06-080.png"/>
              <figcaption>Fig 06-080</figcaption>
            </figure>
            <p>So we'll use another expression here, pass in symbol, and now that symbol is going to be pre pended to
              the amount. Alright, and if we go to take a look at that right now you can see that undefined as being pre
              pended to our amount:</p>
            <figure>
              <img src="images/Fig06-081.png"/>
              <figcaption>Fig 06-081</figcaption>
            </figure>
            <p>and that's because we are not passing in a currency symbol yet. So back over in our template, we can just
              pass that in like this. So I'm going to pass in a $ here. And then we need to do the same thing up here so
              let's pass in the currency symbol here:</p>
            <figure>
              <img src="images/Fig06-082.png"/>
              <figcaption>Fig 06-082</figcaption>
            </figure>
            <p>Okay now if we take a look there we can see that we're getting a $ here. Or I can pass in another symbol
              like the British pound for example. So here on my U.S. keyboard I'm going to hold down alt and type in
              0163 on the numb pad and that gives me a £ and I'm just going to copy this and paste this down here:</p>
            <figure>
              <img src="images/Fig06-083.png"/>
              <figcaption>Fig 06-083</figcaption>
            </figure>
            <p>And now if I come over here, there we go. Now we have a £ sign.:</p>
            <figure>
              <img src="images/Fig06-084.png"/>
              <figcaption>Fig 06-084</figcaption>
            </figure>
            <p>Yay so we now have a currency filter that takes in additional parameters. And of course you can do any
              type of data transformation you'd like with a filter since it just takes data in and returns data out. And
              since filters are just functions we can also just import them inside our component or anywhere else in our
              application and use them in a component like as a computer prop or whatever. They're just functions so we
              can use them however we want.</p>
            <p>Next let's take a look at how to declare this filter globally.
            </p>
          </div>
          <div><h3>Declaring Filters Globally</h3>
            <p>
              Just like we did with directives we can declare filters globally. Right now our currency filter is just
              imported and exposed only in our shopping cart component:</p>
            <figure>
              <img src="images/Fig06-085.png"/>
              <figcaption>Fig 06-085</figcaption>
            </figure>
            <p>But using a currency filter is pretty common and so we might want to use that elsewhere in our app. So
              let's declare it globally. So we'll start by removing this import here:</p>
            <figure>
              <img src="images/Fig06-086.png"/>
              <figcaption>Fig 06-086</figcaption>
            </figure>
            <p>and the filter here and then over in our main.js file we will import it. This changes a little bit:</p>
            <figure>
              <img src="images/Fig06-087.png"/>
              <figcaption>Fig 06-087</figcaption>
            </figure>
            <p>And then just like we did with directives we can say view. filter and the first parameter is the filter
              name so currency and then we pass in our filter:</p>
            <figure>
              <img src="images/Fig06-088.png"/>
              <figcaption>Fig 06-088</figcaption>
            </figure>
            <p>And that should do it. This currency filter is now available globally. So if we go back over to our app
              and add something to our cart, there we go:</p>
            <figure>
              <img src="images/Fig06-089.png"/>
              <figcaption>Fig 06-089</figcaption>
            </figure>
            <p>Our currency filter is now working and it's being shared globally. So, awesome. Now we have a currency
              filter that we can use anywhere in our app.
            </p>
          </div>
          <div><h3>Summary</h3>
            <p>In this module we learned about:</p>
            <ul>
              <li>Creating and using custom directives</li>
              <li>Passing data to directives</li>
              <li>Declaring directives locally vs. declaring them globally</li>
              <li>Creating and using filters</li>
              <li>Declaring filters locally vs. declaring them globally</li>
            </ul>
            <p>Now that we've explored all the fundamentals of building applications with Vue, let's explore how to
              build and deploy our app to production in our final module of this course.
            </p>
          </div>
        </div>
        <div><h2>Deploying Vue Applications to Production</h2>
          <div><h3>Introduction</h3>
            <p>Welcome to this final module on Deploying Vue Applications to Production. In this module, we'll explore
              everything from packaging our application for production to production configuration options, to actually
              deploying to a production server.</p>
            <p>The basic Vue CLI build is a zero config build with reasonable defaults that can be extended or modified
              whenever necessary. This means that you could very reasonably create a new project with the CLI, develop
              it and then use the CLI to create a production-ready build without having to do any configuration, webpack
              or otherwise. Of course in reality, that rarely happens.</p>
            <p>It seems that we always need to be able to tweak configurations as we make changes to support our
              development decisions and to support our development and production environments. Luckily, the
              configuration is very extensible and easy to customize with whatever webpack configuration changes you
              need to make.</p>
            <p>We'll take a look at how to do just that, but first let's take a look at what a zero config build
              includes. So just what is included in an out-of-the-box zero config deployment? Well, the answer is a
              lot:</p>
            <figure>
              <img src="images/Fig07-001.png"/>
              <figcaption>Fig 07-001</figcaption>
            </figure>
            <p>
              I'm not going to read through all of these, but this is what I found when looking through the webpack
              config generated by the Vue CLI at the time this course was produced. There's a lot here, and it includes
              all the things you typically want from a webpack build like minification, concatenation, cache busting via
              chunk hashing, CSS preprocessor support for the most popular options, etc. Everything you'd typically
              think about when creating a build. And so there's a good chance you'd do just fine right out of the
              box.</p>
            <p>But in the event you need to add or remove something to config, you can always do that.</p>
            <p>In this module, we'll cover:
            <ul>
              <li>Creating a basic Vue. js build using the CLI</li>
              <li>Using environment variables and build modes</li>
              <li>Deploying to a production web server</li>
              <li>Handling deep linking when using HTML5 history mode for routing on the client side</li>
              <li>Inspecting the built-in webpack config and customizing the webpack config</li>
            </ul>
            <p>Once we're done with this last module, you will have mastered all the fundamentals you need to know to
              get started with creating and deploying Vue.js applications. So let's jump in and wrap it up.
            </p>
          </div>
          <div><h3>Creating a Basic Vue.js Build with the CLI</h3>
            <p>
              Once you've finished development and you're ready to deploy your changes to production, creating a
              deployable build is simple. Typically, all you need to run is npm run build:</p>
            <figure>
              <img src="images/Fig07-002.png"/>
              <figcaption>Fig 07-002</figcaption>
            </figure>
            <p>So this script will tell the Vue CLI to create a deployable build utilizing all of the built-in webpack
              config that the CLI generated for us when we first generated our project. This will result in a production
              deployable distribution folder. This build will contain all of the latest best practices identified by the
              Vue team for generating a deployable web application, including all of the optimizations we mentioned in
              the previous clip, all of this without us even having to think about it.</p>
            <p>Of course if you want to dig into it and make modifications, you can. More on that later. So let's go
              ahead and run this. Now that this is finished, we have this deployable dist folder:</p>
            <figure>
              <img src="images/Fig07-003.png"/>
              <figcaption>Fig 07-003</figcaption>
            </figure>
            <p>All we need to do to deploy this to a production server is copy this dist folder to a place where it can
              be served by our web server. We'll do this with an express web server later. If we take a look inside this
              dist folder, you can see that we have css, js and img folders:</p>
            <figure>
              <img src="images/Fig07-004.png"/>
              <figcaption>Fig 07-004</figcaption>
            </figure>
            <p>in addition to a favicon and an index.html. The CSS, js and image folders are the webpack contents of all
              the code that we've written for our application. But where did this fave icon and index html come from? We
              never created those. Well, those came from this public directory right here:</p>
            <figure>
              <img src="images/Fig07-005.png"/>
              <figcaption>Fig 07-005</figcaption>
            </figure>
            <p>in our project, and they were generated by the CLI when we first created our application. And actually,
              any file that we put in this folder will be included in the final dist folder. But this index.html file is
              an important file. This is the starting point for our entire application. When we deploy this to
              production, our web server needs to serve up this index html file whenever anyone hits the URL for our
              application. That will then load up our entire Vue.js application.</p>
            <p>And that's all there is to generating a zero config deployment for production. Next let's take a look at
              some other options that we have when building this dist folder, and then we'll see how to deploy it all to
              production.
            </p>
          </div>
          <div><h3>Using Environment Variables and Build Modes</h3>
            <p>When we ran npm run build to generate our deployable dist folder, we didn't pass any arguments to it
              which means that by default it ran in production mode. But sometimes you want to be able to generate
              different deploys for different environments. We can do that with the mode flag. The default build that is
              created when we run npm run build is actually equivalent to this command, running npm run build with the
              switch mode=production:</p>
            <figure>
              <img src="images/Fig07-006.png"/>
              <figcaption>Fig 07-006</figcaption>
            </figure>
            <p>So by default it runs in production mode if we don't provide this mode flag. But we can provide different
              modes. For example, we could create a development mode build and pass in a development flag. And actually,
              when you run npm run serve, as we've been doing all along throughout this course to serve up our
              application and development, it actually creates a development mode build. The important thing to
              understand is that setting mode by default also sets the node_env variable, and this is really
              important.</p>
            <p>
              The webpack build that is generated when the node environment variable is set to production is very
              different than when it is set to development or anything else. Only production mode builds should be used
              in production.</p>
            <p>But what if we want to create a staging mode build and have it use the production node environment
              variables so that we could test a production build in a staging environment prior to production
              deployment</p>
            <p>Well, we can do that with environment variables. To demonstrate that, let's see what happens if we create
              a staging mode build. So I'm going to set mode equal to staging and we'll run that:</p>
            <figure>
              <img src="images/Fig07-007.png"/>
              <figcaption>Fig 07-007</figcaption>
            </figure>
            <p>All right, now take a look at what is in our dist folder:</p>
            <figure>
              <img src="images/Fig07-008.png"/>
              <figcaption>Fig 07-008</figcaption>
            </figure>
            <p>This looks quite different from our production build, which had bundled things up very nicely in a way
              that was appropriate for production. The staging build is basically a development build so we just have
              this one app.js file, for example, instead of optimized chunks. But we can change that so that we could
              have a staging build that runs in production mode.</p>
            <p>So over here in our project, in the root folder, I'm just going to create a new file. And we'll name that
              file. env.staging:</p>
            <figure>
              <img src="images/Fig07-009.png"/>
              <figcaption>Fig 07-009</figcaption>
            </figure>
            <p>And then inside here, I can set environment variables including node environment. And so I'm going to set
              the node environment here to production because even though I'm building a staging build:</p>
            <figure>
              <img src="images/Fig07-010.png"/>
              <figcaption>Fig 07-010</figcaption>
            </figure>
            <p>I want it to be a build that looks just like production so I can test it in staging just like it will
              look in production. So I'll save that and let's come back over here and let's run our npm run build with
              mode staging again:</p>
            <figure>
              <img src="images/Fig07-011.png"/>
              <figcaption>Fig 07-011</figcaption>
            </figure>
            <p>Okay, you can see from the output there that it's very different. So if I take a look at my dist folder
              again:</p>
            <figure>
              <img src="images/Fig07-012.png"/>
              <figcaption>Fig 07-012</figcaption>
            </figure>
            <p>you can see this is all optimized like it was when we did a production build. So we can actually use any
              word that we want here for the mode:</p>
            <figure>
              <img src="images/Fig07-013.png"/>
              <figcaption>Fig 07-013</figcaption>
            </figure>
            <p>So I use staging, but this could be foo or anything else. And then we just create a corresponding .env
              file with that mode name appended to the end of the file name:</p>
            <figure>
              <img src="images/Fig07-014.png"/>
              <figcaption>Fig 07-014</figcaption>
            </figure>
            <p>And it will use any environment variables that we put in here for the build, which leads to another
              question, what other variables might you put in your .env file. Well, you could have, for example,
              connection information for connecting to databases or other configuration options like that. Just be sure
              that if you do that, you don't ever commit secret information to GitHub or anywhere else. You'll want to
              encrypt those values or find some other solution.</p>
            <p>But there's another thing that we can use environment variables for. Let's create another environment
              file and we will call it .env.development:</p>
            <figure>
              <img src="images/Fig07-015.png"/>
              <figcaption>Fig 07-015</figcaption>
            </figure>
            <p>And in here, let's create a new environment variable. We'll just call it VUE_APP_TEST. Now the VUE_APP
              piece of this is important. More on that later. For now, I'm just going to set this to foo:</p>
            <figure>
              <img src="images/Fig07-016.png"/>
              <figcaption>Fig 07-016</figcaption>
            </figure>
            <p>And now that I have that set, let's come over to our home page and we'll add a created hook in here:</p>
            <figure>
              <img src="images/Fig07-017.png"/>
              <figcaption>Fig 07-017</figcaption>
            </figure>
            <p>
              And then when our homepage component is created, we're just going to console.log
              process.env.VUE_APP_TEST:</p>
            <figure>
              <img src="images/Fig07-018.png"/>
              <figcaption>Fig 07-018</figcaption>
            </figure>
            <p>And we created a development.env file with the app Vue test variable in it set to foo:</p>
            <figure>
              <img src="images/Fig07-019.png"/>
              <figcaption>Fig 07-019</figcaption>
            </figure>
            <p>Now we just need to start up our server again:</p>
            <figure>
              <img src="images/Fig07-020.png"/>
              <figcaption>Fig 07-020</figcaption>
            </figure>
            <p>So let's come over to our home page now and open up our console and just refresh this. And there you go,
              you can see that foo got logged here:</p>
            <figure>
              <img src="images/Fig07-021.png"/>
              <figcaption>Fig 07-021</figcaption>
            </figure>
            <p>because in our homepage, we console logged process.env.VUE_APP_TEST. And in our .env.development file,
              that is set to foo.</p>
            <p>Now let's see what happens if we don't prepend the Vue app to this. So we'll just call this
              SOME_TEST=bar:</p>
            <figure>
              <img src="images/Fig07-022.png"/>
              <figcaption>Fig 07-022</figcaption>
            </figure>
            <p>And then back in our home page, let's also print that variable, process.env.SOME_TEST:</p>
            <figure>
              <img src="images/Fig07-023.png"/>
              <figcaption>Fig 07-023</figcaption>
            </figure>
            <p>Okay, and let's stop and restart this again since we changed our .env file:</p>
            <figure>
              <img src="images/Fig07-024.png"/>
              <figcaption>Fig 07-024</figcaption>
            </figure>
            <p>Now let's come back over here and refresh. Notice that we got foo and undefined:</p>
            <figure>
              <img src="images/Fig07-025.png"/>
              <figcaption>Fig 07-025</figcaption>
            </figure>
            <p>And so in our config file:</p>
            <figure>
              <img src="images/Fig07-026.png"/>
              <figcaption>Fig 07-026</figcaption>
            </figure>
            <p>VUE_APP_TEST was available to us but SOME_TEST was not. This is because, for security reasons, Vue will
              only make environment variables available to our client side code that start with VUE_APP_, but there is
              one exception to this and that is NODE_ENV</p>
            <p>So if we were to set this to development or any other value:</p>
            <figure>
              <img src="images/Fig07-027.png"/>
              <figcaption>Fig 07-027</figcaption>
            </figure>
            <p>
              NODE_ENV would also be available to us in our client side code. And this is be cause it's not uncommon to
              want to get access to the node environment in your code. So that one is available without prefixing it
              with Vue app. But every other variable needs to be prefixed with that.</p>
            <p>So you can use these variables in order to provide server-specific variables to your application based on
              the environment that you're operating in.</p>
            <p>Okay, so now that we know how to configure our deployments with environment files, let's see how to
              actually deploy to production.
            </p>
          </div>
          <div><h3>Deploying to a Production Webserver</h3>
            <p>
              We just learned that we can create a production build with npm run build, and that creates this dist
              folder:</p>
            <figure>
              <img src="images/Fig07-028.png"/>
              <figcaption>Fig 07-028</figcaption>
            </figure>
            <p>Now we need to serve that folder from our web server. Your deployment process will be different based on
              the production web server you use, but just to give you an idea of what a basic deploy looks like, we'll
              deploy our site to an express web server.</p>
            <p>If you remember from earlier in the course, we cloned a build-a-bot-server that we used as an API. And up
              till now, that's all we used it for as an API. But let's update it to also serve our newly packaged app.
              Then we'll just deploy our app by copying this dist folder into our server</p>
            <p>So let's open this index.js file up in Visual Studio Code:</p>
            <figure>
              <img src="images/Fig07-029.png"/>
              <figcaption>Fig 07-029</figcaption>
            </figure>
            <p>And you can see here in the index.js file that we have a few routes set up for our API. Let's just add a
              route to also serve the app from a dist folder, and then we can just copy in the dist folder whenever we
              want to deploy a new version of our application.</p>
            <p>So all we need to do is right here at the bottom of our routes, add an app.use, and we'll specify the
              root url here. And then we'll use express.static to serve the dist directory, and we'll let express.static
              know that we want to serve the default index file as index.html:</p>
            <figure>
              <img src="images/Fig07-030.png"/>
              <figcaption>Fig 07-030</figcaption>
            </figure>
            <p>So this line basically says whenever anyone hits the root url and it's not handled by one of the routes
              above, then serve the index.html file from this dist folder. And that's it, this web server is now set up
              to serve our Vue app. The only thing that's missing is the dist folder.</p>
            <p>So basically, whenever you deploy a Vue app, you're basically just deploying or copying the dist folder
              to your web server. So let's go ahead and copy the dist folder from our build-a-bot app into our
              server:</p>
            <figure>
              <img src="images/Fig07-031.png"/>
              <figcaption>Fig 07-031</figcaption>
            </figure>
            <p>
              Okay, so now if we take a look here you can see that we have a dist folder in here:</p>
            <figure>
              <img src="images/Fig07-032.png"/>
              <figcaption>Fig 07-032</figcaption>
            </figure>
            <p>and this is our Vue.js application. And that's it, we just deployed are app to our server. Now let's go
              ahead and start our server. We can do that with npm start:</p>
            <figure>
              <img src="images/Fig07-033.png"/>
              <figcaption>Fig 07-033</figcaption>
            </figure>
            <p>And just like before, when we're running our API, you can see that this is running on port 8081. So one
              thing that's different now from when we were running in development mode is that we were spinning up our
              dev server on port 8080, and that was running with webpack dev server. And we did that with the npm run
              serve command from our build-a-bot folder. And then we were separately starting our API server on port
              8081. So we have our webpack dev server running on port 8080 and our API running on 8081.</p>
            <p>But now that we've deployed are app to this production server, both are app and our API are running on
              port 8081. So let's go check that out. So we'll just navigate to local host 8081</p>
            <figure>
              <img src="images/Fig07-034.png"/>
              <figcaption>Fig 07-034</figcaption>
            </figure>
            <p>And look at that, there is our server. And that is being served out of our dist folder. And if we click
              on Build, you can see that it is communicating with our API, which is running on the same server:</p>
            <figure>
              <img src="images/Fig07-035.png"/>
              <figcaption>Fig 07-035</figcaption>
            </figure>
            <p>So congratulations, you just deployed your first Vue.js application to production and everything here is
              working great except for one problem and that is deep linking. Let's take a look at that next.
            </p>
          </div>
          <div><h3>Handling Deep Linking on the Server</h3>
            <p>There is one problem with our newly deployed app. You can see that our app gets loaded just fine and I
              can even navigate around within my app without any problems. However, let's see what happens if we try
              deep linking into our app. For example, what happens if I navigate straight to this build url here:</p>
            <figure>
              <img src="images/Fig07-036.png"/>
              <figcaption>Fig 07-036</figcaption>
            </figure>
            <p>So I'm going to open a new tab and navigate to that url directly:</p>
            <figure>
              <img src="images/Fig07-037.png"/>
              <figcaption>Fig 07-037</figcaption>
            </figure>
            <p>So you can see that I got a 404 error here. Why is this? Well, by navigating directly to this build url,
              the browser sent a request to our web server saying please send me the document at this url. However,
              there is no document on our server at this url. We don't have a route on our servers for /build. That is a
              client side route. So this is just a manufactured url created by the Vue router that only the client side
              app knows about. And so our server ends up returning a 404 because it doesn't know how to serve this
              url.</p>
            <p>
              So basically, what we need to do is when someone requests any url from our server, we need to return the
              Vue single page application. Or in other words, the index. html file from our dist folder</p>
            <p>This is actually only a problem because we're running in HTML5 history mode. You may recall that before
              we were running in HTML5 history mode, our urls had hash lines in them like this:</p>
            <figure>
              <img src="images/Fig07-038.png"/>
              <figcaption>Fig 07-038</figcaption>
            </figure>
            <p>If you don't run in HTML5 history mode, the server won't try to load this url because the server only
              loads this stuff before the hash. But most people don't want this hash in their url so they turn on HTML5
              history mode. And when you do that, you need to handle deep linking on your server.</p>
            <p>So let's see how to make our server work with that. So if you think about how to make this work,
              basically, whenever a call that is made for a route that is not handled by one of these routes here:</p>
            <figure>
              <img src="images/Fig07-039.png"/>
              <figcaption>Fig 07-039</figcaption>
            </figure>
            <p>
              we'll want to serve the index.html file. That way, we'll serve up the spa and then Vue will load
              everything up and do client-side routing to the correct url. How you do this in different web servers
              varies, but in express, because this is such a common practice, there's an express middleware that we can
              use.</p>
            <p> So back in my terminal, I'm going to stop my server and I'm going to npm install this connect history
              api fallback middleware:</p>
            <figure>
              <img src="images/Fig07-040.png"/>
              <figcaption>Fig 07-040</figcaption>
            </figure>
            <p>Okay, so now that that's installed, I'm going to come over here and I'm going to go ahead and require
              that. So we'll set const history equal to require connect history api fallback:</p>
            <figure>
              <img src="images/Fig07-041.png"/>
              <figcaption>Fig 07-041</figcaption>
            </figure>
            <p>And then I just need to use that middleware like this. So right here at the top, before I route, I'm
              going to say app. use, and then I'm going to call that connect history api fallback function. And then
              inside here I'm going to tell it the name of my index.html file, which is just /index.html:</p>
            <figure>
              <img src="images/Fig07-042.png"/>
              <figcaption>Fig 07-042</figcaption>
            </figure>
            <p>In this case, this parameter isn't necessary because by default it will use index.html. I'm just putting
              it here for clarity. So basically, this says if a request comes in for a file that is not handled in the
              routes below, then redirect the request to /index. html.</p>
            <p>And this will essentially cause it to be handled by this route down here:</p>
            <figure>
              <img src="images/Fig07-043.png"/>
              <figcaption>Fig 07-043</figcaption>
            </figure>
            <p>Okay, so let's go check this out. So we need to start up our server again. And then let's come back over
              here and let's go ahead and deep link into the build page:</p>
            <figure>
              <img src="images/Fig07-044.png"/>
              <figcaption>Fig 07-044</figcaption>
            </figure>
            <p>Excellent, so you can see that works just fine. And we can try it again here for the cart page. And you
              can see everything:</p>
            <figure>
              <img src="images/Fig07-045.png"/>
              <figcaption>Fig 07-045</figcaption>
            </figure>
            <p>all the deep linking in our application is working now. And again, the way you set this up on your web
              server will be different depending on the production web server that you're using. Just know that you need
              to set up your server to always serve the index.html file whenever your server receives a request that it
              doesn't recognize.</p>
            <p>Cool, now let's take a look at how to change webpack config. But before we do that, we need to understand
              what the built-in webpack config looks like. So we'll take a look at that next.
            </p>
          </div>
          <div><h3>Inspecting the Built-in Webpack Config</h3>
            <p>
              We'd like to be able to edit our webpack config, but before we can do that we kind of need to know what is
              already configured. Without some help from the CLI, this would be challenging because the Vue CLI builds
              the webpack config dynamically. So there's no webpack config file to look at. But not to worry, the Vue
              CLI provides the inspect command which outputs the dynamic webpack config. All we need to do is in our
              terminal, run vue inspect:</p>
            <figure>
              <img src="images/Fig07-046.png"/>
              <figcaption>Fig 07-046</figcaption>
            </figure>
            <p>and then we can tell it which environment or build mode to output the config for. So I'm going to say
              generate the production webpack config for production mode:</p>
            <figure>
              <img src="images/Fig07-047.png"/>
              <figcaption>Fig 07-047</figcaption>
            </figure>
            <p>And now I could just run this and it would output the webpack config to the console here. But to make it
              easier to explore, let's pipe this to a file. So we'll pipe it to webpack.config.js:</p>
            <figure>
              <img src="images/Fig07-048.png"/>
              <figcaption>Fig 07-048</figcaption>
            </figure>
            <p>Okay, so this is generating the webpack for us. Remember, you don't ever need to do this. This config
              file that's being generated isn't going to be used. We're just generating it so we can see what the
              webpack config file looks like that the CLI is going to use when it creates a build.</p>
            <p>So let's go take a look at this file. So over here, we can see our webpack config js file. And you can
              see there's a lot of stuff here:</p>
            <figure>
              <img src="images/Fig07-049.png"/>
              <figcaption>Fig 07-049</figcaption>
            </figure>
            <p>including all the webpack rules and loaders and everything. And the nice thing is if we add any of our
              custom config, which we'll do in the next clip, when you run this command it merges that all together and
              generates the resulting file.</p>
            <p>So not only can you use this to see what the Vue CLI is generating itself but you can also see how
              changes that you create are going to get merged into the webpack config at build time. So this is really
              helpful in order to see what the Vue CLI is doing before we start making our own webpack customizations.
              Let's try that next.
            </p>
          </div>
          <div><h3>Customizing Webpack Config</h3>
            <p>Customizing the out-of-the-box webpack config can be almost as easy as editing an existing webpack config
              file. All we have to do is add a section to our Vue config file. If this file doesn't exist yet in a
              project of yours, just create it. We created this one earlier when we wanted to add our API proxy:</p>
            <figure>
              <img src="images/Fig07-050.png"/>
              <figcaption>Fig 07-050</figcaption>
            </figure>
            <p>So in here, we're just going to add a configureWebpack section:</p>
            <figure>
              <img src="images/Fig07-051.png"/>
              <figcaption>Fig 07-051</figcaption>
            </figure>
            <p>And this object is basically your webpack options object. So you configure things inside this object in
              the exact same way that you would your webpack options. And then the CLI uses webpack chain and webpack
              merge to merge it with its own config. So anything that you add here will be added to or overwrite the
              default config.</p>
            <p>
              To demonstrate this, let's add support for CoffeeScript. We do that by adding the Coffee loader. So
              loaders go in the module section. And the module section has rules. All right, and then we're going to add
              a new rule:</p>
            <figure>
              <img src="images/Fig07-052.png"/>
              <figcaption>Fig 07-052</figcaption>
            </figure>
            <p>and this rule will target files that end in .coffee. And then we'll just tell it to use the Coffee
              loader:</p>
            <figure>
              <img src="images/Fig07-053.png"/>
              <figcaption>Fig 07-053</figcaption>
            </figure>
            <p>And that's it, now this config will be merged in with the default webpack config. So now let's go take a
              look at the new webpack config. So we're going to come over to our terminal and we're going to re-run this
              vue inspect command to generate a webpack config:</p>
            <figure>
              <img src="images/Fig07-054.png"/>
              <figcaption>Fig 07-054</figcaption>
            </figure>
            <p>Now this is going to merge our config with the zero config that the CLI generated and we can go take a
              look at the result now. So over here in our webpack config I'm going to hit Control + K and then Control +
              0 in order to collapse everything in here:</p>
            <figure>
              <img src="images/Fig07-055.png"/>
              <figcaption>Fig 07-055</figcaption>
            </figure>
            <p>And then I'm going to expand this. And then down here in the modules, I'm going to expand modules. And
              inside rules, you can see how we have a whole bunch of rules:</p>
            <figure>
              <img src="images/Fig07-056.png"/>
              <figcaption>Fig 07-056</figcaption>
            </figure>
            <p>and down here at the bottom is our new CoffeeScript rule:</p>
            <figure>
              <img src="images/Fig07-057.png"/>
              <figcaption>Fig 07-057</figcaption>
            </figure>
            <p>Of course if we were actually going to leave this in and actually use CoffeeScript, then we need to npm
              install Coffee loader. Since we're just doing this to demonstrate how to edit the config, I'm not going to
              bother doing this. But you can see that we can be confident that the Vue CLI is going to take this rule
              into account when it creates our build.</p>
            <p>But what if instead of adding a new setting we wanted to edit an existing one? For example, I'm going to
              come up to the top of my page here and then I'm going to search for the string right here:</p>
            <figure>
              <img src="images/Fig07-058.png"/>
              <figcaption>Fig 07-058</figcaption>
            </figure>
            <p>So this is a rule targeting image files. And let's go ahead and expand this. And you can see this is a
              url loader rule:</p>
            <figure>
              <img src="images/Fig07-059.png"/>
              <figcaption>Fig 07-059</figcaption>
            </figure>
            <p>So what if we wanted to change this limit here? Well, let's try it, let's copy this rule here and then
              let's paste it in over here in our Vue config:</p>
            <figure>
              <img src="images/Fig07-060.png"/>
              <figcaption>Fig 07-060</figcaption>
            </figure>
            <p>So right here we'll add another rule here. So this is targeting that same rule and then we'll change the
              limit here to 5000:</p>
            <figure>
              <img src="images/Fig07-061.png"/>
              <figcaption>Fig 07-061</figcaption>
            </figure>
            <p>Well, this is actually going to have an unintended consequence. So let's delete our current webpack
              config file:</p>
            <figure>
              <img src="images/Fig07-062.png"/>
              <figcaption>Fig 07-062</figcaption>
            </figure>
            <p>and then we will go generate a new one:</p>
            <figure>
              <img src="images/Fig07-063.png"/>
              <figcaption>Fig 07-063</figcaption>
            </figure>
            <p>And now let's see what this looks like. So if we come back in here, and then let's search for this again,
              so now you can see there are actually two rules in here. And the first rule has it set to a thousand:</p>
            <figure>
              <img src="images/Fig07-064.png"/>
              <figcaption>Fig 07-064</figcaption>
            </figure>
            <p>and the second one has it set to 5000:</p>
            <figure>
              <img src="images/Fig07-065.png"/>
              <figcaption>Fig 07-065</figcaption>
            </figure>
            <p>This sort of configuration can have unintended consequences so there's a better way to edit existing
              rules. Instead of setting our configureWebpack to an object, we can use a function.</p>
            <p>So up here I'm going to set configureWebpack to a function:</p>
            <figure>
              <img src="images/Fig07-066.png"/>
              <figcaption>Fig 07-066.png</figcaption>
            </figure>
            <p>And that function takes in a config object, which is the existing config from the CLI. And then we can
              just mutate this config that was passed in here. So for our Coffee loader, I'm going to just append a rule
              to the module rule. So I'm going to say config.module.rules.push, and then I'm going to push on our
              CoffeeScript rules. So I'm just going to grab this here:</p>
            <figure>
              <img src="images/Fig07-067.png"/>
              <figcaption>Fig 07-067</figcaption>
            </figure>
            <p>and move it up here:</p>
            <figure>
              <img src="images/Fig07-068.png"/>
              <figcaption>Fig 07-068</figcaption>
            </figure>
            <p>Okay, so you can see I've mutated that config and added our CoffeeScript rule. That one was easy. The
              next one's going to be a little bit trickier. Let's start by storing our new rule in a variable. So I'm
              going to say const newRule =:</p>
            <figure>
              <img src="images/Fig07-069.png"/>
              <figcaption>Fig 07-069</figcaption>
            </figure>
            <p>and then let's grab this rule down here:</p>
            <figure>
              <img src="images/Fig07-070.png"/>
              <figcaption>Fig 07-070</figcaption>
            </figure>
            <p>and paste that up here:</p>
            <figure>
              <img src="images/Fig07-071.png"/>
              <figcaption>Fig 07-071</figcaption>
            </figure>
            <p>Okay, so now we have that in a variable available to us. Let's go ahead and delete this down here:</p>
            <figure>
              <img src="images/Fig07-072.png"/>
              <figcaption>Fig 07-072</figcaption>
            </figure>
            <p>
              Okay, so now we need to do something with this new rule. So first, let's find the index of the rule that
              we want to mutate. So I'm going to set an images rule index variable equal to
              config.module.rules.findIndex:</p>
            <figure>
              <img src="images/Fig07-073.png"/>
              <figcaption>Fig 07-073</figcaption>
            </figure>
            <p>
              And then we're going to find the rule where the test expression is targeting our image files. And the test
              object is a regex so that has a source, and the source is a string so we can use includes to search for
              our expression:</p>
            <figure>
              <img src="images/Fig07-074.png"/>
              <figcaption>Fig 07-074</figcaption>
            </figure>
            <p>Okay, so that should find the index of the url loader rule that we want to modify. And now I can splice
              the current rules array to replace the old rule with the new rule. So I'll say config.module.rules.splice.
              And I'll start slicing the array at imageRuleIndex and I'll replace that item, that one item, with our new
              rule:</p>
            <figure>
              <img src="images/Fig07-075.png"/>
              <figcaption>Fig 07-075</figcaption>
            </figure>
            <p>So this is a little bit complex and maybe not totally safe because we could have multiple rules that have
              that same test expression. But this will help you get the idea of how you might use the configureWebpack
              function in order to mutate state. And there are other options for editing existing config using webpack
              chain, but using webpack chain is beyond the scope of this course. Just be aware that if you start running
              into issues with modifying existing config, you can use webpack chain to help with mutating the
              config.</p>
            <p>
              Okay, so this rule should now be replaced with our new rule, so let's delete our webpack config and then
              let's go regenerate our config:</p>
            <figure>
              <img src="images/Fig07-076.png"/>
              <figcaption>Fig 07-076</figcaption>
            </figure>
            <p>Okay, let's go check this out. So in our webpack config here, let's search for this string again:</p>
            <figure>
              <img src="images/Fig07-077.png"/>
              <figcaption>Fig 07-077</figcaption>
            </figure>
            <p>And you can see now that we are only finding it once and it does have limit changed to 5000:</p>
            <figure>
              <img src="images/Fig07-078.png"/>
              <figcaption>Fig07-078</figcaption>
            </figure>
            <p>So now you've seen how you can edit the webpack config using the object syntax and the function syntax.
              And that's all there really is to editing the webpack configuration. You really have complete flexibility
              here, and all of this without ever having to eject from the Vue CLI so that we can continue to use the Vue
              CLI in the future to do upgrades and to handle most of our webpack config and other configuration for us.
              Cool, and that's all there is to editing webpack config.
            </p>
          </div>
          <div><h3>Summary</h3>
            <p>
              In this module, we learned about:</p>
            <ul>
              <li>Creating a basic Vue.js build using the CLI</li>
              <li>Using environment variables and build modes</li>
              <li>Deploying to a production web server</li>
              <li>Handling deep linking when using HTML5 history mode for client side routing</li>
              <li>Inspecting the built-in webpack config</li>
              <li>Customizing the webpack config</li>
            </ul>
            <p>And in this course, we've explored all the fundamentals you need to know for building and deploying
              quality, professional Vue. js applications. I hope you've enjoyed the course, and thanks for joining me on
              this journey to learn Vue. js fundamentals.</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
</body>
</html>
