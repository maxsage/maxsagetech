<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

<head>
  <meta charset="UTF-8">
  <title>maxsagetech - Vue JS Essentials</title>
  <script src="https://unpkg.com/vue"></script>
  <!--<link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"-->
  <!--integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" rel="stylesheet">-->
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
    integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
  </style>
</head>

<body>
  <div class="container" id="app">
    <div class="panel-group">
      <div class="panel panel-primary">
        <div class="panel-heading">
          <h2>An Introduction to Vue</h2>
        </div>
        <div class="panel-body">
          <h3>How to Get Help</h3>
          <p>In this section Stephen Grider discusses the best ways of contacting him if you get stuck during the
            course:
          </p>
          <ul>
            <li>The course discussion <a href="https://www.udemy.com/vue-js-course/learn/v4/questions/4408150">
                board</a> is usually checked once a
              day Monday through Friday.
            </li>
            <li>The second, and probably most effective, option is to contact Stephen via a direct <a
                href="https://www.udemy.com/user/sgslo/"> message</a> on Udemy.
            </li>
            <li>Lastly Stephen invites you to Tweet him at <a
                href="http://twitter.com/home?status=Message@ste_grider">@ste_grider</a></li>
          </ul>
          <h3>Our First Vue App</h3>
          <p>In this section Stephen supplies a link to a <a target="_blank" href="http://goo.gl/NrtSgX">Codepen</a>
            example which demonstrates the power of Vue.
          </p>
          <p>Codepen is similar to many of the other (JSFiddle etc.) prototyping tools out there. We add HTML, CSS and
            JS code to the relevant windows and the result is shown in the output window.
          </p>
          <p>The Codepen example already includes a small amount of JavaScript that Stephen has authored to save a bit
            of time.
          </p>
          <p>Add the following code to the HTML tab:</p>
          <figure>
            <pre><code class="language-html">&lt;div id=&quot;root&quot; @mousemove=&quot;onMouseMove&quot;&gt;
&lt;/div&gt;</code></pre>
            <figcaption>Fig 01-001</figcaption>
          </figure>
          <p>Note the @ symbol prefixing the mousemove attribute, the fact that the mousemove attribute is not
            capitalized and that we are using double quotes around the word onMouseMove.
          </p>
          <p>Add two additional child divs. On the first div add a :style option setting the value to styleOne. Do the
            same for the second div but specify a style of styleTwo instead:
          </p>
          <figure>
            <pre><code class="language-html">&lt;div id=&quot;root&quot; @mousemove=&quot;onMouseMove&quot;&gt;
  &lt;div :style=&quot;styleOne&quot;&gt;&lt;/div&gt;
  &lt;div :style=&quot;styleTwo&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>
            <figcaption>Fig 01-002</figcaption>
          </figure>
          <p>That's all the HTML we will need. Open the JS tab and declare a brand new Vue application passing it an
            empty object:
          </p>
          <figure>
            <pre><code class="language-javascript">new Vue({
});</code></pre>
            <figcaption>Fig 01-003</figcaption>
          </figure>
          <p>Next we will add in some configuration to the object.</p>
          <p>First we will add the el property which specifies where the application should attempt to render itself
            inside of our HTML structure:
          </p>
          <figure>
            <pre><code class="language-javascript">new Vue({
  el: '#root',
});</code></pre>
            <figcaption>Fig 01-004</figcaption>
          </figure>
          <p>Next we will initialize the data property of our application (we will talk a lot about data in future
            modules):
          </p>
          <figure>
            <pre><code class="language-javascript">new Vue({
  el: '#root',
  data: { styleOne: {}, styleTwo: {} },
});</code></pre>
            <figcaption>Fig 01-005</figcaption>
          </figure>
          <p>data is an object that contains two empty objects - styleOne and styleTwo.</p>
          <p>Next add the methods option:</p>
          <figure>
            <pre><code class="language-javascript">new Vue({
  el: '#root',
  data: { styleOne: {}, styleTwo: {} },
  methods: {
    onMouseMove(event) {
    }
  }
});</code></pre>
            <figcaption>Fig 01-005</figcaption>
          </figure>
          <p>methods is also an empty object that is going to have one function tied to it called onMouseMove which will
            be called with some event.
          </p>
          <p>Inside the function body add the following code:</p>
          <figure>
            <pre><code class="language-javascript">new Vue({
  el: '#root',
  data: { styleOne: {}, styleTwo: {} },
  methods: {
    onMouseMove(event) {
      this.styleOne = transform(-event.clientX / event.clientY);
      this.styleTwo = transform(event.clientX / event.clientY);
    }
  }
});</code></pre>
            <figcaption>Fig 01-006</figcaption>
          </figure>
          <p>Make sure you have the X and Y capitalized inside these statements.</p>
          <p>In the CSS tab add the following styling:</p>
          <figure>
            <pre><code class="language-css">#root {
  height: 100vh;
  width: 100vw;
}

#root div {
  position: absolute;
  height: 100%;
  width: 100%;
  box-shadow: 0 0 50px grey;
}</code></pre>
            <figcaption>Fig 01-007</figcaption>
          </figure>
          <p>Finally in Codepen click the Assets button and from the Patterns tab select a the wavy lines pattern (which
            will copy it to the clipboard). Back in the CSS tab paste the clipboard in after the box-shadow declaration:
          </p>
          <figure>
            <pre><code class="language-css">#root {
  height: 100vh;
  width: 100vw;
}

#root div {
  position: absolute;
  height: 100%;
  width: 100%;
  box-shadow: 0 0 50px grey;
  background-image: url('data:image/svg+xml,%3Csvg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;100&quot; height=&quot;18&quot; viewBox=&quot;0 0 100 18&quot;%3E%3Cpath fill=&quot;%239C92AC&quot; fill-opacity=&quot;0.4&quot; d=&quot;M61.82 18c3.47-1.45 6.86-3.78 11.3-7.34C78 6.76 80.34 5.1 83.87 3.42 88.56 1.16 93.75 0 100 0v6.16C98.76 6.05 97.43 6 96 6c-9.59 0-14.23 2.23-23.13 9.34-1.28 1.03-2.39 1.9-3.4 2.66h-7.65zm-23.64 0H22.52c-1-.76-2.1-1.63-3.4-2.66C11.57 9.3 7.08 6.78 0 6.16V0c6.25 0 11.44 1.16 16.14 3.42 3.53 1.7 5.87 3.35 10.73 7.24 4.45 3.56 7.84 5.9 11.31 7.34zM61.82 0h7.66a39.57 39.57 0 0 1-7.34 4.58C57.44 6.84 52.25 8 46 8S34.56 6.84 29.86 4.58A39.57 39.57 0 0 1 22.52 0h15.66C41.65 1.44 45.21 2 50 2c4.8 0 8.35-.56 11.82-2z&quot;%3E%3C/path%3E%3C/svg%3E');
}</code></pre>
            <figcaption>Fig 01-008</figcaption>
          </figure>
          <p>Now run the application and you will see an interesting visualization. This demonstrates the power of Vue -
            just a small amount of code can produce impressive results.
          </p>
          <h3>App Overview</h3>
          <p>In the last section we worked on a little Codepen visualization tool. We are not going to go through the
            code we wrote for this example. Instead we are going to create another little Codepen application that will
            give you a better idea of the structure of a Vue application.
          </p>
          <p>The application we are going to build is an Identicon generator:</p>
          <figure>
            <img src="./images/vuejsessentials/Fig01-009.png" />
            <figcaption>Fig 01-009</figcaption>
          </figure>
          <p>The user will enter a small amount of text into the input box. We are going to take that text and use it to
            create what is called an Identicon - which is short for Identifying Icon. An Identicon is a colourful image
            often used when a user doesn't supply their own image. The Identicon graphic is based around the input
            string. Therefore if you enter the same input string twice the two images will be identical.
          </p>
          <p>We are going to use a library that actually creates the Identicon but we will need to concern ourselves
            with - how we take in user input and how we call functions.
          </p>
          <h3>A Codepen Starter</h3>
          <p>We will start working on this application by creating a new Codepen instance. The starter template can be
            found at the following address:
          </p>
          <a target="_blank" href="http://goo.gl/4TG4Bq">Codepen Identicon Example</a>
          <p>There is a tiny amount of configuration that has already been performed for us in this template. You can
            see this by clicking on the gear in the JS panel which will open the Pen Settings window with the JavaScript
            tab pre-selected:
          </p>
          <figure>
            <img src="./images/vuejsessentials/Fig01-010.png" />
            <figcaption>Fig 01-010</figcaption>
          </figure>
          <p>Towards the bottom of the window you will see a link to the jdenticon.min.js library which we will use to
            create the Identicon. There is also a link to the vue.min.js library.
          </p>
          <p></p>
          <h3>Vue Templates and Instances</h3>
          <p>In order for our application to work we will need:</p>
          <ul>
            <li>Some starting text and form input on the screen.</li>
            <li>Something to happen when a user types in the input.</li>
          </ul>
          <p>Any time a user enters text into the Input text field we want to run some JavaScript code that will create
            the Identicon image itself and then somehow output that to the screen as well.
          </p>
          <p>So we have just described two aspects of our application.</p>
          <p>On the one hand we have the aspect of somehow rendering or getting content to appear on the screen.
          </p>
          <p>On the other hand, in the second list item, we are talking about somehow interacting with user input.
          </p>
          <p>In the Vue.js world we map up these two different tasks to two different elements or two different parts of
            a Vue application
          </p>
          <p>The first part describes the content and structure that appears on the screen. That task is handled by
            creating what is called a Vue template. So we create new templates to show information to users. Vue
            Templates are created in HTML in our application.
          </p>
          <p>The second part - handling user input is going to be covered by creating what is called a Vue instance. A
            Vue instance is created by writing out some amount of Javascript code. The Vue instance is responsible for
            actually dealing with user input. So, in this example, anytime the user types some text into the input field
            the Vue instance will take the entered text and generate an Identicon out of it, and then pass the identicon
            back to the template which will then present it to the user on the screen.
          </p>
          <p>This scenario describes just one possible way of many of structuring a Vue application. An example of a
            different configuration would consist of the Vue Template being created in the Javascript instead of the
            Html.
          </p>
          <h3>Creating the Template</h3>
          <p>In the last section we spoke about the differences between a Vue template and a Vue Instance. We are now
            going to get started on creating our Vue Template - the presentation layer for our application. For the
            first iteration of our template we are going to write essentially just plain Html.
          </p>
          <p>In Codepen add the following Html:</p>
          <figure>
            <pre><code class="language-html">&lt;div&gt;
  &lt;h3&gt;My Identicon Generator&lt;/h3&gt;
  &lt;div&gt;
    Input:
    &lt;input /&gt;

  &lt;/div&gt;
  &lt;div&gt;
    Output:
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
            <figcaption>Fig 01-011</figcaption>
          </figure>
          <p>This is our first Vue template (we will re-visit this Html later and add some more additional syntax that
            will make it clear that we are not working with plain Html here - but a Vue template).
          </p>
          <h3>Linking Templates and Instances</h3>
          <p>In the last section we created our Vue template on the Html side of our application. We are now going to
            define our Vue instance in the Javascript part of our application. In the JS Panel in Codepen add the
            following code:
          </p>
          <figure>
            <pre><code class="language-javascript">new Vue({

});</code></pre>
            <figcaption>Fig 01-012</figcaption>
          </figure>
          <p>Inside of the object defined by the curly braces we are going to add in a bunch of different properties
            over time. All these different properties are going to serve to customize how this Vue instance behaves. The
            Vue instance and the properties contained within are where a lot of the complexity of Vue itself comes into
            play. Understanding these properties and using them correctly is what will make you a professional Vue
            engineer.
          </p>
          <p>The first property that we are going to make use of is the <code class="language-html">el</code> property
            which is short for the word element. :</p>
          <figure>
            <pre><code class="language-javascript">new Vue({
  el:
});</code></pre>
            <figcaption>Fig 01-013</figcaption>
          </figure>
          <p>The <code class="language-">el</code> property ties one Vue instance to one Vue template that has been
            defined in our application. To achieve this add an <code class="language-">id</code> attribute to the root
            <code class="language-">div</code> in your Vue template:
          </p>
          <figure>
            <pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;h3&gt;My Identicon Generator&lt;/h3&gt;
  &lt;div&gt;
    Input:
    &lt;input /&gt;

  &lt;/div&gt;
  &lt;div&gt;
    Output:
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
            <figcaption>Fig 01-014</figcaption>
          </figure>
          <p>Now update the Vue instance's el: property to point to this div using the id:</p>
          <figure>
            <pre><code class="language-javascript">new Vue({
  el:  '#app'
});</code></pre>
            <figcaption>Fig 01-015</figcaption>
          </figure>
          <p>The #app we supplied provides a DOM Query selector to our Vue instance that tell's it exactly where it's
            template exists inside the DOM. This is what really links together the Javascript and Html sides of our
            application.
          </p>
          <h3>Step by Step Implementation</h3>
          <p>In the last section we defined our Vue instance and then provided an <code class="language-">el</code>
            property that told our Vue instance what area of the DOM it was responsible for.
          </p>
          <p>We will see change inside of our Html template only as we start to add code to our Vue instance.
          </p>
          <p>The steps that are going to occur inside of our application are as follows:</p>
          <ul>
            <li>Detect that the user has entered some new text.</li>
            <li>Get the text the user entered.</li>
            <li>Use that text to generate a new identicon.</li>
            <li>Show the identicon next to the Output div</li>
          </ul>
          <p>One detail worth highlighting is that we want to update the identicon displayed as the user enters each
            character into the text input. We are not going to wait for the user to type the whole string and then press
            enter. It is with every single key press that we are going to generate a new identicon. Once we get the text
            the user entered we can use it to generate the new Identicon itself (at which point we will use the
            Identicon library). Finally we output the Identicon to the screen next to the Output section.</p>
          <p>The four steps above may seem very obvious. However the reason we did this is that for everyone of the
            above steps Vue has a different feature built-in to help you implement each step (this will help you learn
            about different pieces of the Vue api)
          </p>
          <h3>Defining Instance Methods</h3>
          <p>In the last section we spoke about the four different steps we are going to implement to get our
            application working. In this section we are going to start off with step number one - detecting when the
            user enter some new text and responding by running some custom Javascript code.
          </p>
          <p>So we will focus on this first step inside this section. To implement this step we are going to add a
            method to the Vue instance. That method will get called anytime the user enters some new text.
          </p>
          <p>What is a method? A method is a function that is going to be tied to our Vue instance. That function can
            then be called at any point in time to somehow implement or update our user interface.
          </p>
          <p>Let's first begin by implementing the method and then we'll figure out how to call it any time a user
            enters some text. First the method:
          </p>
          <figure>
            <pre><code class="language-javascript">new Vue({
  el:  '#app',
  methods: {

  }
});</code></pre>
            <figcaption>Fig 01-016</figcaption>
          </figure>
          <p>Methods is going to have an object tied to it. Right now there's just one method we care about which is the
            method that's going to be called anytime a user enters some text into the input field. But over time if we
            had a more complicated template with more text inputs or more buttons of just more ways of interacting with
            it we might end up having many different methods defined inside the object.
          </p>
          <p>So let's begin by implementing this method that's going to be called anytime a user enters some text.
          </p>
          <figure>
            <pre><code class="language-javascript">new Vue({
  el:  &apos;#app&apos;,
  methods: {
    onInput: function() {
      console.log(&apos;Someone typed something&apos;);
    }
  }
});</code></pre>
            <figcaption>Fig 01-017</figcaption>
          </figure>
          <p>It is not mandatory for the function name to be <code class="language-">onInput</code>, it just makes it
            clear that this function will be called anytime the user enters some text. Inside the function we write a
            message to the console. View the console in Chrome. When you type in the input text field you will note that
            you don't see anything written to the console.
          </p>
          <p>This is because even though we've defined a method called <code class="language-">onInput</code> we have
            not instructed our Vue instance or our Vue template that we want our method to be called when a user enters
            text into the input.
          </p>
          <h3>Defining Vue Directives</h3>
          <p>In the last section we defined our first method inside the methods object inside our Vue instance. We
            defined a function called <code class="language-">onInput</code> that hopefully will be executed anytime a
            user enters some text into the input.
          </p>
          <p>We will add a Vue directive to the input field to hook it up to our <code class="language-">onInput</code>
            method:</p>
          <figure>
            <pre><code class="language-html">&lt;input v-on:input=&quot;onInput&quot; /&gt;</code></pre>
            <figcaption>Fig 01-018</figcaption>
          </figure>
          <p>If we now enter some text into the input we see messages in the console.</p>
          <p>The above code is an example of a Vue directive. A directive is a piece of template syntax inside a view
            that somehow enhances the behavior of otherwise normal HTML code.
          </p>
          <p>So behind the scenes when our instance first boots up it looks at the <code class="language-">el:</code>
            property and, as we said previously, it tries to find some element inside the DOM with an <code
              class="language-">id</code> of <code class="language-">app</code> - in this example it finds the root
            div has this <code class="language-">id</code>, so it scans over all of the Html contained in the <code
              class="language-">div</code> looking for any directives like the one we just added.</p>
          <p>When it finds a directive it performs a couple of additional steps to parse the directive and figure out
            how to correctly process it. In our case we have to find a directive that sets up an event handler.
          </p>
          <p>On the left hand-side of the Vue directive in this statement:</p>
          <figure>
            <pre><code class="language-"> &lt;input v-on:input=&quot;onInput&quot; /&gt;</code></pre>
            <figcaption>Fig 01-019</figcaption>
          </figure>
          <p><code class="language-">v-on</code> means we are trying to define an event handler. We then place a colon
            and then the name of the event that we want to watch for - in this case <code class="language-">
              input</code>. So any time a user enters input into this input tag Vue is going to attempt to do something
            for us. The thing that it actually does is defined to the right of the equals sign - in our case we call the
            <code class="language-">onInput</code> method.</p>
          <p>The event handler directive is one of the more straightforward Vue directives but over time we will start
            to see some more complicated directives.
          </p>
          <h3>Retrieving Event Information</h3>
          <p>In the last section we used a Vue directive to tie an event that occurred to our text input to the <code
              class="language-">onInput</code> method that we defined inside of our Vue instance.
          </p>
          <p>Like I said previously Vue directives are one of the more complicated parts of Vue - which is why, many
            times throughout this course, we are going to review how they work.
          </p>
          <p>Now we have the ability to run a function anytime the user types in this input we need to move to our next
            step which is to somehow get the text that the user entered.
          </p>
          <p>To do this we are going to use our <code class="language-">onInput</code> function which gets called with
            a single argument that we usually refer to as the event object. This is an object that contains a bunch of
            different information about the event that just occurred - in our case an input event. The event object has
            the actual text that the user entered so we can make use of that argument to figure out exactly what text
            the user typed.
          </p>
          <p>Inside the methods object in the Vue instance find the onInput function and reference the single argument
            that is provided to it - like I just said we usually refer to this as the event object. The event object has
            a property called <code class="language-">target.value</code> and that will be a reference to the text
            that the user entered. For the moment let's just write that value to the console:
          </p>
          <figure>
            <pre><code class="language-javascript">new Vue({
  el:  '#app',
  methods: {
    onInput: function() {
      console.log(event.target.value);
    }
  }
});</code></pre>
            <figcaption>Fig 01-020</figcaption>
          </figure>
          <p><code class="language-">event</code> is a reference to the event that just occurred, <code
              class="language-">target</code> is a reference to the Html element that just had the event applied to it
            and then <code class="language-">value</code> is a reference to the current value of that text input.
          </p>
          <p>So if you now enter some text into the input field you should see it appearing over in the console.
          </p>
          <h3>Imperative vs Declarative Programming</h3>
          <p>In the previous section we figured out how to use the event object to get access to the text that the user
            entered into our text input. Next, instead of moving onto step 3 - Use that text to generate a new
            identicon, we are going to take a slight detour.
          </p>
          <p>We are going to get a better idea of how to structure and build Vue applications.</p>
          <p>We are going to discuss the difference between declarative and imperative programming styles especially as
            applied to Vue applications in the world of web development.
          </p>
          <p>In the world of web development from say maybe 2005 all the to 2013 or so we practiced a programming style
            referred to as imperative programming. With imperative programming we write out code that lists exactly what
            our application should do step by step.
          </p>
          <p>So our code follows a pattern very similar to the list we described earlier:</p>
          <ul>
            <li>Detect that the user has entered some new text.</li>
            <li>Get the text the user entered.</li>
            <li>Use that text to generate a new identicon.</li>
            <li>Show the identicon next to the Output div</li>
          </ul>
          <p>This is an example of an imperative design flow where we list out exactly what to do step by step.
          </p>
          <p>By contrast in the world of declarative programming we instead list out some rules that our application
            should follow. We then provide what we refer to as some initial state to our application and we let those
            rules kind of define how our application behaves.
          </p>
          <p>Now these very quick descriptions I'm giving you probably don't make a lot of sense so let's walk through
            the differences between imperative and declarative programming by walking through a little analogy.
          </p>
          <p>OK so I want you to imagine for just a second that maybe you and I are not building software anymore. Maybe
            instead you and I bake cakes for a living. So we go into work every single day and we have to bake a cake.
            Now unfortunately you and I maybe very poor cooks and we don't really know how to bake a cake so our boss
            sits down and gives us a list of directions - essentially a recipe.
          </p>
          <p>So we have one recipe written in an imperative style:</p>
          <ul>
            <li>Mix 1 cup flour and 1 cup sugar in a bowl.</li>
            <li>Add 1 egg to the bowl and mix thoroughly.</li>
            <li>Pour mixture into a pan.</li>
            <li>Put the pan into the oven for 30 minutes at 350F.</li>
          </ul>
          <p>And then we have the same recipe written in a declarative style:</p>
          <ul>
            <li>1 egg, 1 cup flour, 1 cup sugar</li>
            <li>If ingredients have been mixxed, put them in a pan</li>
            <li>If ingredients are unmixed, mix them in a bowl</li>
            <li>If ingredients are in a pan, put in oven for 30 mins at 350F</li>
          </ul>
          <p>So let's walk through both these recipes and get a better idea of the differences between imperative and
            declarative approaches.
          </p>
          <p>Imperative approaches are characterized by step by step directions. They tell you - start with step 1, then
            go directly to step 2 and do it, then go to step 3 etc. After you have gone through this entire list of
            steps you eventually end up with some end product.
          </p>
          <p>So in the context of baking a cake maybe our imperative recipe tells us to take these raw ingredients, mix
            them together, pour the ingredients into a pan and then put that pan into an oven - after you go through
            these steps you end up with a cake.
          </p>
          <p>In a declarative world it's a little bit different as you might imagine.</p>
          <p>So with a declarative recipe we would separate out our recipe into maybe two separate parts. We would start
            out with one part that lists, what we might refer to, as the initial state of our recipe. The initial state
            would be like the variables and in the case of a recipe our variables would be maybe our ingredient
            quantities or the ingredient types. We then take this initial state or this initial listing of ingredients
            and then we apply a set of rules to them. So you can kind of imagine that we take these ingredients or this
            initial recipe, we pass it through the rules one time.
          </p>
          <p>Then maybe after that first time we then stick it into the rules a second time and then maybe after we go
            through the second time we go through a third time - repeating the process over and over until eventually we
            come out the other side with a baked cake.
          </p>
          <p>So it starts to get really important to understand how we might structurally structure these rules in a
            declarative approach.
          </p>
          <p>So for the rules in a declarative recipe we might say okay let's examine our ingredients or our state, if
            our ingredients have been mixed then put them in a pan. Well, clearly with our initial state that doesn't
            quite match - we have not yet mixed our ingredients - so let's go down to rule number 2 which says if the
            ingredients are unmixed then mix them together in a bowl. Ok, well that's good, we have unmixed ingredients
            so we will mix them all together in a bowl.
          </p>
          <p>So, maybe now, instead of having one egg, cup flour, and sugar we would instead have one bowl mixed
            ingredients. We then take that state and apply it to our rules again.
          </p>
          <p>We've now got our mixed ingredients so we're going to look at rule number 1 which says if ingredients have
            been mixed put them in a pan.
          </p>
          <p>Ok that applies to us so let's do that - so now we have one batch ingredients in a pan we work through our
            rules again.
          </p>
          <p>Rule number three says if we're in a pan then put in the ovent for 30 minutes at 350F. Well that definitely
            applies to us. So we take this and we put it in the oven for 30 minutes at 350F and then finally we come out
            with a baked cake.
          </p>
          <p>So in the world of declarative programming, or declarative cooking I suppose, we have some state that we
            start off with, then we take that state and apply a set of rules to it.
          </p>
          <p>Now I know that this might sound like it's a real complicated approach for what we are trying to build
            right now so I took the liberty of writing our our applications rules (of sorts) in an imperative and
            declarative approach.
          </p>
          <p>So let's consider how we might build our Identicon application in an imperative approach and a declarative
            approach.
          </p>
          <p>So in an imperative approach to our current program, which is kind of what we're following now, we might
            say that whenever a user enters some text we want to:
          </p>
          <ol>
            <li>Retrieve the new input value</li>
            <li>Turn the input value into an identicon</li>
            <li>Put the identicon on the screen</li>
          </ol>
          <p>Now this might seem like a very direct and easy to understand flow and you might be thinking - "Hey
            imperative programming - I understand this, it's what I'm used to"
          </p>
          <p>Well maybe for very simple flows like this it makes sense but most web applications, that we spend any
            amount of time building, have flows that are much more complicated than this.
          </p>
          <p>So even though I'm giving you a very simple example here I hope that you can, kind of, extrapolate this
            example and imagine a more complicated flow where going step by step in code might be a little bit more
            challenging.
          </p>
          <p>Now let's look at a declarative approach:</p>
          <figure>
            <img src="./images/vuejsessentials/Fig01-021.png" />
            <figcaption>Fig 01-021</figcaption>
          </figure>
          <p>So with a declarative approach maybe we would say that we've got some initial state or some initial
            ingredients of sorts of a single variable called something like textInput which maybe starts off as an empty
            string.
          </p>
          <p>We'll then take this initial state, of sorts, and apply it to this set of rules that we defined inside of
            our Vue instance. So maybe we'll say "If a user enters text then update text input". Well that doesn't
            really apply to us so we'll say "If the template is rendered calculate the identicon". Well that doesn't
            really apply to us either so we'll say "If text input is updated re-render the template." Well that doesn't
            apply either so we'll just wait around for something to happen.
          </p>
          <p>So maybe then at some point a user updates our text input and when that happens we might apply rule number
            1 - "If user enters text, update textInput". So we update textInput:
          </p>
          <figure>
            <pre><code class="language-javascript">textInput = &quot;abcd&quot;</code></pre>
            <figcaption>Fig 01-022</figcaption>
          </figure>
          <p>And then we look at the other rules that are listed. Rule number 2 - "If template is rendered, calculate
            the identicon". This does apply so we'll re-render the template and now if we look back at rule number two -
            "If template is rendered, calculate the identicon." so let's calculate the identicon and then render it to
            the screen.
          </p>
          <p>So I know that the rules we listed for the identicon application don't quite translate from the idea of
            baking to what we're doing but it gives you the idea that inside of our Vue instance we'll declare some type
            of data or variable. Then, inside of that instance we'll declare the set of different rules that tells our
            Vue instance how it should behave whenever something occurs inside of our application.
          </p>
          <p>So, again, in general you and I, inside a Vue, want to strive for this more declarative programming style
            as opposed to a more imperative approach. Again, I know that imperative programming might seem like a little
            bit more clear and obvious and it might be more challenging to understand exactly why we would take the
            declarative approach but in general a declarative approach scales very nicely for larger applications.
          </p>
          <p>Ok, now we've got this idea of declarative programming in mind, in the next section we'll talk a little bit
            more about how we can implement these declarative rules into our Vue instance and get our application
            working.
          </p>
          <h3>Declarative Apps with the Vue API</h3>
          <p>In the last section we talked about some of the differences between imperative and declarative programming.
            We're now going to take this idea of declarative programming and apply it to our actual application with
            some real terminology that is used in Vue instances.
          </p>
          <p>So the first thing we're going to do is take a look at each of these steps/rules here:</p>
          <ul>
            <li>textInput = "abcd1234"</li>
            <li>If user enters text, update 'textInput'</li>
            <li>If template is rendered calculate the identicon</li>
            <li>If 'textInput' is updated re-render the template</li>
          </ul>
          <p>I want you to consider the purpose of each of these rules and to imagine when each of these rules would be
            applied.
          </p>
          <p>So at the very top we start out with that initial state of sorts (or initial list of ingredients) which we
            might also refer to as our data inside our application. If we had to characterize the purpose of the the
            first rule: "If user enters text, update 'textInput'" we would say it updates our data or state. So this is
            really an update action of an action that changes things inside of our application.
          </p>
          <p>The second step: "If template is rendered, calculate the identicon" is a step that uses our data/state to
            show stuff on the screen. Another way to put it would be to say that this step consumes data to present it
            to users inside of our application.
          </p>
          <p>The last step: "If 'textInput' is updated re-render the template" just kind of happens automatically with
            the Vue behind the scenes. So anytime you or I change our state or change our data inside of our application
            our Vue instance is going to automatically update everything on the screen.
          </p>
          <p>Let's now apply some more precise terminology to each of these steps.</p>
          <p>In the following figure the terms on the right hand side are the different properties that you and I are
            going to eventually define on our Vue instances to implement each of the different steps:
          </p>
          <figure>
            <img src="./images/vuejsessentials/Fig01-023.png" />
            <figcaption>Fig 01-023</figcaption>
          </figure>
          <p>So first off, at the very top, we've been referring to this kind of initial list of ingredients or our
            initial state of sorts. In a Vue instance we refer to this as a property defined as 'data'. So you and I are
            going to define a data property inside of our Vue instance and that's going to tell our instance what the
            starting ingredients, of sorts, are inside our application.
          </p>
          <p>Next, you and I are going to define a couple of different methods. So far we only defined one method - the
            <code class="language-">onInput</code> method - but the purpose of the method's property is to define a
            bunch of functions that are supposed to somehow update our data. So all the functions you're going to see on
            methods are going to describe how we might update the data inside of our application. Looking at our current
            application that definitely matches up.
          </p>
          <p>The computed property is a little bit more complicated. Anytime you and I want to kind of consume data and
            get it into our actual template, or show it on the screen in some fashion, we're going to use a computed
            property.
          </p>
          <p>So, one more time, these are three pieces of terminology or properties that you and I are doing to define
            inside our Vue instance eventually:
          </p>
          <p><strong>data</strong> initializes the data inside of our application</p>
          <p><strong>methods</strong> changes/updates the data inside of our application</p>
          <p><strong>computed</strong> consumes the data and formats/transforms it for display on the screen
          </p>
          <figure>
            <img src="./images/vuejsessentials/Fig01-024.png" />
            <figcaption>Fig 01-024</figcaption>
          </figure>
          <p>Now obviously the text that a user enters into our application is in itself like a viewable value but, in
            this example, we are trying to display an identicon so a viewable value would be like taking that text and
            turning it into an identicon.
          </p>
          <p>In the following figure you can see a simplified version of the previous figure:</p>
          <figure>
            <img src="./images/vuejsessentials/Fig01-025.png" />
            <figcaption>Fig 01-025</figcaption>
          </figure>
          <p>So we've now got a good idea of some of these different parts of the Vue API. In the next section we'll
            start to use the data, methods and computed properties.
          </p>
          <h3>Data, Computed, and Methods</h3>
          <p>In the last section we took the idea of declarative programming and applied it to our application and then
            more specifically took a look at the Vue API and some of the different properties that we're going to define
            on our Vue instance.
          </p>
          <p>So let's now go back over to Codepen and start defining these different properties inside of the JavaScript
            side of our application.
          </p>
          <p>Now, you will recall that we already defined that methods property. I'm going to add a comment inside
            methods object to remind me of it's purpose:
          </p>
          <figure>
            <pre><code class="language-javascript">new Vue({
  el:  '#app',
  methods: { // Use these function to change data
    onInput: function() {
      console.log(event.target.value);
    }
  }
});</code></pre>
            <figcaption>Fig 01-026</figcaption>
          </figure>
          <p>Next I will define the data and computed properties with comments to describe their purpose:</p>
          <figure>
            <pre><code class="language-javascript">new Vue({
  el:  '#app',
  data: { // Initialize our list of 'ingredients'

  },
  computed: { // Turn data into viewable values

  },
  methods: { // Use these function to change data
    onInput: function() {
      console.log(event.target.value);
    }
  }
});</code></pre>
            <figcaption>Fig 01-027</figcaption>
          </figure>
          <p>Now one thing that might be a little bit misleading here is that with the methods property we have clearly
            defined a function. However, inside of this computed object we are also going to define functions -
            functions that are going to be executed to turn our data into viewable values. But with the data property we
            are not defining functions, instead we are defining simple properties and private property names and
            property values. As an example we could initialize a textInput property like so:
          </p>
          <figure>
            <pre><code class="language-javascript">  data: { // Initialize our list of 'ingredients'
    textInput: ''
},</code></pre>
            <figcaption>Fig 01-028</figcaption>
          </figure>
          <p>So, again, with data we define simple key value pairs that have say strings or numbers or arrays or
            objects. But with the computed and methods properties we define functions on both and those functions are
            executed to either update our data (methods property) or turn our data into viewable values (computed
            property)
          </p>
          <p>Now that we've added in some comments to further guide us we will continue in the next section to start
            adding code to the data and computed properties.
          </p>
          <h3>Updated Data Values</h3>
          <p>In the last section we added in our data property and our computed property. We also added in some comments
            to describe their purpose inside of this Vue instance. In this section we're going to go back to our <code
              class="language-">onInput</code> function inside of the methods object.
          </p>
          <p>Remember all of the functions inside of methods are intended to somehow update our data and anytime we
            updated our data it's going to cause our Vue instance to update the HTML that is displayed inside the
            browser.
          </p>
          <p>At present we're just taking the value that the user types in - which is <code class="language-">event
            .target.value</code> and logging it to the console. That's not incredibly useful. I think we should
            probably
            remove that console log and replace it with something that's going to update the <code
              class="language-">textInput</code> property in our data object. Remember <code class="language-">
              textInput</code> is supposed to reflect the current value of the text input form field defined here:
          </p>
          <figure>
            <pre><code class="language-html">&lt;div&gt;
  Input:
  &lt;input /&gt;
&lt;/div&gt;</code></pre>
            <figcaption>Fig 01-029</figcaption>
          </figure>
          <p>We can kind of imagine this <code class="language-">data</code> property of <code class="language-">
            textInput</code> as being like our list of ingredients and based on what the value of <code
              class="language-">textInput</code> is inside of the data object we will do different things to render
            different stuff out onto the page.
          </p>
          <p>So let's remove the consolelog statement and then to update the value of this <code class="language-">
            textInput</code> value data property we will add the following code:
          </p>
          <figure>
            <pre><code class="language-javascript">methods: { // Use these function to change data
  onInput: function() {
      this.textInput = event.target.value;
  }
}</code></pre>
            <figcaption>Fig 01-030</figcaption>
          </figure>
          <p>Now one thing that's very important here that I want to point out is that we said simply <code
              class="language-">this.texInput</code> we did not say anything like <code
              class="language-">this.data.textInput</code>. We only used the word <code class="language-">data</code>
            when we first initialized the data property. After that to refer to any of
            the properties that are initialized inside of here we simply write <code class="language-">this.</code> and
            then the property name.
          </p>
          <p>Now, what I want to be really crystal clear about because I mentioned this in passing one or two videos ago
            is that anytime we update the value of one of our <code class="language-">data</code> properties it causes
            our Vue instance to automatically re-render inside of the browser window. At present our template is not
            making use of the <code class="language-">textInput</code> property at all so you won't currently see any
            changes in the browser. However, as soon as we start updating or making use of <code
              class="language-">textInput</code>
            inside of our actual template you're going to see that anytime we run this <code
              class="language-">onInput</code> function everything inside the browser window is going to automatically
            update as well which is a very nice feature. We don't have to forcibly say "Please re-render my application"
            or anything like that.
          </p>
          <p>So just to bring everything full circle now I want to go back to one of the diagrams we were just looking
            at and walk through the process of what we've done now with the <code class="language-">data</code> property
            and the <code class="language-">onInput</code> function:
          </p>
          <figure>
            <img src="./images/vuejsessentials/Fig01-031.png" />
            <figcaption>Fig 01-031</figcaption>
          </figure>
          <p>We said that we have some initial starting data of <code class="language-">textInput</code> equal to
            empty string. So that's how our application first starts off. We then sit around and wait and then at some
            point in time the <code class="language-">onInput</code> method is executed. So the user enters some text
            and inside the method we update the value of <code class="language-">textInput</code>. So let's imagine that
            maybe the user enters in text of "abcd". So
            after they enter that text we're going to update the <code class="language-">textInput</code> value. So now
            the <code class="language-">textInput</code> property
            in <code class="language-">data</code> has a value of "abcd". Now because <code
              class="language-">textInput</code> has been updated the template is re-rendered automatically by Vue.
            Next, as a result of the template being re-rendered we calculate the identicon by using one of our computed
            functions. We have not yet defined this function but we will in just a second.
          </p>
          <p>We are going to talk about the data, methods and computed properties non-stop throughout this course so if
            it seems confusing right now don't sweat it because we're definitely going to get a lot of practice with it.
          </p>
          <p>Let's continue in the next section where we're going to start working on our computed properties and
            hopefully start to bring everything full circle.
          </p>
          <h3>Computed Properties</h3>
          <p>We've now got our <code class="language-">data</code> property being initialized here and we've got some
            way for our data to be initialized over time whenever our user does something inside of our application.
            It's now time to turn to the last step here which is to take our data and turn it into an actual viewable
            value. To be entirely clear our data is already in kind of like a viewable value - it's a plain text string.
            Obviously we can show it inside of our template and have our users kind of view the output.
          </p>
          <p>However that's not actually what we want our users to view. We don't care about showing them the text that
            they just entered. Instead, we want to show them an identicon - so we need to do some processing of oiur
            data before it actually gets displayed on the screen. Anytime we want to do some calculation on a value
            before it gets displayed on the screen that's where we make use of a computed function.
          </p>
          <p>So inside of the computed object is where we're going to define a new function which I'm going to call
            identicon like so:
          </p>
          <figure>
            <pre><code class="language-javascript">computed: { // Turn data into viewable values
  identicon: function() {
  }
},</code></pre>
            <figcaption>Fig 01-032</figcaption>
          </figure>
          <p>So any time the identicon function gets called you and I are going to return something that's going to get
            the identicon displayed on the screen.
          </p>
          <p>Now as a quick reminder when we first made use of this CodePen then we already got you access to this
            library call jdenticon (you can verify this by clicking the settings button, selecting the JavaScript tab
            and viewing the external scripts section). So we're going to write some code that's going to make use of
            this library right here to produce the actual identicon based on the text input that the user has provided
            to us.
          </p>
          <p>So inside the identicon function we're going to make use of that jdenticon library:</p>
          <figure>
            <pre><code class="language-javascript">computed: { // Turn data into viewable values
identicon: function() {
  jdenticon.toSvg();
}</code></pre>
            <figcaption>Fig 01-033</figcaption>
          </figure>
          <p>First we'll pass in the value of <code class="language-">textInput</code> because that's kind of like the
            seed of sorts from which our identicon gets calculated. Remember that we can reference any of the properties
            in the data object by simply writing <code class="language-">this.</code> and then the property name.
          </p>
          <p>The second argument is going to be the height or pixel width of the identicon that gets generated - 200
            pixels should be fine for application.
          </p>
          <p>Now the very last thing we need to do is return this calculated or computed value from the identicon
            function so I'm going to make sure I get the return keyword inside there as well:
          </p>
          <figure>
            <pre><code class="language-javascript">computed: { // Turn data into viewable values
identicon: function() {
  return jdenticon.toSvg(this.textInput, 200);
}</code></pre>
            <figcaption>Fig 01-034</figcaption>
          </figure>
          <p>Ok so I know that at this point we still don't really see any change in the output rendered to the browser
            window. So to actually get this identicon function running and displayed on the screen we have to actually
            reference the identicon function from within our template which is defined in the Html panel in the CodePen.
          </p>
          <p>To call a computed function from within our template or to somehow get that information to appear on the
            screen we can use a little bit of advanced Vue syntax. So in the Html where we have written Output: I am
            going to reference this computed identicon function by writing the following:
          </p>
          <figure>
            <pre v-pre><code class="language-html">&amp;lt;div&amp;gt;
    Output:
    {{ identicon }}
&amp;lt;/div&amp;gt;</code></pre>
            <figcaption>Fig 01-035</figcaption>
          </figure>
          <p>So now in the browser output you'll see a bunch of crazy strange text. This might not look like what we
            want but it is actually pretty close to what we need. You should see an svg tag which is a type of image.
            So, in this case, whenever we make use of the jdenticon <code class="language-">toSvg</code> function it
            returns an SVG element. But when we try to show that inside of our template we just see the actual raw Html
            that represents our Svg.
          </p>
          <p>To actually get this to show up as a real piece of rendered Svg we're going to use another Vue directive:
          </p>
          <figure>
            <code class="language-">    &lt;div v-html=&quot;identicon&quot;&gt;&lt;/div&gt;</code>
            <figcaption>Fig 01-036</figcaption>
          </figure>
          <p>Now you should see the identicon appear on the screen. Now I know that the last step there, where I said
            "Ok we don't really want the SVG raw text to appear here - we want to instead show the Html" might seem a
            little bit confusing. We'll come back to this in a second but before we do let's try entering in some text
            in the input field. As you start to type stuff in you'll notice that the identicon is changing every single
            time and we get some new identicon appearing on the screen.
          </p>
          <p>So in the next section we're going to do a very big review to describe exactly how this application is
            working right now.
          </p>
          <h3>Review from Start to Finish</h3>
          <p>In the last section we got our application working but I think you'll agree with me that there's still some
            confusion over how everything works at the moment. So in this section we are going to work through a big
            timeline diagram that's going to give you a better idea of exactly what is occurring inside or our
            application and it's going to really tie everything together.
          </p>
          <figure>
            <img src="./images/vuejsessentials/Fig01-037.png" />
            <figcaption>Fig 01-037</figcaption>
          </figure>
          <p>At the very top we first start off by creating our Vue instance. When that instance is created the <code
              class="language-">data</code> property is evaluated:
          </p>
          <figure>
            <pre><code class="language-javascript">data: { // Initialize our list of 'ingredients'
 textInput: ''
  },</code></pre>
            <figcaption>Fig 01-038</figcaption>
          </figure>
          <p>Vue sees that we are providing an object that has a property named <code class="language-">textInput</code>
            with a value of empty string. Because we are initializing the <code class="language-">data</code> property
            Vue is going to take that and it's going to assign it to the value
            of <code class="language-">this</code> which is accessible inside of our computed functions and our
            methods functions. After that value is initialized our template inside the Dom is then evaluated by Vue and
            eventually rendered onto the screen. So that's when we actually see some starting content appear
          </p>
          <p>We then wait for some user to type into our text input. The instant they do our <code
              class="language-">onInput</code> method is executed. Inside of that <code class="language-">onInput</code>
            method we update the value of <code class="language-">textInput</code>.
            That's when some interesting stuff starts to happen. So when you start to update data properties that have
            been assigned to <code class="language-">this</code> our template gets automatically re-rendered to the
            screen. So Vue says - "Hey!, someone just updated that value. I need automatically re-render the template
            and update content that is visible on the screen.
          </p>
          <p>
            During that process, Vue looks at our template and it sees that it references a computed property when we
            put together the directive right underneath Output:
          </p>
          <figure>
            <pre><code class="language-html">&amp;lt;div&amp;gt;
  Output:
  &amp;lt;div v-html=&amp;quot;identicon&amp;quot; /&amp;gt;
&amp;lt;/div&amp;gt;</code></pre>
            <figcaption>Fig 01-039</figcaption>
          </figure>
          <p>So we added in the directive of <code class="language-">v-html</code> which we're going to expand upon in
            just a moment and inside there we referenced the <code class="language-">identicon</code> computed
            function.</p>
          <p>So Vue locates the <code class="language-">identicon</code> function and executes it and then whatever is
            returned from that function will be provided to this <code class="language-">v-html</code> directive. So
            in this case the <code class="language-">identicon</code> function returns some raw Html as a string (with
            an <code class="language-">svg</code> tag inside it). But as you an I very well know we don't want to show
            raw Html to the user - we want to display an identicon. So to get Vue to interpret that string as Html and
            not a plain old string we used the <code class="language-">v-html</code> directive. This directive says -
            "We're going to give you a snippet of Html. It's gonna be a string but it's going to look like Html. You
            need to interpret that as Html and render it as Html in the output. Don't try to just print out the string."
          </p>
          <p>What we did before where we use the curly braces <code v-pre class="language-">{{ identicon }}</code>
            this is how we just print out a very simple string.</p>
          <p>Traditionally we don't use the <code class="language-">v-html</code> tag unless you are working on an
            application where you actually need to make use of some pre-generated Html. So it's much more frequently
            that we'll use other methods for displaying content on the screen.
          </p>
          <p>So hopefully that's a little bit more of an explanation and makes what's happening inside of our
            application a little bit more clear. There's still some side topics I want to address about this application
            which we will address in the next section.
          </p>
          <h3>Template Placement</h3>
          <p>In the last section we reviewed our entire application and got a better idea of how it's working. In this
            section I want to start going over a couple of quick odds and ends around the application we just put
            together.
          </p>
          <p>So the first ordinance I want to tell you about is the placement of our template. Remember, that, many
            videos ago when we spoke about the Vue template being created in Html and the Vue instance being created in
            JavaScript and we mentioned that was one way of structuring a Vue application. In particular, I'd said that
            our Vue template does not have to be created on the Html side of our application and that we could instead
            declare that Vue template in the JavaScript side.
          </p>
          <p>To demonstrate this alternative configuration go back to our CodePen and take all the Html that is inside
            the <code class="language-">div</code> with an <code class="language-">id</code> of <code
              class="language-">app</code> and cut and paste it into a new property called <code
              class="language-">template:</code>
            that we add to the bottom of the JavaScript panel:
          </p>
          <figure>
            <pre><code class="language-javascript">template: `
&amp;lt;div&amp;gt;
  &amp;lt;h3&amp;gt;My Identicon Generator&amp;lt;/h3&amp;gt;
      Input:
    &amp;lt;div&amp;gt;
      &amp;lt;input v-on:input=&amp;quot;onInput&amp;quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
      Output:
      &amp;lt;div v-html=&amp;quot;identicon&amp;quot; &amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;`</code></pre>
            <figcaption>Fig 01-031</figcaption>
          </figure>
          <p>Note the use of back ticks (the character on the keyboard to the left of 1) and additional enclosing <code
              class="language-">div</code>.
          </p>
          <p>So when we make use of a template that is attached directly to an instance we provide a string that
            contains some amount of Html. Inside that string we have to have exactly one root element (which is why we
            added the additional <code class="language-">div</code>). If I were to remove the root <code
              class="language-">div</code> you would see the we only see the <code class="language-">h3</code> element
            in the browser window (which is now the root element). >That's the
            reason for the root <code class="language-">div</code>. We are expected to only return 1 root element
            inside the template string.
          </p>
          <p>So you'll see very plainly that everything works the exact same way that it did before. This is just a
            different way to structure your Vue application. You can either create your template inside of your Html or
            you can create the template and attach it directly to your Vue instance.
          </p>
          <p>Now, in reality, the vast majority of applications that you will be working on are going to take the
            approach where you define the Html as a template property in JavaScript. The reason I demonstrated the
            approach where the Vue template is created in the Html is because all the Vue documentation takes that
            approach.
          </p>
          <h3>Referencing Data in the Template</h3>
          <p>In this section I want to focus on the fact that we used a computed function when putting our application
            together. Now what I want to be very clear about is that our template can show data that has been assigned
            to our <code class="language-">data</code> property. We don't have to always use computed functions.
          </p>
          <p>In general we only ever use computed functions anytime we want to somehow mess around with some piece of
            data before it gets shown on the screen. Let me show you a good example of this. Back inside of our
            application let's say that we want to dramatically change how our app behaves. Let's say that maybe instead
            of entering in some input and then getting back an identicon we want to just echo back our text directly to
            the user. So if I enter "my slice of pie" the output should be simply "my slice of pie" - no change
            whatsoever. If you want to print out some value that is assigned to <code class="language-">data</code>
            without making any change to it whatsoever you don't have to use a computed function. Instead you can
            reference your property or your <code class="language-">data</code> name directly from within the
            template.
          </p>
          <p>To do this scroll down to where the template is defined (in the JavaScript panel) and locate the <code
              class="language-">div</code> with a directive of <code class="language-">v-html </code>. So, we don't want
            to show the identicon anymore so I am going to delete
            that <code class="language-">div</code> entirely.
          </p>
          <p>Instead I will directly reference the text input property and just try to print it out directly into the
            template. To print out a direct property without trying to do any fancy directives or anything like that we
            use the double curly braces and then inside there we just write out the property name that we want to
            display. The name that we put inside the curly braces can be either the name of one of our computed
            functions or the name of one of our data properties:
          </p>
          <figure>
            <pre v-pre><code class="language-html">&lt;div&gt;
    Output:
    {{ textInput }}
&lt;/div&gt;</code></pre>
            <figcaption>Fig 01-032</figcaption>
          </figure>
          <p>Now if I start to type inside of my textInput again you'll see that the text gets directly mirrored right
            underneath. That's because I'm just taking whatever my input value is an printing out directly inside the
            template. One thing I want to mention inside of here, very explicitly, is that when we reference this <code
              class="language-">textInput</code> we did not have to do anything like say <code
              class="language-">this.textInput</code> or <code class="language-">this.data.textInput</code> We
            simply write the name of the property inside the curly braces.
          </p>
          <p>One issue that raises is you'll want to make sure when you're defining computed functions you don't
            accidentally duplicate the name of one of your data properties. So I would not want to make a computed
            function named <code class="language-">textInput</code> because then it would be really ambiguous as wo
            whether inside my template I'm referring to the data property or the computed function name.
          </p>
          <p>So, to recap, we don't have to use a computed property to display data if we don't want to/need to. We can
            just reference the data name directly and that will be printed out verbatim inside of our template.
          </p>
          <p>In CodePen revert back to the original <code class="language-">v-html</code> directive:</p>
          <figure>
            <pre><code class="language-">&lt;div&gt;
    Output:
    &lt;div v-html=&quot;identicon&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>
            <figcaption>Fig 01-033</figcaption>
          </figure>
          <h3>Expressions in Templates</h3>
          <p>So when we were talking in the last section about using those curly braces to display some value inside of
            a template that made use of a technique called string interpolation. So whenever we use string interpolation
            that means that we are kind of injecting a value directly into our template. Anytime that we use those curly
            braces we are not limited to referring to a simple data property or a computed property.
          </p>
          <p>If we want to we can put in some tiny amount of JavaScript logic into those curly braces. To be more
            precise we can put exactly one Javascript expression inside the curly braces. So we can't write out a full
            <code class="language-">if</code> statement, we can't write out a <code class="language-">for</code> loop or
            anything like that.
          </p>
          <p>Back in CodePen at the very bottom of the template where we've got the identicon content being printed out
            inside the <code class="language-">div</code> using the <code class="language-">v-html</code> directive.
          </p>
          <p>Delete the <code class="language-">div</code> replacing it with another set of curly braces . Inside the
            braces reference textInput again:</p>
          <figure>
            <pre v-pre><code class="language-html">&lt;div&gt;
    Output:
    {{ textInput }}
&lt;/div&gt;</code></pre>
            <figcaption>Fig 01-034</figcaption>
          </figure>
          <p>Now if I type something out inside the input, just as before, I see the same text appear in the Output. So,
            right now, we are simply referencing <code class="language-">textInput</code>. However, if we want to we
            can add a very limited amount of Javascript logic inside of these curly braces.</p>
          <p>So, for example, we could do a little bit of string concatenation:</p>
          <figure>
            <pre v-pre><code class="language-html">&lt;div&gt;
  Output:
  {{ textInput + 'abcd' }}
&lt;/div&gt;</code></pre>
            <figcaption>Fig 01-034</figcaption>
          </figure>
          <p>Or we could reverse the string. In Javascript we reverse the string by splitting it into an array by every
            character and then reverse that array and, finally, join the result back together:</p>
          <figure>
            <pre v-pre><code class="language-html">&lt;div&gt;
Output:
{{ textInput.split('').reverse().join('') }}
&lt;/div&gt;</code></pre>
            <figcaption>Fig 01-035</figcaption>
          </figure>
          <p>Now what I want to point out here is that while I can add some amount of logic into the string
            interpolation it is almost always preferable to use a computed function.</p>
          <p>So instead of the string interpolation method shown above we could use a computed function:</p>
          <figure>
            <pre><code class="language-javascript">reverse: function() {
  return this.textInput.split('').reverse().join('');
}</code></pre>
            <figcaption>Fig 01-036</figcaption>
          </figure>
          <p>So that's doing the same operation as before. Now inside the template we reference our computed function
            instead:
          </p>
          <figure>
            <pre v-pre><code class="language-html">&lt;div&gt;
  Output: {{ reverse }}
&lt;/div&gt;</code></pre>
            <figcaption>Fig 01-037</figcaption>
          </figure>
          <p>I highly recommend you use computed functions anytime you need to play around with some data before it gets
            printed out because it keeps your templates very clean and easy to read. The computed functions will also be
            easier to understand because you can add comments to document their behaviour.
          </p>
          <h3>Coding Exercise 1 Rendering with String Templates</h3>
          <h3>Coding Exercise 2 JS Expressions with String Templates</h3>

        </div>
        <div class="panel-heading">
          <h2>Moving on with Vue CLI</h2>
        </div>
        <div class="panel-body">
          <h3>App Overview</h3>
          <p>In the last section we wrapped up our identicon project and in this video we're going to start talking
            about the next application which we will be working on in this course. The next application will be a lot
            more ambitious with more features and complexity to it.
          </p>
          <p>First let's take a look at a mock up of what we're going to build:</p>
          <figure>
            <img src="./images/vuejsessentials/Fig02-001.png" />
            <figcaption>Fig 02-001</figcaption>
          </figure>
          <p>So we're going to make a sort of YouTube browsing application. This application is going to allow users to
            enter a search term at the top of the page in the text input field. They might search for a term like say
            "archery". Once they submit their search criteria we will use the YouTube API to search for the term they
            just entered. We will receive a list of videos that match that search term.
          </p>
          <p>We will display the list of videos on the right hand side of the screen. Then any time a user click on one
            of these videos we will display a larger detail on the left hand side where the user can play the video and
            view a quick description of the video itself.
          </p>
          <p>This application will test our knowledge of Vue and ensure that we learn many different aspects of working
            with Vue inside an application.
          </p>
          <h3>App Challenges</h3>
          <p>We'll now continue by talking about some of the problems which we're going to have to address as we start
            working on this app. And we'll also of course talk about some possible solutions as well. So I think there
            are at least four big issues that we are going to run into over time:
          </p>
          <table class="table table-striped table-bordered">
            <thead class="thead-dark">
              <tr>
                <th>Problem</th>
                <th>Solution</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Need to somehow search for videos on YouTube</td>
                <td>Sign up for the YouTube API and use it to search for videos based on the user's entered search term.
                </td>
              </tr>
              <tr>
                <td>Need to show some different elements on the screen (search bar, video player, video list)
                </td>
                <td>Use Vue to create a couple of components, each of which have a distinct job.</td>
              </tr>
              <tr>
                <td>Need a place to write our code and run it</td>
                <td>Use a tool called Vue CLI to generate a new project boilerplate.</td>
              </tr>
              <tr>
                <td>Need to handle user input, like typing in the search term and clicking on videos</td>
                <td>Use the same Vue directives, methods, and computed functions that we just learned about
                </td>
              </tr>
            </tbody>
          </table>
          <p>So let's continue in the next section where we're going to start by generating a new project - making use
            of Vue CLI.
          </p>
          <h3>Generating a New Project</h3>
          <p>In the last section we talked about how we're going to make use of a tool called <a
              href="https://cli.vuejs.org/">Vue CLI</a> to generate a new project boilerplate. We're
            using this tool because setting up your own Vue project from scratch takes a little bit of time and it's not
            the best thing to deal with when you're first trying to start learning Vue.
          </p>
          <p>So we're going to install Vue CLI at our terminal and then we'll use it to generate a new project. To
            install Vue CLI enter <code class="language-">npm install -g @vue/cli</code> in a terminal window.</p>
          <p>Now while that's being installed I want to show you the documentation for Vue CLI very quickly. It can be
            found on <a target="_blank" href="https://github.com/vuejs/vue-cli">GitHub</a>. There's not a tremendous
            amount of documentation on here because Vue CLI is still in active development right now. Towards the bottom
            of the page you will find a link to the full documentation. Following this link will take you to some
            information on how to do further configuration of the project and eventually I would expect to see some
            deployment directions on here as well.
          </p>
          <p>Back in our terminal we can now use this tool to generate a new project so I'm going to make sure I am
            inside of a directory where I want to create a workspace folder of sorts. For this application I created a
            directory at <code class="language-">C:\DevelopmentTutorials\video-browser</code>. Inside of this
            directory
            I'm going to run the following command: <code class="language-">vue create video-browser</code>. When you
            run this command you might be prompted to
            answer several questions about the new project you are configuring. If you do just select any of the default
            options that are presented.</p>
          <h3>Why Use Vue CLI?</h3>
          <p>In the previous section we made use of Vue CLI to generate a new project. It looks like my installation is
            now complete and I'm given the directions to change directories to video-browser and run the following
            command <code class="language-">npm run serve</code>
            <p>Let's have a quick discussion about why we are making use of the Vue CLI project generator - why do we
              need
              all this infrastructure and preconfigured stuff anyway?
            </p>
            <p>Let's take a look at a diagram to get a better sense of why:</p>
            <figure>
              <img src="./images/vuejsessentials/Fig02-002.png" />
              <figcaption>Fig 02-002</figcaption>
            </figure>
            <p>So above is an illustration of how we were running when we used CodePen in the previous couple of
              examples.
              We automatically loaded up the Vue JS file by adding it as a dependency to the project. We also then added
              a
              little bit of code directly on CodePen. The two together formed a usable application. The key thing there
              to
              keep in mind is that all the code that you and I wrote - like the Javascript code and the Html markup were
              all inside of essentially a single file authored directly on CodePen.
            </p>
            <p>When we start working on real projects we don't have the luxury of only having to create one single file
              like we did in the previous examples. With real Vue project we much more frequently make a collection of
              files - so many different files form one single application. Vue CLI aids us in this process.
            </p>
            <p>So, with Vue CLI, we get the ability to instead make many different files each of which might
              have one
              individual or distinct purpose inside of our application:
            </p>
            <figure>
              <img src="./images/vuejsessentials/Fig02-003.png" />
              <figcaption>Fig 02-003</figcaption>
            </figure>
            <p>So we might have one file that has some code for fetching videos and then maybe another one that's in
              charge of the search bar at the top of our application. Another one for playing a video and then one more
              for maybe showing a list of videos to the user.
            </p>
            <p>So all these different files are going to come together to form our one usable application.</p>
            <p>Here's the thing about JavaScript though - out of the box it doesn't offer a great way to take all these
              different files, combine them down to one single file, send that file to the user's browser and have our
              application start up and be executed.
            </p>

            <p>So to take all these different files and combine them together we make use of a tool called webpack.</p>
            <figure>
              <a target="blank" href="https://webpack.js.org/"><img src="./images/vuejsessentials/Fig02-004.png" /></a>
              <figcaption>Fig 02-004</figcaption>
            </figure>
            <p>Essentially webpack's purpose is to look at a big collection of files and possibly dependencies as well
              (like Vue JS) and combine them all down to one single file which can then be sent down to your users
              browser
              when they try to make use of your application.
            </p>
            <p>The webpack tool is one of the big reasons that we're making use of Vue CLI. webpack is somewhat
              notorious
              for being a little difficult to set up out of the box. So by making use of Vue CLI it automatically sets
              up
              webpack for us and chooses a lot of very sensible configuration defaults.
            </p>
            <figure>
              <a href="https://babeljs.io/" target="_blank"><img src="./images/vuejsessentials/Fig02-005.png" /></a>
              <figcaption>Fig 02-005</figcaption>
            </figure>
            <p>Along with Vue CLI we also get access to Babel preconfigured for us right of the box. You may have heard
              of
              Babel before as well. Babel allows us to write ES2015, 16, 17 and so on code that can be safely executed
              inside of a user's browser even if their browser does not have support for a particular dialect of
              Javascript which we might want to use. Just like webpack, Babel is also included automatically inside of
              Vue
              CLI and it has a lot of very sensible configuration defaults already set up for us.
            </p>
            <p>So that's why we are making use of Vue CLI. It does all this setup for us and we don't have to waste any
              time labouring over documentation and figuring out how to set that stuff up.
            </p>
            <p>Let's continue in the next section where we're going to start up our application and get a better sense
              of
              all the different files and folders that were created for us automatically when we just generated the
              project.
            </p>
            <h3>Project Walkthrough</h3>
            <p>In the last section we spoke about how we get webpack and Babel setup for us for free whenever we make
              use
              of Vue CLI.
            </p>
            <p>Back in the terminal change directory into the newly created video browser directory and start the
              project
              by running the <code class="language-">npm run serve</code> command.
            </p>
            <p>Throughout the rest of this course we're going to be using this command to start our project up. Now when
              you run that command you'll see some information about starting up the development server. The <code
                class="language-">npm run serve</code> command starts up a local server that starts up Babel and
              webpack, takes all of our project files and bundles them together into one single Javascript file where it
              can then be served up into the browser. The command will also open a browser window pointing to the
              following address:
            </p>
            <pre><code class="language-">localhost:8080</code></pre>
            <p>This is where our project is hosted.</p>
            <p>You'll also notice that there is a little bit of default content already visible on the screen here.
            </p>
            <figure>
              <img src="./images/vuejsessentials/Fig02-006.png" />
              <figcaption>Fig 02-006</figcaption>
            </figure>
            <p>The code to create this content is generated automatically when we run Vue CLI to setup our new project.
            </p>
            <p>Let's now open up our code editor inside of the project directory and take a look at some of the
              different
              files and folders that were generated for us:
            </p>
            <figure>
              <img src="./images/vuejsessentials/Fig02-007.png" />
              <figcaption>Fig 02-007</figcaption>
            </figure>
            <p>You'll see some different files and folders that were created for us automatically when we generated our
              project. Inside the <span class="filename">node_modules</span> directory is a list of all the different
              dependencies that our project relies on.
            </p>
            <p>Underneath that you'll find the <span class="filename">public</span> directory inside which is a very
              important file - index.html:</p>
            <figure>
              <pre><code class="language-html">&lt;!DOCTYPE html&gt;
              &lt;html&gt;
                &lt;head&gt;
                  &lt;meta charset=&quot;utf-8&quot;&gt;
                  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
                  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
                  &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;
                  &lt;title&gt;video-browser&lt;/title&gt;
                &lt;/head&gt;
                &lt;body&gt;
                  &lt;noscript&gt;
                    &lt;strong&gt;We're sorry but video-browser doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;
                  &lt;/noscript&gt;
                  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
                  &lt;!-- built files will be auto injected --&gt;
                &lt;/body&gt;
              &lt;/html&gt;</code></pre>
              <figcaption>Fig 02-008A</figcaption>
            </figure>
            <p>Anytime someone tries to visit our application by coming to our server in their web browser the <span
                class="filename">index.html</span> file is going to be loaded up automatically. In the Html you should
              see a
              <code class="language-html">div</code> with an <code class="language-html">id</code> of <code
                class="language-">app</code> just like the code we wrote back in CodePen. This <code
                class="language-">div</code> represents the root location of where our app is going to be booted up.
            </p>
            <p>Then inside the <span class="filename">src</span> directory you will find a bunch of different files and
              folders that are related to the actual implementation of our Vue app. We're gong to be spending the vast
              majority of our time inside this <span class="filename">src</span> directory.
            </p>
            <p>Let's start off by looking at the <span class="filename">main.js</span> file. Inside of this file you'll
              find some very plain Javascript code and towards the bottom you'll find a function call to create a new
              Vue
              instance. You'll notice that there's also a <code class="language-javascript">render</code> option and a
              <code class="language-javascript">$mount</code> function call as well:</p>
            <figure>
              <pre><code class="language-javascript">import Vue from 'vue';
              import App from './App';
              
              Vue.config.productionTip = false
              
              new Vue({
                  el: '#app',
                  render: h =&gt; h(App)
              }).$mount('#app')
              </code></pre>
              <figcaption>Fig 02-008B</figcaption>
            </figure>
            <p>We'll just ignore those two little pieces of code for right now but we'll definitely come back to those
              very shortly and talk about what their purposes are.
            </p>
            <p>You'll notice that, also inside the <span class="filename">src</span> directory, is an <span
                class="filename">App.vue</span> file. Notice the extension there - it's <span class="filename">.vue
              </span> rather than being <span class="filename">.js</span> or anything like that. Let's open up the file
              and
              have a look:
            </p>
            <figure>
              <pre><code class="language-html">&lt;template&gt;
                &lt;div id=&quot;app&quot;&gt;
                  &lt;img src=&quot;./assets/logo.png&quot;&gt;
                  &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;
                &lt;/div&gt;
              &lt;/template&gt;
              
              &lt;script&gt;
              import HelloWorld from './components/HelloWorld.vue'
              
              export default {
                name: 'app',
                components: {
                  HelloWorld
                }
              }
              &lt;/script&gt;
              
              &lt;style&gt;
              #app {
                font-family: 'Avenir', Helvetica, Arial, sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                text-align: center;
                color: #2c3e50;
                margin-top: 60px;
              }
              &lt;/style&gt;</code></pre>
              <figcaption>Fig 02-009</figcaption>
            </figure>
            <p>All this Html is nested inside of a <code class="language-html">template</code> tag and then below all
              that
              Html you'll find what looks like another piece of Html - a <code class="language-html">script</code> tag
              inside which there is some Javascript code. So I don't know about you but this definitely looks like one
              weird little file - let's talk about what's going on here.</p>
            <h3>Vue Files</h3>
            <p>In the last section we started looking at some of the different files and folders that were generated for
              us automatically when we made our new project. In particular we opened up the <span
                class="filename">App.vue</span> file and inside of there we saw some very interesting looking syntax.
            </p>
            <p>So at the top we see a <code class="language-html">template</code> tag and a the bottom we see a <code
                class="class=language-html">script</code> tag. So let's talk about what's going here.
            </p>
            <p>First off, a quick reminder of what we were doing previously over inside of CodePen:</p>
            <figure>
              <img src="./images/vuejsessentials/Fig02-010.png" />
              <figcaption>Fig 02-010</figcaption>
            </figure>
            <p>This figure demonstrates one possible way of structuring a Vue app. We might define our Vue template
              inside
              of some Html like an actual Html document and we might create our Vue instance over in some Javascript
              code.
            </p>
            <p>We then later on said that alternatively we could also create this Vue template inside of our Javascript:
            </p>
            <figure>
              <img src="./images/vuejsessentials/Fig02-011.png" />
              <figcaption>Fig 02-011</figcaption>
            </figure>
            <p>We saw an example of that over in CodePen when we used those back tick characters to insert our template
              directly attached to our Vue instance.
            </p>
            <p>So that covers two different ways of structuring a Vue application.</p>
            <p>However, what you're seeing inside of the App.vue file is yet another way of structuring your Vue code:
            </p>
            <figure>
              <pre><code class="language-html">&lt;template&gt;
                &lt;div id=&quot;app&quot;&gt;
                  &lt;img src=&quot;./assets/logo.png&quot;&gt;
                  &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;
                &lt;/div&gt;
              &lt;/template&gt;
              
              &lt;script&gt;
              import HelloWorld from './components/HelloWorld.vue'
              
              export default {
                name: 'app',
                components: {
                  HelloWorld
                }
              }
              &lt;/script&gt;
              
              &lt;style&gt;
              #app {
                font-family: 'Avenir', Helvetica, Arial, sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                text-align: center;
                color: #2c3e50;
                margin-top: 60px;
              }
              &lt;/style&gt;</code></pre>
              <figcaption>Fig 02-012</figcaption>
            </figure>

            <p>So in this scenario we are making use of a paradigm called Vue files. The idea behind a Vue file is that
              you'll have exactly one file that is responsible for creating a single component inside of your
              application.
            </p>
            <p>A single component is created as a reusable piece of code that can be used all over your application many
              times. Inside the single Vue file you'll find not only the template that your Vue file or your Vue
              component
              is going to use but you'll also find all the Javascript code related to it as well.
            </p>
            <p>So in other words, inside of one single file, we get access to all of our Html for this Vue component, we
              get all the Javascript for it, and in future demos we will also locate all the CSS for this component as
              well:
            </p>
            <figure>
              <img src="./images/vuejsessentials/Fig02-013.png" />
              <figcaption>Fig 02-013</figcaption>
            </figure>
            <p>So - one file that contains all the code related to one component or one piece of our application. As we
              start to implement our video browser application you and I are going to end up with a couple of different
              Vue files each of which are responsible for implementing one distinct part of this application.
            </p>
            <p>So we might make one Vue file that is responsible for the search bar at the top of the browser, we might
              make another single Vue file that is responsible for the search results list over the right-hand side, and
              another that is responsible for the big video detail here in the middle that's going to eventually play a
              video.
            </p>
            <p>So, again, the idea is that we have all the Html, Javascript and CSS directly placed inside the one Vue
              file.
            </p>
            <p>Now you might think that this violates one of the core principles of creating web applications - the idea
              of separate concerns. Separation of concerns means we try not to mix all of our Html, Javascript and CSS
              together because that could make our application messy and difficult to follow.
            </p>
            <p>What I want to point out here is that even when we start making use of Vue files. Even though we've got
              our
              template, script and CSS altogether in one file we are still technically adhering to the principle of
              separation of concerns because inside the Vue file we have one area that is responsible for Html, one for
              our Javascript, and one for our CSS. So, while, yes they are all located inside of a single file they are
              still at least somewhat isolated inside this file. One of the big benefits to making use of Vue files is
              that if you ever need to change your application in some fashion it'll be a lot easier to find all the
              related code in one file.
            </p>
            <p>
              For example, if we wanted to make a change to the way that the search bar behaves we know that we could
              always open up the Vue file that contains the search bar implementation and inside there we'll find the
              Html, Javascript and CSS. That means that we don't have to go hunting around different directories inside
              of
              our application to find all the different aspects of code that are related to the search bar.
            </p>
            <p>It might take a little bit of time to get used to this Vue file syntax but over time I'm very confident
              that you'll come to enjoy it. We've spoken a little bit about the purpose of the Vue file at this point
              but
              we have't really spoken about how this strange syntax is used to build an actual application.
            </p>
            <p>In the next section we're going to examine some of the behind the scenes stuff that occurs to get the
              code
              you create inside your Vue files to run inside of your browser.
            </p>
            <h3>Behind the Scenes of Vue Files</h3>
            <p>In the last section we started talking about Vue files. Inside of a single Vue file we will locate all
              the
              code related to one distinct portion of our application. We're going to use Vue files in place of making
              separate Vue instances and Vue templates that are already created in the DOM. In this section I want to
              answer a question that you might have - which is how does our browser understand and execute the code that
              we place inside our Vue files.
            </p>
            <p>So, in fact, the code you see in a Vue file is not what actually gets sent down to your user's browser.
              Instead Babel and webpack work together to somehow convert all of this content into some very plain
              Javascript code that your browser can safely run.
            </p>
            <p>So in this section we will run through a quick demonstration of what this file turns into when it gets
              sent
              down to your browser.
            </p>
            <p>First, go back to the browser and open up the request log like so:</p>
            <figure>
              <img src="./images/vuejsessentials/Fig02-014.png" />
              <figcaption>Fig 02-014</figcaption>
            </figure>
            <p>Then I'm going to go over to my code editor and make one very small change to the Vue file and then save
              it. Go back over to the request log and you should see a whole bunch of Javascript code that represents
              that
              change that we just made:
            </p>
            <figure>
              <img src="./images/vuejsessentials/Fig02-015.png" />
              <figcaption>Fig 02-015</figcaption>
            </figure>
            <p>I'm going to copy that code into a blank file in my code editor, I'm going to find and replace newline
              characters in here very quickly and then I'm just going to delete a tiny little bit of code leaving me
              with:
            </p>
            <figure>
              <pre><code class="language-javascript">var render = function() {
              var _vm = this
              var _h = _vm.$createElement
              var _c = _vm._self._c || _h
              return _c(
                  \&quot;div\&quot;,
                      { attrs: { id: \&quot;app\&quot; } },
                          [
                                _c(\&quot;img\&quot;, { attrs: { src: __webpack_require__(/*! ./assets/logo.png */ \&quot;./src/assets/logo.png\&quot;) } }),\n
                                _c(\&quot;HelloWorld\&quot;, { attrs: { msg: \&quot;Wel to Your Vue.js App\&quot; } })
                          ],
                          1
                      )
              }</code></pre>
              <figcaption>Fig 02-016</figcaption>
            </figure>
            <p>So, like I said, I just wanted to very quickly go through that change so we can see what that file gets
              turned into.
            </p>
            <p>The <code class="language-javascript">render</code> function in Fig 02-016 is what our <span
                class="filename">App
                .vue</span> file was converted into before it got sent down to our browser. Fig 02-016 shows the actual
              code
              that is running inside of your browser that represents that Vue file.
            </p>
            <p>Now, before we walk through the code inside of here too deeply let's go back over to the <span
                class="filename">App.vue</span> file. Inside the <code class="language-html">template</code> you'll
              notice
              that we are creating a <code class="language-html">div</code> with an <code
                class="language-html">id</code> of <code class="language-javascript">app</code> and then inside there
              we've got an <code class="html">image</code> tag with a <code class="language-html">src</code> of <span
                class="filename">logo.png</span>. Then we have a <code class="language-html"> HelloWorld</code> tag that
              has a message of "Welcome to your Vue.js App":
            </p>
            <figure>
              <pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
                &lt;img src=&quot;./assets/logo.png&quot;&gt;
                &lt;HelloWorld msg=&quot;Wel to Your Vue.js App&quot;/&gt;
              &lt;/div&gt;</code></pre>
              <figcaption>Fig 02-017</figcaption>
            </figure>
            <p>Now that we have a better understanding of the template let's go back over to the file we just created.
              Inside this file you'll notice a couple of strange variable declarations at the top:
            </p>
            <figure>
              <pre><code class="language-javascript">var _vm = this
              var _h = _vm.$createElement
              var _c = _vm._self._c || _h</code></pre>
              <figcaption>Fig 02-018</figcaption>
            </figure>
            <p>Ignore those for a second and checkout the function call to _c:</p>
            <figure>
              <pre><code class="language-javascript">return _c(
              \&quot;div\&quot;,
                  { attrs: { id: \&quot;app\&quot; } },
                      [
                            _c(\&quot;img\&quot;, { attrs: { src: __webpack_require__(/*! ./assets/logo.png */ \&quot;./src/assets/logo.png\&quot;) } }),\n
                            _c(\&quot;HelloWorld\&quot;, { attrs: { msg: \&quot;Wel to Your Vue.js App\&quot; } })
                      ],
                      1
                  )
              }</code></pre>
              <figcaption>Fig 02-019</figcaption>
            </figure>
            <p>Inside this we have a first argument of <code class="language-html">div</code> which represents our top
              level
              <code class="language-html">div</code> tag inside of our template. Then the second argument is an object
              that
              says that <code class="language-html">div</code> should have an <code class="language-html">id</code> of
              <code class="language-html">app</code>. The third argument is a list of
              other elements that are contained within that <code class="language-html">div</code>.
            </p>
            <p>The first element that exists inside the <code class="language-html">div</code> is an <code
                class="language-html">img</code> tag that has a <code class="language-html">src</code> of <span
                class="filename">logo.png</span>
            </p>
            <p>The second element is that <code class="language-html">HelloWorld</code> tag that has a message property
              of
              "Welcome to your Vue .js App".
            </p>
            <p>So even though this syntax still might look very strange - it might not look like any Vue code we've
              written or looked at so far - I hope that you can at least get the sense that everything inside the Vue
              file
              is somehow converted into this other structure before it gets sent down to our browser. Inside of our
              browser, we're not directly running the code in <span class="filename">App.vue</span>. It all gets
              translated into this other form and then executed.
            </p>
            <p>So really the idea of making use of these Vue files that have the <code
                class="language-html">template</code> tag, the <code class="language-html">script</code> tag and the
              <code class="language-html">style</code> tag is really just to make your life and my life as developers a
              little
              bit
              more easy and straightforward. That's the only purpose of it - it's just to help us organize our code
              inside
              of these Vue files.
            </p>
            <p>Ok, so now that we've got a better idea of what's happening inside of a Vue file, let's continue in the
              next section and do a little bit more of a walk through of some of the code that we have inside the
              project
              that Vue CLI setup for us.
            </p>
            <h3>Vue Components vs Vue Instances</h3>
            <p>In the last section we saw how the <span class="filename">.vue</span> file eventually got turned into
              normal Javascript code before it was displayed in the browser. Before we move onto actually coding our
              video-browser application there is one last important topic which I want to share with you. In the last
              couple of videos I've been using the term Vue component a couple of different times and earlier on in the
              course, back when we were working inside of CodePen, I was using the term Vue instance. I want to make the
              distinction between Vue components and Vue instances:</p>
            <figure>
              <img src="./images/vuejsessentials/Fig02-020.png" />
              <figcaption>Fig 02-20</figcaption>
            </figure>
            <p>You can think of a Vue component as a blueprint or a set of rules on how to create something that can be
              inserted into the DOM in our browser which the user can then interact with. Whenever you and I make a Vue
              file we are going to define exactly one component inside of it and that component is going to have this
              set
              of rules that tells you how to display some content on the screen and how a user can interact with it. So
              again - think of a component as being like a blueprint of sorts.
            </p>
            <p>On the other hand is a Vue instance which is what we were making back inside of CodePen. A Vue instance
              is
              really an instance of a Vue component and represents something that has been inserted into the DOM and is
              something that a user can interact with. I know that the relation between these two things is very tenuous
              but if you've got an understanding or a background in object oriented programming then you can think of a
              Vue component as being a class and a Vue instance being like an instance of that class. That's the real
              relationship that's going on here.
            </p>
            <p>So like I said we are always going to create one Vue file for every Vue component. One of the critical
              steps that we're going to undergo in every Vue application that we put together is to plan out the
              different
              components that we might want to make. In general we like to look at mockups of the applications that we
              are
              going to make and do some quick brainstorming on how we might assemble a set of different components go
              make
              up that application.
            </p>
            <p>So with that in mind I took the liberty of taking our mockup for the video-browser application and
              thinking
              about how I might divide this up into a set of different components:
            </p>
            <figure>
              <img src="./images/vuejsessentials/Fig02-021.png" />
              <figcaption>Fig 02-021</figcaption>
            </figure>
            <p>So you'll notice I've added some colored boxes on this mockup and then on every box I've attached a
              label.
              So the label that you see here is the name of a component that we're going to make to implement the
              video-browser application. So you and I are going to make one Vue file called <span
                class="filename">SearchBar.vue</span>.
              This is going to have a single Vue component that is going to contain a text input field and anytime a
              user
              types inside that we are going to somehow trigger some searching operation on the YouTube API.
            </p>
            <p>
              We will also make a single Vue file that houses a component called VideoList. This component will know how
              to take a list of videos and render them out onto the screen. In turn we will also have a VideoListItem
              which will be a single component that represents a single video.
            </p>
            <p>So the VideoList component will contain many VideoListItems inside of it because the VideoListItem
              represents one video and the VideoList represents the entire list. We'll also have a Vue file for the
              VideoDetail which is responsible for showing details about one single video and then all of these
              components
              will be assembled underneath one component that we will call the App component. This component is kind of
              like the central brains of our entire application and it represents the single point that kind of
              organizes
              these different components and controls how data flows between them.
            </p>
            <p>It's extremely common to always have a single component called <code class="language-html">app</code> in
              a Vue application and it's always going to serve that same purpose of
              being the brains of your app.
            </p>
            <p>The last thing I want to show you, with all these component names in mind, is a quick diagram of how they
              are
              all related:
            </p>
            <figure>
              <img src="./images/vuejsessentials/Fig02-022.png" />
              <figcaption>Fig 02-022</figcaption>
            </figure>
            <p>So this is the overall structure that you and I are going to eventually head towards as we start to build
              our video browser application. At the very top we've got our <span class="filename">main.js</span> file
              which is responsible for kind of like booting up your entire application and rendering it onto the screen.
              That <span class="filename">main.js</span> file is then going to show our App component and internally the
              App component will show the VideoDetail, the SearchBar, and the VideoList. In turn, the VideoList
              component
              will show a couple of copies of the VideoListItem component.
            </p>
            <p>So that's how all these different pieces are going to be wired together. Again we're going to make one
              separate Vue file for each of these different components and each of those Vue files is going to contain
              all
              the Html, CSS and Javascript related to that single component.
            </p>
            <p>Hopefully that should give you more of an idea of the high level architecture. If any of this component
              stuff still seems a bit strange this is another one of those topics where we're going to be doing the kind
              of breakdown of talking about components throughout the course. So this is another topic that we're just
              going to come back to again and again. So we'll get a lot of practice in understanding how components are
              really working.</p>
        </div>

      </div>
    </div>
  </div>
  </div>
</body>

</html>