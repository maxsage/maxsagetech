<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>Node:js The Complete Guide to Build RESTful APIs (2018)</title>
  <script src="https://unpkg.com/vue"></script>
  <link crossorigin="anonymous"
        href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
        rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
  </style>
</head>
<body>
<div class="container" id="app">
  <div class="panel-group">
    <div class="panel panel-primary">
      <div class="panel-heading">
        <h2>Node:js The Complete Guide to Build RESTful APIs (2018)</h2>
      </div>
      <div class="panel-body">
        <div>

        <h2>Section 2 - Node Module System</h2>
        <h3>10 Introduction</h3>
        <p>Throughout this section we will investigate some of the built in modules in Node: os fs
          events http We will also cover how to create your own modules.
        </p>
        <h3>11 Global Object</h3>
        <p>Previously we used the console.log command. The console object is known as a global
          object. It is part of the global scope which means we can access it from anywhere in our
          code.
        </p>
        <p>There are a bunch of other objects and functions that are globally available in Node.
          setTimeout() is used to call a function after a delay. This function is part of standard
          Javascript so it can be used on the client, in the browser or in Node. We also have:
          clearTimeout()
        </p>
        <p>setInterval() - call a function repeatedly at a specified interval. clearInterval() -
          stops the function from being called repeatedly.
        </p>
        <p>The above are all Javascript global objects.</p>
        <p>In browsers we have the window object that represents the global scope. So all the
          variables and functions that are defined globally we can access via the window object:
        </p>
        <figure>
          <pre><code class="language-command">window.console.log</code></pre>
          <figcaption>Fig 02-001</figcaption>
        </figure>
        <p>or</p>
        <figure>
          <pre><code class="language-command">console.log</code></pre>
          <figcaption>Fig 02-002</figcaption>
        </figure>
        <p>The Javascript engine will prefix this statement with window.console.log because that is
          where the object is defined. Similarly the setTimeout, clearTimeout, setInterval and
          clearInterval methods all belong to the window object so we can call:
        </p>
        <figure>
          <pre><code class="language-command">window.setTimeout</code></pre>
          <figcaption>Fig 02-003</figcaption>
        </figure>
        <p>In Node instead of the window object we have an object called global so the functions
          discussed above are accessed via the global object. One thing to know about Node is that a
          variable declared like this:
        </p>
        <figure>
          <pre><code class="language-javascript">var message = '';</code></pre>
          <figcaption>Fig 02-004</figcaption>
        </figure>
        <p>is not added to the global object. So, in Node, if we wrote:</p>
        <figure>
          <pre><code class="language-javascript">console.log(global.message);</code></pre>
          <figcaption>Fig 02-005</figcaption>
        </figure>
        <p>we would see 'undefined' in the console. This is due to Node's modular system which we
          will learn about in the next section.
        </p>

        <h3>12 Modules</h3>
        <p>In the last section we learned that in client side Javascript that we run in a browser
          when we declare a variable or a function it is added to the global scope:
        </p>
        <figure>
<pre><code class="language-javascript">var sayHello = function() {
}

window.sayHello();</code></pre>
          <figcaption>Fig 02-006</figcaption>
        </figure>

        <p>The problem with this behaviour that is in a real world application we often split our
          Javascript code into multiple files. This means that it is possible to define the same
          sayHello function. Because the function is added to the global scope one definition will
          overwrite the other.
        </p>

        <p>In order to build reliable and maintainable applications we should avoid defining
          variables and functions in the global scope. Instead we need modularity where we create
          small building blocks or modules where we define our variables and functions. They are
          then encapsulated in that module.
        </p>
        <figure>
          <img src="images/Fig02-007.png"/>
          <figcaption>Fig 02-007</figcaption>
        </figure>
        <p>Every file in a node application is considered a module.</p>
        <figure>
          <img src="images/Fig02-008.png"/>
          <figcaption>Fig 02-008</figcaption>
        </figure>
        <p>Variables and functions defined within the module are private (in OOP terms). If we want
          to make a variable of function available outside of the module we need to explicitly
          export it.
        </p>
        <p>Every Node application has at least one file or module which we refer to as the main
          module.</p>
        <p>If we write out the module object to the console:</p>
        <figure>
          <pre><code class="language-command">console.log(module)</code></pre>
          <figcaption>Fig 02-009</figcaption>
        </figure>
        <p>We will see a JSON object containing various properties such as id, exports, parent,
          filename, loaded etc:
        </p>
        <figure>
        <pre><code class="language-command">Module {
          id: '.',
          exports: {},
          parent: null,
          filename: 'C:\\DevelopmentTutorials\\TheCompleteNodeJSCourse\\02-node-module-system\\12-modules.js',
          loaded: false,
          children: [],
          paths:
        [ 'C:\\DevelopmentTutorials\\TheCompleteNodeJSCourse\\02-node-module-system\\node_modules',
          'C:\\DevelopmentTutorials\\TheCompleteNodeJSCourse\\node_modules',
          'C:\\DevelopmentTutorials\\node_modules', 'C:\\node_modules' ] }</code></pre>
          <figcaption>Fig 02-010</figcaption>
        </figure>
        <p>In Node, every file is a module, and the variables and functions defined in that file are
          scoped to that module, they are not available outside of that module.
        </p>
        <h3>13 Creating a Module</h3>
        <p>Let's add a new module called logger.js for logging messages. The module will be re-used
          in this application and potentially other applications. In this module we will imagine
          that we are going to use a remote logging service for logging our messages. So there are
          third party websites out there that provide a url where we can send an http request to log
          a message:
        </p>
        <figure>
          <pre><code class="language-javascript">var url = 'http://mylogger.io/log';</code></pre>
          <figcaption>Fig 02-011</figcaption>
        </figure>
        <p>The above url is made up but let's imagine that we are sending an http request to this
          endpoint.</p>
        <p>We also create a function called log that takes a message and sends an http request. For
          now, for simplicity, we will just write the message to the console:
        </p>
        <figure>
            <pre><code class="language-javascript">function log(message) {
    // Send an HTTP request
    console.log(message);
}</code></pre>
          <figcaption>Fig 02-012</figcaption>
        </figure>
        <p>The variable and the log function are both scoped to this module - they are private and
          not visible from the outside.
        </p>
        <p>However in app.js we want to be able to access the log function. So we need to make this
          public and visible from the outside.
        </p>
        <p>One of the properties of the module object is exports which by default is set to an empty
          object:</p>
        <figure>
          <img src="./images/Fig02-013.png"/>
          <figcaption>Fig 02-013</figcaption>
        </figure>
        <p>Anything that we add to this object will be exported from the module and will be
          available from outside the module:
        </p>
        <figure>
          <pre><code class="language-javascript">module.exports.log = log;</code></pre>
          <figcaption>Fig 02-014</figcaption>
        </figure>
        <p>Similarly if we wanted to export the url we defined in 13-logger.js we could write the
          following:</p>
        <figure>
          <pre><code class="language-javascript">module.exports.url = url;</code></pre>
          <figcaption>Fig 02-015</figcaption>
        </figure>
        <p>We can change the name that get's exported:</p>
        <figure>
          <pre><code class="language-javascript">module.exports.endPoint = url;</code></pre>
          <figcaption>Fig 02-016</figcaption>
        </figure>
        <p>We only export a subset of functions from modules - keeping other details private.</p>
        <h3>14 - Loading a Module</h3>
        <p>To load a module we use the require function:</p>
        <figure>
          <pre><code class="language-javascript">require('./13-logger');</code></pre>
          <figcaption>Fig 02-016</figcaption>
        </figure>
        <p>This is a node function it is not available in the browser. The js file extension is
          optional as Node assumes we will specify a Javascript file and therefore automatically
          adds the js extension.
        </p>
        <p>If the file was in a subfolder we could specify:</p>
        <figure>
          <pre><code class="language-javascript">require('./subFolder/logger');</code></pre>
          <figcaption>Fig 02-017</figcaption>
        </figure>
        <p>or if the file was in a parent folder:</p>
        <figure>
          <pre><code class="language-javascript">require('../logger');</code></pre>
          <figcaption>Fig 02-018</figcaption>
        </figure>
        <p>The require function returns the object that is exported from the specified module.</p>
        <p>To demonstrate write the following:</p>
        <figure>
        <pre><code class="language-javascript">var logger = require('./logger');
console.log(logger);
        </code></pre>
          <figcaption>Fig 02-019</figcaption>
        </figure>
        <p>Then we run the application we get an object with a single method called log that is a
          function:</p>
        <figure>
          <img src="images/Fig02-020.png"/>
          <figcaption>Fig 02-020</figcaption>
        </figure>
        <p>We can now call this function in app.js:</p>
        <figure>
          <pre><code class="language-javascript">logger.log('message');</code></pre>
          <figcaption>Fig 02-021</figcaption>
        </figure>
        <p>Now when we run the app we get the following output:</p>
        <figure>
          <img src="images/Fig02-022.png"/>
          <figcaption>Fig 02-022</figcaption>
        </figure>
        <p>In more recent versions of Javascript we have the ability to use a const. So, as a best
          practice, when loading a module using the require function it is better to store the
          result in constant:
        </p>
        <figure>
          <pre><code class="language-javascript">const logger = require('./13-logger');</code></pre>
          <figcaption>Fig 02-023</figcaption>
        </figure>
        <p>This prevents us from accidentally overwriting the value of logger:</p>
        <figure>
          <pre><code class="language-javascript">logger = 1;</code></pre>
          <figcaption>Fig 02-024</figcaption>
        </figure>
        <p>When using a const this will result in a "Assignment to constant variable" error.</p>
        <p>One last thing to mention is that sometimes instead of exporting an object from a module
          you might want to export a single function. For example, in our logger module, we don't
          necessarily need an object because we have a single method. An object would be useful if
          we had multiple methods or properties but in this case we can export a single function:
        </p>
        <figure>
          <pre><code class="language-javascript">module.exports = log;</code></pre>
          <figcaption>Fig 02-025</figcaption>
        </figure>
        <p>then in app.js call the function directly:</p>
        <figure>
          <pre><code class="language-javascript">logger('message');</code></pre>
          <figcaption>Fig 02-026</figcaption>
        </figure>
        <h3>15 Module Wrapper Function</h3>
        <p>You now know that the variables and functions defined in a module are scoped to that
          module. How does Node do this? To illustrate let's introduce a syntax error to the first
          line of logger.js (this must be on the first line):
        </p>
        <figure>
          <pre><code class="language-javascript">var x=;</code></pre>
          <figcaption>Fig 02-027</figcaption>
        </figure>
        <p>If you run logger.js you will receive the following error:</p>
        <figure>
        <pre><code class="language-javascript">(function (exports, require, module, __filename, __dirname) { var x =;

        SyntaxError: Unexpected token ;</code></pre>
          <figcaption>Fig 02-028</figcaption>
        </figure>
        <p>If you look above the SyntaxError message you will see a function declaration which
          accepts the following parameters:
        </p>
        <ul>
          <li>exports</li>
          <li>require</li>
          <li>module</li>
          <li>__filename</li>
          <li>__dirname</li>
        </ul>
        <p>Under the hood Node does not execute the code defined in our module directly. Instead it
          wraps it inside a function (the one we saw in the error message above). So, at runtime,
          our code will look similar to this (we will remove the syntax error):
        </p>
        <figure>
<pre><code class="language-javascript">(function (exports, require, module, __filename, __dirname) {
    var url = 'http://mylogger.io/log';

    function log(message) {
      // Send an HTTP request console.log(message);
    }

    module.exports = log;
  })</code></pre>
          <figcaption>Fig 02-029</figcaption>
        </figure>
        <p>The actual code is more complex than shown above but to avoid distracting from the topic
          we will keep the example simple. More advanced Javascript developers will recognise the
          code above as an Immediately Invoked Function Expression of IIFE.
        </p>
        <p>The takeaway is that Node never executes our code directly. Instead it wraps each module
          in a function. Looking at the parameters that the module accepts we have require (which we
          have seen before). The require function appears to be global but actually it is local to
          each module - in every module require is one of the parameter passed into the function.
        </p>
        <p>The function is known as the Module Wrapper Function. We have also used the module
          function previously. The exports parameter is a shortcut to module.exports so we could
          write:
        </p>
        <figure>
          <pre><code class="language-javascript">module.exports.log = log;</code></pre>
          <figcaption>Fig 02-030</figcaption>
        </figure>
        <p>or</p>
        <figure>
          <pre><code class="language-javascript">exports.log = log;</code></pre>
          <figcaption>Fig 02-031</figcaption>
        </figure>
        <p>However you can't reset exports like this:</p>
        <figure>
          <pre><code class="language-javascript">exports = log; // module.exports</code></pre>
          <figcaption>Fig 02-032</figcaption>
        </figure>
        <p>In addition we also have __filename and __dirname parameters which represent the name of
          the file and the path. Let's take a look:
        </p>
        <figure>
<pre><code class="language-javascript">console.log(__filename);
console.log(__dirname);

var url = 'http://mylogger.io/log';

function log(message) {
  // Send an HTTP request
  console.log(message);
}

module.exports = log;
</code></pre>
          <figcaption>Fig 02-033</figcaption>
        </figure>
        <p>If we now go back and run this application from the terminal we get the following:</p>
        <figure>
          <img src="images/Fig02-034.png"/>
          <figcaption>Fig 02-034</figcaption>
        </figure>
        <p>On the first line we have filename which is the complete path to the logger.js file. The
          second line shows the path to the directory that contains the module.
        </p>
        <h3>16 Path Module</h3>
        <p>In the last section we mentioned that there are a few useful modules that are built into
          the core of Node. These modules allow you to work with files, the network, operating
          system etc. and include the following:
        </p>
        <ul>
          <li>File System - work with files</li>
          <li>HTTP - create web servers that listen for HTTP requests</li>
          <li>OS - work with the Operating System</li>
          <li>Path - provides utilities for working with paths</li>
          <li>Process - information about the current process</li>
          <li>Query Strings - useful when building HTTP services</li>
          <li>Stream - for working with streams of data</li>
        </ul>
        <p>In this section we will investigate the Path module. If you run 16-path-module.js:</p>
        <figure>
        <pre><code class="language-javascript">const path = require('path');
var pathObj = path.parse(__filename);
console.log(pathObj);</code></pre>
          <figcaption>Fig 02-035</figcaption>
        </figure>
        <p>Node assumes that the argument we give to the require function specifies a built-in
          module. If there is no built-in module with the name specified in the require statement
          then Node looks for the existence of a related path to a file in this application. In this
          case we load the built-in path module and store it in a const named path. This gives you
          access to an object with a bunch of useful methods. Above we use the __filename which is
          one of the arguments in the module wrapper function we saw earlier.
        </p>
        <p>When you run the above application you will get the following information:</p>
        <figure>
<pre><code class="language-command">{ root: 'C:\\',
  dir: 'C:\\DevelopmentTutorials\\TheCompleteNodeJSCourse\\02-node-module-system',
  base: '16-path-module.js',
  ext: '.js',
  name: '16-path-module' }</code></pre>
          <figcaption>Fig 02-036</figcaption>
        </figure>
        <p>As you can see the path object has a few useful properties:</p>
        <ul>
          <li>root</li>
          <li>dir</li>
          <li>base</li>
          <li>ext</li>
          <li>name</li>
        </ul>
        <h3>17 OS Module</h3>
        <p>This section describes how to get information about the current operating system. Some of
          the available methods in the OS module include:
        </p>
        <ul>
          <li>freemem</li>
          <li>totalmem</li>
          <li>userInfo([options])</li>
          <li>uptime</li>
        </ul>
        <p>If you run 17-os-module.js:</p>
        <figure>
<pre><code class="language-javascript">const os = require('os');

var totalMemory = os.totalmem();
var freeMemory = os.freemem();

// Before node it was not possible to get information about the
// operating system using Javascript.
console.log(`Total Memory: ${totalMemory}` );
console.log(`Free Memory: ${freeMemory}` );

// Template string
// ES6 /2015 : ECMAScript 6</code></pre>
          <figcaption>Fig 02-037</figcaption>
        </figure>
        <p>You can see we make use of what is referred to as a template string which is available in
          more recent versions of JavaScript such as ES6 ES2015 whish is short for ECMAScript 6 or
          ECMAScript 2015.
        </p>
        <p>The V8 engine inside of Node is pretty up to date and it implements alot of the new
          features of Javascript defined in ECMAScript.
        </p>
        <p>If you run the above application you will get the following information:</p>
        <figure>
        <pre><code class="language-javascript">Total Memory: 17081073664
Free Memory: 10441883648</code></pre>
          <figcaption>Fig 02-037</figcaption>
        </figure>
        <p>Before node it was not possible to get information about the operating system using
          Javascript. Javascript only ran inside a browser and we could only work with the Window or
          Document objects.
        </p>
        <h3>18 File System Module</h3>
        <p>Almost all of the functions in the fs module come in two forms - synchronous (blocking)
          or asynchronous (non-blocking). Where possible you should avoid using the synchronous
          methods. As we mentioned in the previous section a Node process has a single thread. If
          you are using Node to build the backend for your application you may have hundreds or
          thousands of clients connecting to that back-end.
        </p>
        <p>If you keep that client busy you wont be able serve many clients.</p>
        <p>All the asynchronous methods take a function as their last argument. This function is
          known as a callback:
        </p>
        <p>Let's look at an example (using readdir method. First we will look at the synchronous
          form because that is easier to understand:
        </p>
        <figure>
        <pre><code class="language-javascript">const fs = require('fs');

const files = fs.readdirSync('./');
console.log(files);</code></pre>
          <figcaption>Fig 02-038</figcaption>
        </figure>
        <p>If we run the code above we get the following result:</p>
        <figure>
          <img src="images/Fig02-039.png"/>
          <figcaption>Fig 02-039</figcaption>
        </figure>
        <p>So you can see we get an array of strings describing the files in the directory we
          read.</p>
        <p>Now let's take a look at the asynchronous form of this method:</p>
        <figure>
<pre><code class="language-javascript">const fs = require('fs');

const files = fs.readdirSync('./');
console.log(files);

fs.readdir('./', function(err, ))</code></pre>
          <figcaption>Fig 02-040</figcaption>
        </figure>

        <p>As we said earlier all the asynchronous methods take a function as their last argument.
          This function is known as a callback:
        </p>
        <figure>
          <img src="images/Fig02-040.png"/>
          <figcaption>Fig 02-041</figcaption>
        </figure>
        <p>In the intellisense shown above the second parameter is a callback which is a function
          with two parameters - an error and result (which in this case is a string array)
        </p>
        <p>So we need to pass a callback function which is a function with an error and the result -
          a string array:</p>
        <figure>
        <pre><code class="language-javascript">fs.readdir('./', function(err, files) {

})</code></pre>
          <figcaption>Fig 02-042</figcaption>
        </figure>
        <p>We need to check if we have an error or the result. Only one of these arguments will have
          a value:</p>
        <figure>
<pre><code class="language-javascript">fs.readdir('./', function(err, files) {
  if (err) console.log('Error', err);
  else console.log('Result', files);
})</code></pre>
          <figcaption>Fig 02-043</figcaption>
        </figure>
        <p>If we run the code shown above using node we get the following output:</p>
        <figure>
          <img src="images/Fig02-044.png"/>
          <figcaption>Fig 02-044</figcaption>
        </figure>
        <p>This is the same result we saw with the synchronous method. Now let's simulate an error
          by changing the first argument to a dollar sign:
        </p>
        <figure>
        <pre><code class="language-javascript">fs.readdir('$', function(err, files) {
  if (err) console.log('Error', err);
  else console.log('Result', files);
})</code></pre>
          <figcaption>Fig 02-045</figcaption>
        </figure>
        <p>If we run the application using node now we see the following output:</p>
        <figure>
          <img src="images/Fig02-046.png"/>
          <figcaption>Fig 02-046</figcaption>
        </figure>
        <h3>19 Events Module</h3>
        <p>One of the core concepts in Node is events. An event is basically a signal that indicates
          that something has happened in our application.
        </p>
        <p>For example, in Node there is a class called HTTP which we can use to build a
          webserver:</p>
        <figure>
          <img src="images/Fig02-047.png"/>
          <figcaption>Fig 02-047</figcaption>
        </figure>
        <p>So we listen on a given port, and every time we receive a request on that port, that HTTP
          class raises an event:
        </p>
        <figure>
          <img src="images/Fig02-048.png"/>
          <figcaption>Fig 02-048</figcaption>
        </figure>
        <p>Our job is to respond to that event which basically involves reading that request and
          returning the right response.
        </p>
        <p>In the Events module we have a class called EventEmitter. When we call require events the
          require function returns an EventEmitter class (hence the casing to indicate a class):
        </p>
        <figure>
          <pre><code
            class="language-javascript">const EventEmitter = require('events');</code></pre>
          <figcaption>Fig 02-049</figcaption>
        </figure>
        <p>We then create an instance of the EventEmitter class:</p>
        <figure>
          <pre><code class="language-javascript">const emitter = new EventEmitter();</code></pre>
          <figcaption>Fig 02-050</figcaption>
        </figure>
        <p>The emit method raises an event:</p>
        <figure>
          <pre><code class="language-javascript">emitter.emit('messageLogged');</code></pre>
          <figcaption>Fig 02-051</figcaption>
        </figure>
        <p>The messageLogged argument is the name of the event.</p>
        <p>In order to respond to the event being raised we need to register a listener:</p>
        <figure>
<pre><code class="language-javascript">emitter.on('messageLogged', function() {
  console.log('Listener called');
});</code></pre>
          <figcaption>Fig 02-052</figcaption>
        </figure>
        <p>the on method takes two arguments - the name of the event to listen for and a callback
          function. If we run the application we see the following output:
        </p>
        <figure>
        <pre><code class="language-command">node app.js
Listener called</code></pre>
          <figcaption>Fig 02-053</figcaption>
        </figure>
        <p>The order in which you define the emitter and the listener is important. If you register
          the listener after calling the emit method it will not pick up the event. This is because
          when we call the emit method it iterates over all the registered listeners and calls them
          synchronously.
        </p>
        <h3>20 Event Arguments</h3>
        <p>Often when you raise an event you also want to send some information about that event. As
          an example, let's assume that when we log a message our remote login service might
          generate an id for that message. Perhaps we want to return that id to the client or it may
          give us a Url to access that log message directly. When raising an event, we can add
          additional arguments, referred to as event arguments:
        </p>
        <figure>
          <pre><code
            class="language-javascript">emitter.emit('messageLogged', 1, 'url');</code></pre>
          <figcaption>Fig 02-054</figcaption>
        </figure>
        <p>The magic values that we supply above are a bit confusing. A better practice is to
          encapsulate the values inside an object:
        </p>
        <figure>
          <pre><code class="language-javascript">emitter.emit('messageLogged', {id: 1, url: 'http://' });</code></pre>
          <figcaption>Fig 02-055</figcaption>
        </figure>
        <p>We refer to this object as the event argument.</p>
        <p>When registering the listener the callback function can also receive the event
          argument:</p>
        <figure>
        <pre><code class="language-javascript">emitter.on('messageLogged', function(arg) {
  console.log('Listener called');
});</code></pre>
          <figcaption>Fig 02-056</figcaption>
        </figure>
        <p>We have used arg for the parameter name here but we could call this anything. By
          convention we usually use arg, e or eventArg.
        </p>
        <p>If we run the application we get the following output:</p>
        <figure>
        <pre><code class="language-command">node app.js
Listener called { id: 1, url: 'http://' }</code></pre>
          <figcaption>Fig 02-057</figcaption>
        </figure>
        <p>One last way to simplify the code is to use the ECMAScript 6 arrow function. An arrow
          function allows you to remove the function keyword and add an arrow =>:
        </p>
        <figure>
<pre><code class="language-javascript">emitter.on('messageLogged', function(arg) {
  console.log('Listener called');
});</code></pre>
          <figcaption>Fig 02-058</figcaption>
        </figure>
        <h3>21 Extending Event Emitter</h3>
        <p>In the real world it is quite rare that you would work with the EventEmitter directly.
          Instead you normally create a class that has all the capabilities of the EventEmitter and
          then you would use that class in your code.
        </p>
        <p>To explain open the 21-logger.js module where we are exporting a simple logger function
          called log which writes the message to the console:
        </p>
        <figure>
        <pre><code class="language-javascript">var url = 'http://mylogger.io/log';

function log(message) {
  // Send an HTTP request
  console.log(message);
}

module.exports = log;</code></pre>
          <figcaption>Fig 02-059</figcaption>
        </figure>
        <p>After this we want to raise an event. Later in the app module we will respond to that
          event.</p>
        <p>We create a class in 21-logger.js called Logger that extends the EventEmitter class:</p>
        <figure>
          <pre><code class="language-javascript">const EventEmitter = require('events');

var url = 'http://mylogger.io/log';

class Logger extends EventEmitter {
    // When a function is defined in a class it is known
    // as a method. Also, the function keyword is not required
    log(message) {
        // Send an HTTP request
        console.log(message);

        // Raise an event
        this.emit('messageLogged', { id: 1, url: 'http://url'});
    }
}

module.exports = Logger;</code></pre>
          <figcaption>Fig 02-059</figcaption>
        </figure>
        <p>The ES6 extends keyword gives the Logger class all the capabilties of the
          EventEmitter.</p>
        <p>This gives the Logger class all the functionality that is defined in EventEmitter but we
          can also add additional functionality. In ES6 we have the class keyword which is
          syntactical sugar for creating a constructor function. When a function is defined in a
          class it is known as a method. Also, the function keyword is not required.
        </p>
        <p>Also instead of using the emitter object to call emit we use this - we can directly emit
          or raise events. We can remove the emitter object because it is no loner used in anywhere
          in the code.
        </p>
        <p>Back in the 21-extending-the-event-emitter.js file when requiring the 21-logger.js module
          we get a class so we rename the log const to Logger to indicate this:
        </p>
        <figure>
          <pre><code class="language-javascript">const Logger = require('./21-logger');</code></pre>
          <figcaption>Fig 02-060</figcaption>
        </figure>
        <p>Now we create a logger object:</p>
        <figure>
          <pre><code class="language-javascript">const logger = new Logger();</code></pre>
          <figcaption>Fig 02-061</figcaption>
        </figure>
        <p>To log a message we use:</p>
        <figure>
          <pre><code class="language-javascript">logger.log('message');</code></pre>
          <figcaption>Fig 02-062</figcaption>
        </figure>
        <p>Instead of using the EventEmitter class in 21-logger.js we use an instance of the logger
          class. That means we no longer need the emitter EventEmitter object:
        </p>
        <figure>
          <pre><code class="language-javascript">const emitter = new EventEmitter();</code></pre>
          <figcaption>Fig 02-063</figcaption>
        </figure>
        <p>This means we want to register the listener:</p>
        <figure>
<pre><code class="language-javascript">emitter.on('messageLogged', (arg) =&gt; {
  console.log('Listener called', arg);
}</code></pre>
          <figcaption>Fig 02-064</figcaption>
        </figure>
        <p>on the logger object. So we move the code to after we create the logger:</p>
        <figure>
        <pre><code class="language-javascript">logger.on('messageLogged', (arg) => {
  console.log('Listener called', arg);
});</code></pre>
          <figcaption>Fig 02-065</figcaption>
        </figure>
        <p>Now, when we run the application we will see 'message' written to the console but also
          because we are using the same logger object for registering an event listener and also
          raising an event we will also see 'Listener called' on the console:
        </p>
        <figure>
        <pre><code class="language-command">node app.js
message
Listener called { id: 1, url: 'http://' }</code></pre>
          <figcaption>Fig 02-066</figcaption>
        </figure>
        <h3>22 HTTP Module</h3>
        <p>One of the powerful building blocks of Node is the Http module that we use for creating
          networking applications. For example, we can create a web server that listens for Http
          requests on a given port. With this we can easily create a backend service for our client
          applications - like a web application that we build with React or Angular or a mobile
          application running on a mobile device.
        </p>
        <p>Let's write some code to load the HTTP module:</p>
        <figure>
            <pre><code class="language-javascript">const http = require('http');

const server = http.createServer();</code></pre>
          <figcaption>Fig 02-067</figcaption>
        </figure>
        <p>The server we created above is an event emitter. So it has all the capabilites of the
          EventEmitter that you saw earlier in this section (e.g. on, addListener, emit). Let's add
          some code to tell the http server which port to listen on.
        </p>
        <figure>
            <pre><code class="language-javascript">server.listen(3000);

console.log('Listening on port 3000...');</code></pre>
          <figcaption>Fig 02-068</figcaption>
        </figure>
        <p>Now when we run this application this server will listen on port 3000. Every time there
          is a new connection or request this server raises an event. We can use the on method to
          handle that event. Before listening we want to register a listener or a handler:
        </p>
        <figure>
            <pre><code class="language-javascript">server.on('connection', (socket) =&gt; {
  console.log('New connection...');
});</code></pre>
          <figcaption>Fig 02-069</figcaption>
        </figure>
        <p>The name of the event is 'connection' (this is detailed in the Node documentation). The
          second argument is a callback function for the actual listener. As you can see from the
          intellisense tooltip:
        </p>
        <figure>
          <img src="./images/Fig02-070.png"/>
          <figcaption>Fig 02-070</figcaption>
        </figure>
        <p>This listener is a function with one argument that is socket of type Socket class which
          returns void. So here we have the arrow function syntax in ES6. We add an arrow function
          that takes a socket and goes to a code block that writes to the console.
        </p>
        <p>If we run the application we get the following:</p>
        <figure>
            <pre><code class="language-command">node app.js
Listening on port 3000...</code></pre>
          <figcaption>Fig 02-071</figcaption>
        </figure>
        <p>If we now browse to localhost port 3000 in a browser:</p>
        <figure>
          <img src="./images/Fig02-072.png"/>
          <figcaption>Fig 02-072</figcaption>
        </figure>
        <p>If you look back in the terminal you will see the new connection:</p>
        <figure>
            <pre><code class="language-command">node app.js
Listening on port 3000...
New connection...
New connection...</code></pre>
          <figcaption>Fig 02-073</figcaption>
        </figure>
        <p>So you see the server object raises different kinds of events that you can respond
          to.</p>
        <p>In real world applications we are not going to respond to the connection event to build
          an Http service. So let's delete the following code:
        </p>
        <figure>
    <pre><code class="language-javascript">server.on('connection', (socket) =&gt; {
  console.log('New connection...');
});</code></pre>
          <figcaption>Fig 02-074</figcaption>
        </figure>
        <p>Leaving us with:</p>
        <figure>
            <pre><code class="language-javascript">const http = require('http');

const server = http.createServer();

server.listen(3000);

console.log('Listening on port 3000...');</code></pre>
          <figcaption>Fig 02-075</figcaption>
        </figure>
        <p>What we commonly do is pass a callback function to the createServer method like this:</p>
        <figure>
          <pre><code class="language-javascript">const server = http.createServer(function(req, res) {});</code></pre>
          <figcaption>Fig 02-076</figcaption>
        </figure>

        <p>or we can use the arrow function syntax by removing the function keyword and adding the
          fat arrow:</p>
        <figure>
          <pre><code class="language-javascript">const server = http.createServer((req, res) =&gt; {});</code></pre>
          <figcaption>Fig 02-077</figcaption>
        </figure>
        <p>In this function instead of working with a socket we can work with the actual request or
          response objects:
        </p>
        <figure>
            <pre><code class="language-javascript">if(req.url === '/') {
  res.write('Hello World');
  res.end();
}</code></pre>
          <figcaption>Fig 02-078</figcaption>
        </figure>
        <p>Now if we run the application we can see in the terminal we are still "Listening on port
          3000". If we refresh the browser:
        </p>
        <figure>
          <img src="./images/Fig02-079.png"/>
          <figcaption>Fig 02-079</figcaption>
        </figure>
        <p>You can see we get the "Hello World" message on the home page.</p>
        <p>Now, if we wanted to build a back-end application for our web or mobile applications we
          need to handle various routes. For example:
        </p>
        <figure>
    <pre><code class="language-javascript">if(req.url === '/') {
  res.write('Hello World');
  res.end();

if(req.url === '/api/courses') {
  res.write(JSON.stringify([1, 2, 3]));
  res.end();
}</code></pre>
          <figcaption>Fig 02-080</figcaption>
        </figure>
        <p>Now in the terminal. Stop the process and restart it (we will automate this in future
          sections). Now browse to localhost:3000/api/courses in the browser:
        </p>
        <figure>
          <img src="images/Fig02-081.png"/>
          <figcaption>Fig 02-081</figcaption>
        </figure>
        <p>As you see building a web server with Node is very easy.</p>
        <p>In the real world we are not going to use the Http module to build a backend service for
          our application.</p>
        <p>The reason is that as we add more routes our code becomes complicated. Instead we use a
          framework called express which gives our application a clean structure to handle various
          routes. Internally the express framework is built on top of the Http module in Node.
        </p>
        <h3>23 Recap</h3>
        <p>So, in this section, you learned that:</p>
        <ul>
          <li>We don’t have the window object in Node.</li>
          <li>The global object in Node is “global”.</li>
          <li>Unlike browser applications, variables we define are not added to the “global” object.
          </li>
          <li>Every file in a Node application is a module. Node automatically wraps the code in
            each file with an IIFE (Immediately-invoked Function Expression) to create scope. So,
            variables and functions defined in one file are only scoped to that file and not visible
            to other files unless explicitly exported.
          </li>
          <li>To export a variable or function from a module, you need to add them to
            module.exports:
          </li>
          <pre><code class="language-javascript">module.exports.sayHello = sayHello;</code></pre>
          <li>To load a module, use the require function. This function returns the module.exports
            object exported from the target module:
          </li>
          <pre><code class="language-javascript">const logger = require(‘./logger’);</code></pre>
          <li>Node has a few built-in modules that enable us to work with the file system, path
            objects, network, operating system, etc.
          </li>
          <li>EventEmitter is one of the core classes in Node that allows us to raise (emit) and
            handle events. Several built-in classes in Node derive from EventEmitter.
          </li>
          <li>To create a class with the ability to raise events, we should extend EventEmitter:
          </li>
          <pre><code class="language-javascript">class Logger extends EventEmitter { }</code></pre>

        </ul>
        </div>
      </div>
    </div>
  </div>
</div>
</body>
</html>
