<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>WebPack 2 The Complete Developers Guide</title>
  <script src="https://unpkg.com/vue"></script>
  <link crossorigin="anonymous"
        href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
        rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="panel-group">
    <div class="panel panel-primary">
      <div class="panel-heading">
        <h2>Section 7: React-Specific Topics</h2>
      </div>
      <div class="panel-body">
        <h2>React Router with Codesplitting</h2>
        <p>Now that we've got our Webpack-dev-server put together, we're going to start looking at some optimizations of
          our project that specifically revolve around React.js. So, if you're not familiar with the React or if you
          don't want to learn about using webpack with React, feel free to skip this section and go on to the next
          topic. Nothing that we do inside of this React focus section is going to be required for doing everything else
          within the course. So if you don't want to do the React.js stuff, no problem just continue on. Otherwise,
          let's get started with some React.js focused optimization of our project.</p>
        <p>Now in particular, we're going to be using code splitting with React-router. Using code splitting with
          React-router is a fantastic way to break up your application into smaller parts and this is starting to; this
          will be something that gets really useful when you're working on really large React projects. So let's get
          started.</p>
        <p>Inside of my source directory, I'm going to find the router.js file:</p>
        <figure>
          <img src="./images/Fig07-001.png"/>
          <figcaption>Fig</figcaption>
        </figure>
        <p>So this project makes use of the very popular React-router library. It uses Version two or Version three,
          it's compatible with either one. React-router Version four, at the time of this recording, is still in very
          active development. Do note that Versions two and three of React-router are supported indefinitely, so don't
          really feel like just because there's Version four out, you have to forget everything that you know about
          Version two and three. In particular, Version four is going to be a very significant rewrite of the
          React-router API, so a lot of things will be quite different.</p>
        <p>But nonetheless, everything that we learn in this section will be 100 percent applicable, more or less. Let
          me say that the general concepts and ideas will be applicable to React-router four when it comes out. However,
          you might not be able to directly copy and paste all the code. That's what I'm really trying to say. Okay, so
          in the router file we import a bunch of components at the top:</p>
        <figure>
          <img src="./images/Fig07-002.png"/>
          <figcaption>Fig 07-002</figcaption>
        </figure>
        <p>and then we define our different routes in the application:</p>
        <figure>
          <img src="./images/Fig07-003.png"/>
          <figcaption>Fig 07-003</figcaption>
        </figure>
        <p>So the root route is the home component. It has an index route of ArtistMain which means, when we go to the
          route route we'll show both the home component and ArtistMain. We then have three sub routes to find; artist
          new, artist ID and artist ID edit, which show the respective different components.</p>
        <p>So what we're going to do, is refactor this router to use code splitting around these sub routes that we
          have. So the idea here, is going to be that by default, I want to always have a bundle.js file that contains
          my home and ArtistMain component. So when a user first lands at our Website, they can grab the big bundle.js
          file and that will have all the code needed for showing the very root base routes of our application.</p>
        <p>Then, as the user starts to navigate around the app, we will add in some code splitting to dynamically load
          up the artist create, artist detail and artist edit components. Okay? So that's the idea, only when the user
          starts to navigate around, are we going to fetch all this additional code for other components.</p>
        <p>You can very easily start to imagine how this gets really really useful on very large projects, where you
          might have radically different parts of the application that don't share a lot of components at all. In
          particular, this starts to get much more relevant if you think back to the first example on code splitting
          that we did where we had a log in screen and then the second screen had a big dashboard or a fancy dashboard
          tied to it. That would have been a perfect case of using code splitting with React-router.</p>
        <p>Okay, so the big refactor that we're going to do is going to be revolving around replacing all of the route
          logic, or all the route jsx that we've got in here. React-router's big claim to fame is that you can organize
          all of your different navigation or all of your different routes using jsx. But in order to use code splitting
          effectively with React-router, we're going to move away from this jsx based approach and instead, we're going
          to use what are called plane routes.</p>
        <p>So here's how we're going to start. Right above the routes function of the routes component, we're going to
          add in a new object called componentRoutes:</p>
        <figure>
          <img src="./images/Fig07-004.png"/>
          <figcaption>Fig 07-004</figcaption>
        </figure>
        <p>And inside of here, we're going to define some amount of configuration inside this object that will mirror
          exactly what is described by the jsx right now. So, all we're doing is transforming this general jsx structure
          into a plain javascript object. Just so you know, this is actually exactly what React-router does behind the
          scenes with all the jsx that you write. So we're kind of saving a step of processing for React-router when we
          do this.</p>
        <p>Inside the components route object, we're going to add some amount of default configuration to first show the
          home component and then add in some more configuration that will be responsible for all the different routes
          in here. Again, this is like a direct translation of the jsx into a javascript object so let's just get to
          it:</p>
        <figure>
          <img src="./images/Fig07-005.png"/>
          <figcaption>Fig 07-005</figcaption>
        </figure>
        <p>First, we'll define the component to use, which will be home. We'll define the path with which to use it,
          which will be forward slash. And that's it, that's it for our first route. That's all we have to add in to
          replace this route right here:</p>
        <figure>
          <img src="./images/Fig07-006.png"/>
          <figcaption>Fig 07-006</figcaption>
        </figure>
        <p>Now, to tell the home route or the route route to use this index route of ArtistMain, we will also add in an
          index route property with an object containing component ArtistMain:</p>
        <figure>
          <img src="./images/Fig07-007.png"/>
          <figcaption>Fig 07-007</figcaption>
        </figure>
        <p>So I hope we kind of feel it's starting to get like a little bit obvious what we're doing here when I say
          translate from jsx to an object. Literally, we are translating from jsx to an object. We're taking all the
          same properties in the jsx and stuffing into this object instead.</p>
        <p>Next, we will define some child routes:</p>
        <figure>
          <img src="./images/Fig07-008.png"/>
          <figcaption>Fig 07-008</figcaption>
        </figure>
        <p>So, I bet you can guess what these child routes are. They are the different routes that our application is
          making use of:</p>
        <figure>
          <img src="./images/Fig07-009.png"/>
          <figcaption>Fig 07-009</figcaption>
        </figure>
        <p>so, the artist create, detail and edit. Each of these, all three of them, will look nearly identical. They're
          all going to be an object that will specify a path and a get component function. The path is a path to use to
          decide when we want to show this component. And so, hey we can read directly off of the jsx. We want artist
          new, artist ID and artist ID edit. So, we'll start off with artist new first:</p>
        <figure>
          <img src="./images/Fig07-010.png"/>
          <figcaption>Fig 07-010</figcaption>
        </figure>
        <p>Now, the complexity starts to come in with this get component function. By default, React-router assumes that
          when you are trying to use it, it has already loaded up, or you have already loaded up all the different
          components that you want to show on the screen. So it assumes that you've already loaded up a component of
          artist create, artist detail and artist edit.</p>
        <p>However, if we want to asynchronously load up our component, we can use this get component function. It takes
          the arguments, location and cb:</p>
        <figure>
          <img src="./images/Fig07-011.png"/>
          <figcaption>Fig 07-011</figcaption>
        </figure>
        <p>Cb right here is the real magic. React-router expects us to call cb. It is a function that expects us to call
          cb with our module or with our component after we have successfully loaded it up. So in essence, our strategy
          inside of this get component function right here, is to place our system.import call to dynamically load up
          the component, and then after we have loaded it up, we will call cb with the component that we just loaded.
          Now, I don't want this section to get too long so let's take a quick break and then finish the refactor inside
          of our router.</p>
        <h2>Plain Routes with React Router Codesplitting</h2>
        <p>In the last section we started using code splitting within our React Router application. All we have to do is
          take our existing jsx routes and transform them into some plain route components. Again, the jsx that we've
          got ends up getting translated into the same exact structure of plain javascript objects that we are currently
          doing so we're technically kind of saving re-act router a step in translation here.</p>
        <p>We defined our root component, the path on which to show it, and our index route. And we are currently in the
          process of defining all the child, all the child routes, excuse me, that the home component can show. We also
          introduced the idea of a getComponent function, React Router will automatically call this get component
          function. Inside of it, we can fetch the code for our child component and once it's fetched we'll call this
          callback with that component. So that's where we are right now.</p>
        <p>We can add in some logic to fetch our component, which in this case is going to be the ArtistsCreate
          component with another System.import() call. So, remember the purpose of System.import. Whenever a webpack
          sees, literally the characters, or literally the string System.import in our code base, it will automatically
          modify the bundle that is generated to split off a second bundle or a sub bundle that can be fetched
          dynamically to load all the code inside of it.</p>
        <p>All we have to do is pass the path to the module that we want to import. We're going to scroll to the top
          just a little bit and right up here you'll find the path for ArtistCreate, which is the component that we are
          currently trying to show. So I'm just going to copy the exact path right here:</p>
        <figure>
          <img src="./images/Fig07-012.png"/>
          <figcaption>Fig 07-012</figcaption>
        </figure>
        <p>and we'll pass it into the System.import call:</p>
        <figure>
          <img src="./images/Fig07-013.png"/>
          <figcaption>Fig 07-013</figcaption>
        </figure>
        <p>and then I make sure that I have a string in there. There we go. So, because this is an asynchronous call,
          remember it returns a promise; the promise will be resolved as soon as the module has been successfully
          loaded. So we're going to take that module and we're going to call the callback function with the module that
          just got loaded:</p>
        <figure>
          <img src="./images/Fig07-014.png"/>
          <figcaption>Fig 07-014</figcaption>
        </figure>
        <p>So say cb and then here's the one big gotcha, or I should say the two big gotchas. Around this whole code
          splitting process, the callback right here takes a first argument of an error object so if there is any error
          in loading this module the first argument will be an error. In our case, we can very, we can very safely
          assume that if we are in this.then case right here, that there was no error with loading the module. So we'll
          pass in null as the first argument to say, "hey, we loaded the module, everything looks good".</p>
        <p>And then the second argument, which is also the second gotcha, remember, when we load up this module it is
          the entire javascript module and the actual code that we care about is available on the.default property, like
          so.</p>
        <p>Okay, so that's it for doing code splitting with react router. This right here, 100 percent copy paste-able.
          All we have to do is update the path with which we want to show this thing and also input, or also update the
          path to the module that we want to import as well.</p>
        <p>So, we've got two other components that we need to do a refactor for. So, I'm going to copy/paste this object
          twice. So, I've got everything from path to get component, I'm going to make sure I add in the semi colon and
          then I'll paste. So I know there's a lot of code on the screen right now but we've got child routes, we've got
          the route that we just added, and then the route that I just copy/pasted in:</p>
        <figure>
          <img src="./images/Fig07-015.png"/>
          <figcaption>Fig 07-015</figcaption>
        </figure>
        <p>Now, we'll update this one as well. So I need to update the path to use or like the actual url and the path
          to the module as well. So the next one that we're going to take care of is artist detail, the artist detail
          component. So it looks like the path or the URL to use is artist:ID. So let's do that first. So on the second
          path or the second child route,we'll do artist: ID:</p>
        <figure>
          <img src="./images/Fig07-016.png"/>
          <figcaption>Fig 07-016</figcaption>
        </figure>
        <p>and then we want to grab the ArtistDetail component. So I'm gonna make sure to update the module path, as
          well.</p>
        <p>Okay. Just one more copy/paste. I know these copy/pastes are very large. So we'll do the last copy paste,
          there we go. So, I've got another object in here. Don't forget the comma:</p>
        <figure>
          <img src="./images/Fig07-017.png"/>
          <figcaption>Fig 07-017</figcaption>
        </figure>
        <p>
          And the last path that we have to do, let's double check down here, artistID edit. So we've got
          artistsID/edit. And then we will update the path on here, as well, to the component ArtistEdit:</p>
        <figure>
          <img src="./images/Fig07-018.png"/>
          <figcaption>Fig 07-018</figcaption>
        </figure>
        <p>Okay, so a little bit of a nasty refactor just because there's so much code on the screen. So we've now
          defined this big object called componentRoutes:</p>
        <figure>
          <img src="./images/Fig07-019.png"/>
          <figcaption>Fig 07-019</figcaption>
        </figure>
        <p>and we need to make sure that we actually use it inside of our router. So I am going to scroll back down to
          all of our jsx and I'm going to find our RoutesComponent:</p>
        <figure>
          <img src="./images/Fig07-020.png"/>
          <figcaption>Fig 07-020</figcaption>
        </figure>
        <p>Here it is. So we just refactor all of this jsx right here into a single javascript object. So we don't need
          any of this jsx anymore because it's being taken care of in that code that we just added. So, we're going to
          take all this code:</p>
        <figure>
          <img src="./images/Fig07-021.png"/>
          <figcaption>Fig 07-021</figcaption>
        </figure>
        <p>everything from the nesting route and the four internal routes and we're just going to dump it.</p>

        <p>This is now a self-closing tag. So I'm going to take off the closing tag and I'm going to make sure I close
          this tag off as a self-closing tag:</p>
        <figure>
          <img src="./images/Fig07-022.png"/>
          <figcaption>Fig 07-022</figcaption>
        </figure>
        <p>So at this point, we've got router, the history object, and then the closing tag.</p>
        <p>Now, the very last step, we need to tell the router what route configuration object it should use so we'll
          pass in a routes={componentRoutes}, like so:</p>
        <figure>
          <img src="./images/Fig07-023.png"/>
          <figcaption>Fig 07-023</figcaption>
        </figure>
        <p>And so, component routes right here, is the object that we just declared; it's a big route configuration
          object. So I'm going to scroll back up now. There's one last step. So here is componentRoutes. The very last
          step is to remove all the import statements for the ArtistDetail, the ArtistCreates, and the ArtistEdit. So
          I'm going to highlight all three of these import statements and we're going to take them out because those
          modules are now being dynamically loaded:</p>
        <figure>
          <img src="./images/Fig07-024.png"/>
          <figcaption>Fig 07-024</figcaption>
        </figure>
        <p>Okay. That's pretty much it. Now, the big thing I want to point out here again, is that we are choosing to
          leave behind both the Home component and the ArtistMain. The reason that we're doing this is that these are
          the two components that will be shown whenever like a brand new user comes to the root route of our
          application.</p>
        <p>So we are going to assume, or we're going to want to say that, you know, if they're going to that very root
          route, chances are, maybe it's like their first time on our application. Right? Or maybe they're going to a
          log in screen or something like that. I basically, kind of, expect ArtistMain to be the most commonly visited
          component in my application. And because I expect it to be the most commonly visited, I want it to load up
          with my application instantly every single time as opposed to having to do in another, you know, round trip
          trip, or another, another round trip request to fetch an additional module.</p>
        <p>So we could have very easily included ArtistMain as a fetched component inside of our hierarchy but I think
          that makes a lot of sense to just include it by default:</p>
        <figure>
          <img src="./images/Fig07-025.png"/>
          <figcaption>Fig 07-025</figcaption>
        </figure>
        <p>Okay, so I'm going to make sure that I've got my webpack dev server running and we're going to do a little
          bit of a test to make sure everything is still working. So I'm going to go back over to my code. All right,
          I've got a big error message at my terminal so it looks like I left off a semi-colon here:</p>
        <figure>
          <img src="./images/Fig07-026.png"/>
          <figcaption>Fig 07-026</figcaption>
        </figure>
        <p>totally my mistake. You'll want to check your terminal as well and see if you have any error messages like
          this as well. So, I'm going to tab back over and I'm going to fix up this missing semi-colon. So on my child
          routes I think I'm missing one basically, after every path. So, I'll save this and looks like we are, there we
          go:</p>
        <figure>
          <img src="./images/Fig07-027.png"/>
          <figcaption>Fig 07-027</figcaption>
        </figure>
        <p>So now I've got a successful rebuild of my project, which means I'm ready to test it out inside the browser.
          So I'm going to go back over to Chrome. I'm going to make sure I'm that local host, 80 80, and then I'll
          refresh the page:</p>
        <figure>
          <img src="./images/Fig07-028.png"/>
          <figcaption>Fig 07-028</figcaption>
        </figure>
        <p>Okay, so it looks like everything loads up just the same as I would expect. You'll notice that I've got the
          network tab in my chrome console open, and I'm filtered by only javascript scripts. So now in theory, if I go
          to any of the other routes in my application I would expect to see an additional javascript bundle request in
          here to get that additional component. So let's click on the play button for Angus Spinka. That will take me
          to the artist detail component:</p>
        <figure>
          <img src="./images/Fig07-029.png"/>
          <figcaption>Fig 07-029</figcaption>
        </figure>
        <p>And as soon as I do, you'll notice the additional request for one.C3 blah, blah, blah. And I can go to say,
          CreateArtist, and I get two, and I think that if I go back to the edit screen, so here's edit again. And if I
          go to the edit page right here, then I get module 0:</p>
        <figure>
          <img src="./images/Fig07-030.png"/>
          <figcaption>Fig 07-030</figcaption>
        </figure>
        <p>which was the edit component. Cool. So, it looks like everything is working out pretty well. I've got an
          additional code splitting mechanism attached to React Router and this makes sure that for really large
          applications I can split off all my code and only fetch the additional modules as required.</p>
        <p>Now, the last thing I want to mention about code splitting with React Router, is that you really don't need
          to go overboard. So if you've got an application that's only like a handful of different pages, you probably,
          you know, maybe you don't really need code splitting. It's once you start getting into the applications that
          have tons and tons of different routes that you'll want to start thinking about adding code splitting to your
          application.</p>
        <p>The very last thing I want to mention is you'll notice that inside of our child routes, each route that we
          have looks a little bit repetitive. Right? It definitely looks pretty repetitive. You might be thinking,
          Stephen, can't we make like a helper function here to handle get components and maybe just pass in like, you
          know, the route by itself and then to help or function do the actual system import call?</p>
        <p>Well, I want to remind you, now, don't forget that React, or it's in the web pack, manually scans your code
          base looking for system.import calls and when it sees one and then takes the string right there and forms a
          additional module out of the string. And so, webpack doesn't really have the ability to handle a lot of fancy
          string concatenation or interpolation, or anything like that, because it's very static analysis, you know,
          literally just reading over your code. So we couldn't really do something very easily like pull out a string
          and then dynamically generate it based on the location that the user is navigating to. It doesn't quite work
          so robustly.</p>
        <p>Okay, so that's it for React Router and code splitting. Let's continue on with our next topic in the next
          section.</p>
      </div>
    </div>
  </div>
</div>
</body>
</html>
