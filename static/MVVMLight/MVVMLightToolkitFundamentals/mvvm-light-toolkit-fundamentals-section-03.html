<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

<head>
  <meta charset="UTF-8">
  <title>MVVM Light Toolkit Fundamentals</title>
  <script src="https://unpkg.com/vue"></script>
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
    integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
  </style>
</head>

<body>
  <div class="container" id="app">
    <div class="panel-group">
      <div class="panel panel-primary">
        <div class="panel-heading">
          <h2>MVVM Light Toolkit Fundamentals</h2>
        </div>
        <div class="panel-body">
          <div>
            <h2>The Core Components</h2>
            <div>
<h3>Introduction: What is MVVM Light and What is it Not?</h3>
<p>In the previous modules, we saw some of the advantages of the Model-View-ViewModel Pattern. And we also learned how to refactor an existing application to MVVM. To do this, we didn't use any toolkit or framework. In this module, we will introduce some of the components of the MVVM Light Toolkit and we will see how they can help you to code faster. First, I would like to have a discussion on what MVVM Light is and what it is not. Often, people talk about MVVM Light as a framework, but I prefer to call it a toolkit. This is a subtle difference, but it helps to understand what MVVM Light actually does. Then we'll start studying the MVVM Light components with a foundational ObservableObject, and ViewModelBase classes. The ViewModelBase was actually the very first item added to MVVM Light. These two classes help your code to be cleaner and more efficient. We will continue with a study of the RelayCommand; a very convenient object that allows you to write less code, to expose properties, implementing the ICommand Interface. After that, we will see what the Messenger does. This is a very powerful object, but with great power comes great responsibility, and it is important to understand well how this component works and to take some precautions. We'll finish this study of the core MVVM Light components with a DispatcherHelper. This is a lesson on components that provides a lot of help when dealing with asynchronous code and background threads. At the end of this module, you will have a good understanding of all the components in the code DLL of MVVM Light and be able to use them in common scenarios in the XAML application. Before we talk about each component, let's understand ‘What is MVVM Light? ' and ‘What is it not? ' MVVM Light is a toolkit, it is not a framework. With Toolkit, we understand that it is a suite of tools, some helper classes containing two DLLs, project templates, item templates, and code snippets for Visual Studio. Those are helpers to help you go faster into your code, to avoid the monotony of having to write the same code over and over and over again, and of course those tools are not only useful for XAML-based applications, but some of them, such as a Messenger or SimpleIoc, can be used for any type of decoupled application. MVVM Light, however, is less intruding than the framework and lets you select which components you want to use and which ones you want to leave aside.</p>
<h3>The ObservableObject and the ViewModelBase</h3>
<p>Talking about the components, let's start with two classes very useful for databinding; the ObservableObject and the ViewModelBase. In a typical MVVM application, the ViewModel layer and the Model layer will have multiple classes. Let's start with the ViewModel. In this layer, the classes typically implement the INotifyPropertyChanged interface. Until now we implemented INotifyPropertyChanged explicitly on each of the classes of the ViewModel. Of course this is quite a lot of repetitive work and this can be simplified by adding a ViewModelBase class, by having the ViewModel classes inherit this class and by implementing INotifyPropertyChanged directly in the base class. We can also have multiple flavors of the RaisePropertyChanged method, and some Helper's properties that we add to the ViewModelBase class. In the Model layer, we can also have the classes implement INotifyPropertyChanged. And here too, until now, we implemented INotifyPropertyChanged on each of the classes. It is also interesting to have a base class, named ObservableObject, which is very similar to the ViewModelBase. And in fact, ViewModelBase can easily inherit from ObservableObject in order to simplify the implementation. Classes deriving from ObservableObject and ViewModelBase can use a variety of methods to raise a PropertyChanged event. Of course, the "Classic" one, raising the PropertyChanged event with a string for the property name, and here typically we will use a constant for the property's name. But there are also more comfortable ways; for example, the RaisePropertyChanged method, which takes an expression as parameter. Using an expression to identify the properties that have changed is better than the string, because it supports IntelliSense, and also if you change the name of the property, automatic refactoring tools will help you to propagate the change everywhere in your code. There is a very small performance impact because of the need to use some light Reflection to get the name of the property. Another method, named Set, can help you to create even less code, like we will see in the sample. For classes in the ViewModel layer, you can also broadcast the PropertyChanged event through the Messenger class. Later in this module, we will learn how to use the Messenger to send messages from object to object. This is a very decoupled manner of communicating. To do this, you use an overload of the RaisePropertyChanged method, which in addition of the property name, takes the oldValue, the new value, and the parameter specifying if you need to broadcast using the Messenger. Of course, just like before, you also have the other variants of these methods, and the message sent through the Messenger class is a PropertyChangedMessage, like we will see a little bit later in the section about the Messenger. In addition to the PropertyChanged event, MVVM Light also supports a PropertyChanging event. This event is raised just before the property changes, when the property still has the oldValue, which can be useful in certain scenarios. ObservableObject and ViewModelBase supported two overloads of the RaisePropertyChanging method, and the Set method that we saw before is also automatically raising the PropertyChanging event. Classes deriving from ViewModelBase can use the IsInDesignMode property. This property is useful because XAML frameworks have different ways to check if the code is running into a Visual Designer, such as Blend. For example, this is a code that we would use in Silverlight and Windows Phone, in Windows Store Application in Windows 8, and in WPF. So MVVM Light proposes a way to unify all that, and has just one property, named IsInDesignMode. For convenience, this value is also exposed in a static property on the ViewModelBase class.</p>
<h3>The ObservableObject and the ViewModelBase (Demos)</h3>
<p>Now we can refactor the small application that we built in the previous module to use MVVM Light. The first thing we will do is add a reference to the MVVM Light assemblies. To do this, I'm going to select ‘Manage NuGet Packages', go online, and type mvvmlight in the Search box. I'm going to take the ‘libraries only' and click Install. (Typing) One of the libraries are installed. I can open the MainViewModel class and I'm going to change here the INotifyPropertyChanged interface implementation by having the MainViewModel derive from ViewModelBase. Now I can delete the INotifyPropertyChanged implementation, which I had at the end of this class. And the ViewModelBase class is going to take care of that. Then we can simplify the observable properties; for example, the SelectedFriend property. I'm going to remove this code here. And instead, I'm going to use the Set method, taking an expression for the property name. Here you see that I can use IntelliSense for that. And passing the value. Also, I can use the IsInDesignMode property to detect the design conditions. This is going to be useful, especially if we want to share code; for example, with Windows 8, WPF, or Silverlight. So here I can use IsInDesignMode directly, and in a static context, for example here in the constructor I can use IsInDesignMode static instead. Now we can take care of the Model class. So let's open, here, the Friend class. And here I'm going to derive from ObservableObject, which is a little bit more lightweight than ViewModelBase, and for example doesn't have design mode detection. Let's enhance this class by adding an IsDirty property. This property is going to be set to true, if the class needs to be saved to the web service. And we can refactor the FirstName and the LastName properties to a simpler form using the Set method, and notice that here we use a written value of this method to detect if the property has changed and to set the Dirty flag accordingly. And we can do the same here for the LastName property. (Typing) Of course what I can do is get rid of the explicit implementation of INotifyPropertyChanged, since now this is taken care of by the ObservableObject class. So here we are, this is a small step, but we have already refactored our application to take advantage of the MVVM Light classes. Now we can verify that our changes didn't break anything, let's run the new application here in the Emulator. I can Refresh. Just like before, the Friends list is being loaded and I can navigate to a Friend, do some editing, etc. So you see that everything's working just fine.</p>
<h3>Introduction to ICommand and RelayCommand</h3>
<p>After talking about ViewModelBase and ObservableObject, we can talk about the RelayCommand. RelayCommand is another very important component in the MVVM Light Toolkit, because it's going to help you to expose some functionality on the ViewModel in a very decoupled manner. The RelayCommand is an implementation of the ICommand Interface. This interface is not only useful for XAML-based frameworks, but it has definitely been used a lot, and especially since the Model-View-ViewModel Pattern got popular. The ICommand Interface defines three members; the Execute method is going to be called when the command is actuated, then there is the CanExecute method, which should return true or false depending on if the command can be executed at that point, or not. And there is a CanExecuteChanged event, which should be raised if the Status of CanExecute changes. So if anything in the context of the command changes and you want the CanExecute method to be called again, to be reevaluated, then you should raise the CanExecuteChanged event. Of course, implementing the ICommand interface for every functionality that you want to expose on the ViewModel is quite a lot of work. You will need to have a new class for each command. And this class should implement ICommand and should provide an implementation for Execute, for CanExecute, and also a way to raise the CanExecuteChanged event. This is obviously quite a lot of repetitive work, and here too, the MVVM Light Toolkit is going to simplify the process of implementing such functionality. To do this, MVVM Light proposed an implementation of ICommand, called the RelayCommand. Let's understand how this works.</p>
<h3>Demonstrating the Commands</h3>
<p>To better understand how RelayCommands work, we are going to start by understanding a standard ICommand implementation. So here we have a Windows 8 application, we have a MainViewModel, which is bound to the DataContext of the page, and we have here a TextBox. Here below, we have a button, and this button doesn't have a Click event, but instead it is using the command, which is bound to something called SayHelloCommand, which will be on the MainViewModel. And there is also a CommandParameter, which we bind to the TextBox that we saw just before, and we are going to use the TextProperty. Now let's take a look to this SayHelloCommand. So the SayHelloCommand is going to be on the MainViewModel. Let's open this class. And here we see that the SayHelloCommand is of type SayHello. So somewhere in the application, we have a class and here we see that the properties initialized to a new SayHello instance, which is using the current ViewModel as a parameter. The SayHello class is here and we see that this is an implementation of the ICommand interface. So constructor, like we mentioned, is taking an instance of the MainViewModel, which we are going to Save as a field, and then we have the ICommand implementation, the Execute method, which is going to be called when the command is actuated, so in that case when the button is clicked. And here what we will do is show a MessageDialog using the parameter that is passed to the command. Remember that in the XAML, we had a CommandParameter attribute, which is set. In addition to that, we implement the CanExecute method. Remember that this method needs to return true if the command can be executed, and false if it cannot be executed. And here we are going to rely on the _owner attribute. The _owner attribute is the MainViewModel which owns the command and which we passed in the constructor. Of course this is a little bit annoying to have a dependency like that from the command to the MainViewModel, but here this is, unfortunately, what we have to do. On the _owner, we are going to check the Counter property, and if this property can be divided by 2, we are going to return true, meaning that the command can be executed. The last member of the ICommand interface is the CanExecuteChanged event. And of course we need to raise this event if the context changed and if the CanExecute method needs to be reevaluated. So how do we do that? Well because we are outside of the MainViewModel and we want to react to a change of the Counter property, we'll need to observe the PropertyChanged event of the MainViewModel, and if the property that is changed is the Counter property, then we are going to raise the CanExecuteChanged event and this will force the Binding to that command to call CanExecute again. So this is a basic way that the command works with a Binding, and because a Binding is to a control which can be disabled, when CanExecute returns false, this button is going to be disabled automatically. Let's take a look at a small application. I'm going to enter my name, and if I click the button, the command is executed and the message dialog is shown. Now if increment the Counter, for example going to 1, this forces a CanExecute method to be re-executed, and this time it will return false because 1 cannot be divided by 2. So as a consequence, the button to which the command is bound will be disabled. If I increment again, this time the CanExecute method returns true and the button is enabled.</p>
<h3>RelayCommand Demo</h3>
<p>MVVM Light allows to simplify the small application by taking care of the ICommand implementation. Notice that we don't have the SayHello class anymore. Instead, the SayHelloCommand is of type RelayCommand of string. And of course the string is a type of the CommandParameter; in this case we passed a TextProperty of the TextBox control. The RelayCommand is constructed here and it takes two parameters. The first parameter, which is compulsory, is the delegate to the Execute method. In this case, we use a named method, called ShowMessage, and notice the parameter of type string. This method does exactly the same as before; it simply shows a MessageDialog. The second parameter is optional. In this case, we use an anonymous lambda expression, and this is a delegate to the CanExecute method. Based on the written value of this method, the command will be enabled or disabled. In this case, we take the Counter attribute and then we check if it can be divided by 2. If the result of this expression is true, this is what we return, and the command will be enabled. Depending on your personal preferences, you can use named methods or anonymous lambdas for those to delegate, or you can mix and match them. Of course the code is much simpler, because a RelayCommand property has direct access to private members of the MainViewModel; for example, here, the Counter attribute. In order for the CanExecuteChanged event to be raised, we use a built-in raised CanExecuteChanged method. Here, every time that the _counter property is set, we will raise the CanExecuteChanged event for the SayHelloCommand. Running the application produces the exact same result. (Typing) But even in this small application, the advantage of using a packed implementation of ICommand is quite clear.</p>
<h3>RelayCommand Slides</h3>
<p>So let's review what we know about RelayCommands. The RelayCommand is a packed implementation of the ICommand interface. It needs a delegate to the Execute method, which will be invoked when the command is actuated. Optionally, you can also pass a delegate to the CanExecute method, which specifies if the command is enabled or disabled. Note that if the control to which the command is bound allows it, the control will be disabled if CanExecute returns false. The RelayCommand has a method called RaiseCanExecuteChanged that will, well, raise a CanExecuteChanged event. This will false the system to reevaluate the CanExecute method, and possibly change the state of the control to which the command is bound. The advantage of the RelayCommand is that, since it is packed, it replaces an explicit implementation of the ICommand interface, which saves quite a lot of work. When you create a new instance of the RelayCommand here as a public property on the ViewModel, you pass a delegate to the constructor. This is the Execute method, which can be declared explicitly a name, as shown here, the DoSomething method. Optionally, it is possible to pass a second delegate, which can also be a named method; in this case, the CanDoSomething method. This method returns a Boolean, true if the command is enabled, and false if the command should be disabled. However, it is also possible to declare each of the delegate as anonymous lambda expression. For example, here the Execute delegate is an anonymous lambda. Or here, the CanExecute delegate, which returns true or false. Note that for simple expressions, another possible syntax for the CanExecute lambda is to avoid the returned keyword, as shown here. Finally, there is also a generic implementation of RelayCommand, taking a type parameter. This is a type of the comment parameter, which the ICommand interface allows. There can be only one parameter per command, which is a restriction of the ICommand interface itself. Generic RelayCommands are built in a similar manner, for example with a named method, and here note the parameter of the DoSomething method. Same thing for the CanExecute delegate, it also receives as a string parameter. And finally, each of the delegates can also be an anonymous lambda expression, just like before, with a single difference that the lambda expression is declared with a parameter, in this case of type string.</p>
<h3>The Messenger, Receiving and Sending Messages</h3>
<p>Now I would like to talk about an important component of the MVVM Light Toolkit, a component which is easy to love, but which can also be easy to overuse, the Messenger. First let's review how conventional event handling works in. NET. One issue we have is that registering an event handler will often create a strong link between the instance handling the event and the instance raising the event, so this, of course, is a potential memory leak. For reference, this is how you register an event handler in. NET; for example, the Click event of the button. And this is how you unregister in order to remove any risk to a potential memory leak. Of course there is also another difficulty, which is how to even find the instance raising the event that we want to register to. Sometimes, this instance can be hidden, or it can be located in a part of the application that is not easy to access. Or, sometimes, the event subscriber doesn't even know if there will be such an instance at runtime; for example, in a plugin scenario. And of course this is especially a problem with decoupled application, when one part of the application knows as little as possible about other parts. So for all these scenarios, the Messenger can help. What is Messenger? Well sometimes it's called an "event bus". Simply said, it is a system that sends messages to a list of recipients. It is fully decoupled, so the center doesn't know if any recipient gets the message. And the recipient also doesn't know who sends the message, so recipients register to receive the messages based on some criteria. Typically, we use a default instance of the Messenger, but it is also possible to create new instances of the Messenger, which will each operate on their own private channel. In order to get a message, the recipients inform the Messenger that it is interested in a specific message type, and the type can be anything, from a value type like int, bool, etc., to normal. NET classes. Typically, messages are broadcasted to all recipients that registered for that message type, but it is also possible to open a "private channel" with a token, like we will see in a moment. In the typical case, the message recipient registers to the default Messenger instance using one of the Register methods. The important parameters are, the type of the message, the instance that registers in order to check the lifetime, and a delegate to the message handling method. There are multiple ways to register for a message. If you remember the section about RelayCommands, this is quite similar. You can easily pass a delegate to a named method, which will receive the message. Or, if you don't want to look for a name for this method, you can pass an anonymous lambda expression, as shown here. In both cases, notice the message parameter, which contains whatever was sent. Sending a message is even easier. Again, any kind of object, even simple values, can be sent. For example, here is how you send an instance of MyMessageType. Like mentioned before, you could possibly send a Boolean value if really you wanted to. Of course this is probably not a great idea, as there is absolutely no context and the recipient is unlikely to know what to do with that message. In a simple Master Details app, we could just send a selected item; for example, here's a selectedFriend. Of course, here too, some context is missing, and if the application grows more complex, it might be necessary to refactor this part to add the missing information. The more realistic scenario is to send dedicated message types. There are a number of built-in message types in MVVM Light; for example, the very useful NotificationMessage. This message type takes a string, an instruction for the receiver. It can also carry a payload, in this case a selectedFriend. Optionally, these built-in message types can also carry a reference to the message sender. A little bit like conventional events, often pass the event sender to the subscriber. This can be useful, but of course we need to be careful not to store this reference and create, again, the memory leaks that we were trying to avoid.</p>
<h3>Messenger Advanced Options</h3>
<p>Let's talk a little bit about memory here. When the recipient registers to the Messenger with a message handling method, the Messenger keeps, of course, a reference to this method. Sometimes, it can be difficult to unregister. We do our best to avoid the discourses of memory leak. Notably, whenever possible, the message handling methods are kept as weak references, so that the object can be garbage collected, even if they didn't unregister first, but sometimes this is not possible. The table here shows a summary. Message handling methods can be Static, Public, Internal or Private. They can also be anonymous Lambdas, which is the same as a Private method. In WPF and in Windows 8, there are no problems. You can register a private method or a lambda expression as message handler, and it will not create a strong leak. In Silverlight and in Windows Phone, unfortunately, there are some additional security restrictions in place. Because of this, it is not possible to create a weak reference to a Private, Internal or Anonymous method. Only Static or Public methods are fully safe in these two frameworks. So if you use Silverlight or Windows Phone, make sure to analyze your scenario carefully. If you see a risk for a memory leak, you should unregister the message handling method. Unregistering is quite easy and is generally a good idea to keep things clean. You can easily register a recipient altogether, for all the delegates that it registered, or you can unregister for a specific delegate. If you are using Tokens to open private channels, like we will show in a moment, you can also unregister using the same Token. So let's talk about these tokens. This is a special case, but it can prove useful sometimes. In this scenario, one or more recipients can register using a token in the Register method. So token can be anything, it just has to be unique. When the Sender sends a message using the same token, the Messenger will filter who receives the message. So even if Recip 2 registered for that message type, because it didn't use a token, it will not receive the message at all. This prevents a need to write filtering logic in every recipient. From a code standpoint, this is how it works. Here we use a Guid as a unique Token, but again it could be anything, such as a string or an instance of an object. Then we call the Register method using the Token as parameter. And, of course, the same Token is used in the Send method of the Messenger. Another special case that can be very useful, is a possibility to register for an interface or a base class. For example, let's imagine an IMessage interface, implemented by a class called ImplementMessage. If a recipient registers for a message of type IMessage and sets this Boolean flag to true, then the method will be called when any message implementing IMessage will be sent. This is true when you send a message of type ImplementMessage, but it is also convenient with GenerateMessage, that can carry a payload of various types. In this case, the method will be called whatever the type of the payload is. Then it is easy to handle the payload of the message. I guess that this presentation wouldn't be complete if we didn't mention a few dangers. It is very tempting to overuse a component. If you overuse the Messenger, this can lead to confusing code, where it is not exactly clear what is happening. If people with less experience have to maintain this code, this can cause difficult situations. Be reasonable; for me the Messenger is a last resort, when I cannot or don't want to use conventional code, like event handlers, and when for some reason I cannot use an IOC container with some services, like we did with the DialogService or the NavigationService. Finally, be advised that it is always right. Test your code for memory leaks, make sure you cover everything with test cases, and if you are in doubt, use the Unregister method.</p>
<h3>Messenger Demos</h3>
<p>In order to demonstrate the Messenger, I will use a Windows 8 application, but these components work exactly the same in Windows Presentation Foundation, Silverlight, Windows Phone, and Windows 8. We will let some user controls communicate in a decoupled manner and demonstrate a OneWay message, as well as a message with feedback. Here we have an MVVM application with a receiver and a SenderViewModel. So Sender can send two kinds of messages; one message type is named LogMessage and carries a Text and a Timestamp. If we run the application, we notice this blue area, this is a SenderViewModel. There is a Send button and a text field. Let's enter a message. And then we can press Send. Nothing happens because there is no receiver registered to get this message. In the ApplicationBar, there is an add button. This adds a user control with a ReceiverViewModel as its data context. If I press the Send button now, the message of type LogMessage is Send, because each of the ReceiverViewModel subscribed to this message type, we can see that those three user controls are getting it. If we add a false user control and send the message again, we see that all four user controls get the message, but for the sender it doesn't make any difference. In fact, if I remove all the receivers, and send the message again, nothing happens. The sender doesn't know that no one got the message. Now let's look at another message type called LogMessageWithFeedback. It is based on the previous message type, LogMessage. In addition, it has a Feedback property, which is an Action<bool>. We will use this action to send Feedback after the user has confirmed or cancelled the message. Let's register a mix of receivers. (Typing) Just like before, the red ones listen to a LogMessage. The orange ones, on the other hand, listen to a LogMessageWithFeedback. So first, let's send a LogMessage. Here we see that only the red ones got it. If I send a LogMessageWithFeedback, the orange ones got it, but not the red ones. Using the LogMessageWithFeedback, the user can send some Feedback to the sender. This will execute the Action<bool> and the dialog is shown; for example, here OK or here Cancel. Of course the parameter could be anything. Here I use the Boolean, but it could be a string or even a complex object type. Let's take a look at the code. First, the two message types. This here is a LogMessage, and as you can see, it's a plain old object with two properties; the Text and the Timestamp. Here is now the LogMessage with Feedback. Like we saw before, it is based on the LogMessage, so it also has the two properties, Text and Timestamp, but in addition it has this Feedback property, which is going to be used to send some Feedback back to the Message sender. Now let's go to the SenderViewModel. And here we see what happens when a message needs to be sent. First, the message is constructed here, we take a LogMessage, and then we use Messenger. Default to Send the message. If we need some Feedback, we will go to the other command and here we build a Message with Feedback. which also takes a Text, a Timestamp, and the Action<bool>, which is going to be executed whenever the user wants to give some Feedback. Here when the Action is executed, we will show a MessageDialog using the result to show the string "OK" or "Cancel". Now we can look at the ReceiverViewModel, and this is where we will register for the type of message that we want to receiver, either for LogMessageWithFeedback or with a simple LogMessage. Like we saw in the slide, the Receiver method needs a reference to the receiver itself, in order to monitor the lifetime, and a delegate to the method which will be executed, in this case we will build a string with the parameters from the message, Text and Timestamp, and then we will assign this to the Display property, which is data bound in the XAML. In the case of the Feedback message, we will also Save the _feedback property, which is an Action<bool>, so that we can execute it later. The execution of the Feedback is shown here. This is a command which is bound in the XAML to the OK and the Cancel button, and you can see that we will simply execute the _feedback action and we will pass here a Boolean as a result parameter. Finally, notice that we take care here of unregistering the two message types. For simplicity, we simply unregister everything when the user control is unloaded. This is not strictly necessary, because in Windows 8 even private methods can be saved with a weak reference, and the receiver can be garbage collected, even if we didn't do that, but it is always a good policy to cleanly unregister whenever possible.</p>
<h3>Dispatching to the UI Thread With the DispatcherHelper</h3>
<p>Now we will talk about the lesser known, but useful component of MVVM Light; the DispatcherHelper. In modern applications, multithreading is more and more important. For example, Windows Presentation Foundation allows doing synchronous web request to a server. However, in Silverlight, which came later, it is not possible anymore. All web requests have to be asynchronous, which is to say that they are multithreaded. Similarly, in Windows 8, which is the most recent XAML-based framework, every file access has to be asynchronous, as well as many other operations. So more and more, we see that we need to program in multithreaded environments. However, this is not always easy. There are a few things that need to be taken care of. In this section, we will talk about an issue that may very well crash your application if you don't pay attention. So let's review how threading works in. NET. All XAML applications start with a Main Thread. This thread is like a queue, where all operations are executed one after the other. From the Main Thread, it is possible to start one or more Background Threads. This can be explicit, for example by calling the ThreadPool class, or by using a BackgroundWorker, etc. In a more complex manner, however, some operations can also operate on a Background Thread, without the developer being always aware of it. For example in a Phone application, some senses can raise events on the Background Thread; for example, the Compass Sensor or the accelerometer, etc. Another example is the HttpWebRequest class, which is used to send complex web requests to a server. Even if the request is sent from an application's Main Thread, the response is always received on the Background Thread. One issue in that case is that we sometimes need to get back on the Main Thread from the Background Thread. This is necessary, because the Main Thread owns all the UI elements. So, if an operation running on the Background Thread attempts to modify an object owned by the Main Thread, an Exception is thrown because of Invalid Cross Thread Access. Here we see an example of code that can crush the application, because the StatusTextBlock is a UI element, but it is accessed from the Background Thread, the Exception is thrown. In order to clean this up, we need to take some precautions. The Background Thread will contact the Main Thread's Dispatcher and request that the operation accessing the UI element is executed on the Main Thread directly. The Dispatcher is a kind of controller for the thread and there is exactly one Dispatcher per thread. In code, here is how we do things. Know that in Windows 8, things would be slightly different, but the main point remains the same. We have to use a Dispatcher object to send the request to execute the operation. In this case, the UpdateStatus method on the Main Thread. This method will then safely access the UI element. In theory, this is relatively easy, but there are a few difficulties. First, the Dispatcher property that we used before is only available on the view; for example, in a page or a window. If we execute the method in a ViewModel, accessing the Dispatcher can be difficult. Also, the syntax is a little bit complicated, and it is not the same in all the XAML frameworks. For instance, in Windows 8. 1, the Dispatcher API is not the same as in Windows Phone, WPF or Silverlight. In order to simplify all this, we can use the DispatcherHelper component of MVVM Light. So DispatcherHelper stores an instance of the main Dispatcher and provides unified access to its API, whatever the framework is. First, the class must be initialized. If possible, as soon as the application starts. It is important that the call to Initialize is executed on the Main Thread, which is quite easy. Then, whenever some code is executed on a Background Thread like here, the CheckBeginInvokeOnUI method can be used. This method receives a delegate, in this case a lambda expression. This delegate will be executed on the Main Thread. The DispatcherHelper will check if direct access to the UI element is possible. If yes, the method will be executed at once without waiting. On the other hand, if a Cross Thread Access is needed, the DispatcherHelper will execute the dispatching properly.</p>
<h3>DispatcherHelper Sensor Demo (Windows Phone)</h3>
<p>We are going to see a few examples of scenarios where the DispatcherHelper becomes useful. First, we will study a small Windows Phone application using the accelerometer sensor. This is one of the sensors that works on the Background Thread. Not all of them do. The Geo Coordinate Watcher component, for example, returns its values on the Main Thread directly. So when you read the location, you don't need to dispatch the result to the UI Thread, but when you read the heading with a compass, or an acceleration using the accelerometer, you need to do so to avoid a crash. So DispatcherHelper allows you to stop worrying about that, because it will automatically find out if dispatching is needed or not. In this small application, I have a MainViewModel, which is going to subscribe to a service called ISensorService. This is an abstraction of the sensors. In this sample I only take care of the acceleration, but we could easily add all the sensors, such as compass or location. The ISensorService is located in the Model. We have one method called RegisterForAcceleration, and here is the implementation of the SensorService, and the RegisterForAcceleration method. This method takes a callback and it will execute the callback everything that the value of the accelerometer has changed. The callback is provided by the caller, in this case the MainViewModel. Let's run the application in Debug mode and see what happens. If I press the Start button here, the application will crash, with an invalid cross-thread access exception. This is a symptom of what we explained earlier in the slides. The Sensor event is executed on the Background Thread, which is also where the callback method is executed. However, if we inspect the MainViewModel code, which provided the callback, we see that it is assigning the returned value to the StatusMessage property. This wouldn't be an issue if the StatusMessage was not bound to a TextBlock in the XAML. We know that all UI elements belong to the Main Thread, so the crash happens when the UI element, the TextBlock, is being touched from the Background Thread through the StatusMessage property. To fix this, we are going to go back into the Service code and we are going to use a DispatcherHelper here. I'm going to use the CheckBeginInvokeOnUI method. This method takes an action as parameter, this is a delegate. And now I can copy the code to the _callback method, which is going to be executed on the Main Thread, so this is a safe zone. Note that for this to work, we need to initialize a DispatcherHelper. It can be done anywhere in the code, making sure that the Initialize method is called on the UI Thread. Typically, we do this in App. xaml. cs in one of the Initializer method, so that the DispatcherHelper is initialized as early as possible. Here in the Phone application, I do this in the InitializePhoneApplication method. Now we can run the application again and we will see that this time the application does not crash. And in fact in the Simulator, we can simulate shaking the device, here, using the shake Recorded Data. Again, not all sensors need to be dispatched to the Main Thread. The Location Sensor, for example, is automatically returning on the Main Thread directly. However, if you use DispatcherHelper, you don't have to worry about this.</p>
<h3>DispatcherHelper WebRequest Samples (WPF and SL)</h3>
<p>Another example is using a WPF application and a Silverlight 5 application using shared code. We are going to execute web code using an HttpWebRequest. Of course this is a very simple example and we don't really need this complex object; we could do the same using a web client. HttpWebRequest is useful when you need to do more complex operations, but here for the purpose of the demo, we'll use that anyway, because of the fact that it gets a response on a Background Thread. So here, everything inside the BeginGetResponseCompleted method is executed on this Background Thread. And as you see, we are trying to set the Status property, which is data bound to a TextBlock in the XAML UI. If we run this application in WPF, everything works fine. Here I can load the web page, and after a short delay, we see that the Status was updated. This is because WPF automatically dispatches a PropertyChanged event to the Main Thread. So here, everything works fine. Now I'm going to stop the application, and then I'm going to move to Silverlight. Let's set this as a startup project and I'm going to run the application again in Debug mode, and now if I press a Load button, we see that we get an exception, and if we check the details, we will see that there is an UnauthorizedAccessException, so again this is an invalid cross-thread exception. So in order to get the application to work, I'm going to have to use a DispatcherHelper again, and I'm going to do that in the BeginGetResponseCompleted method, just when the Status property is set. (Typing) And now, again, I have created a delegate, which will be executed on the Main Thread, and so I can set the Status in this safe zone. Now let's run the application again. And we will see that this time, the web page was loaded and the Status was set properly. Because we are sharing the MainViewModel code between Silverlight and WPF, using DispatcherHelper is very convenient, because in WPF nothing changes, so Status will be set directly on the Main Thread without dispatching; however, in Silverlight, the dispatching will be executed, but there's a developer, we don't have to worry about that; the DispatcherHelper component is taking care of this. This small example shows a value of having a component, such as DispatcherHelper, in order to simplify multithreaded code.</p>
<h3>Summary</h3>
<p>In this module, we discovered the core components of MVVM Light and we learned the features. We talked about the base classes used to make observable properties easier to use; the ObservableObject and the ViewModelBase. Then we studied commanding in. NET and we understood how the RelayCommand component of MVVM Light simplifies this task. We continued our tour with the Messenger component, a system allowing to send decoupled messages, even if the sender and the receiver don't know each other. And finally we finished with a short explanation of multithreading and dispatching in. NET, and discovered the DispatcherHelper component of MVVM Light. In the next module, we will continue to explore MVVM Light by discovering the Extras assembly and the components that it contains.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>

</html>