<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

<head>
  <meta charset="UTF-8">
  <title>MVVM Light Toolkit Fundamentals</title>
  <script src="https://unpkg.com/vue"></script>
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
    integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
  </style>
</head>

<body>
  <div class="container" id="app">
    <div class="panel-group">
      <div class="panel panel-primary">
        <div class="panel-heading">
          <h2>MVVM Light Toolkit Fundamentals</h2>
        </div>
        <div class="panel-body">
          <div>
            <h2>The Extras</h2>
            <div>
              <h3>Introduction</h3>
<p>Welcome to Module 4 of the MVVM Light course. In the previous module, we talked about the core components of MVVM Light, the ObservableObject, ViewModelBase, RelayCommand, Messenger, and the DispatcherHelper. We'll start this module with a discussion of how Views are bound to their respective ViewModels, and we'll discuss various strategies that we recommend using in MVVM Light applications. There are two more components that I would like to study in this module; the SimpleIoc and the EventToCommand. These two components are placed in a separate assembly called Extras. First we will start with an introduction to the Extras assembly, and why it is even there. Then, we will have a detailed study of the SimpleIoc component, an IOC container that is well suited for MVVM applications. Later, we will talk about the EventToCommand behavior and understand what behaviors are and what this particular element does. At the end of this module, you will understand the standard structure of an MVVM Light application and understand how the Views are bound to the ViewModels. You will also understand why MVVM Light comes in two separate assemblies, and you will know how to use a SimpleIoc and the EventToCommand components.</p>
<h3>Setting the DataContext</h3>
<p>At this point, I would like to take a moment to talk about the way that the ViewModel is data bound to the Views in a typical MVVM application. First let's recapitulate what the DataContext is. It is, in fact, a shortcut; it's a way to say, everything that happens here is in reference to this DataContext, unless explicitly specified otherwise. So we don't need to write the fully-qualified Binding expression, like we have here, in different places in this document. Instead, we can define the DataContext; for example, here, directly in the XAML. And then we can have tighter XAML expressions, which is much more comfortable; for example, here in the document. Of course we can still use fully-qualified expressions; for example, here, when we're referred to a property, defined in another resource named Strings. So in summary, the DataContext is really just a shortcut. It can be set in XAML, like in the previous slide, which works great with visual designers, such as Blend or the Visual Studio Designer, because these tools pass the XAML code when they render an element. So, of course, a DataContext is taken in account by the designer, and the built-in helpers take advantage of this knowledge. Sometimes, however, it is more convenient to set the DataContext in the code behind directly; for example, in the Master-Detail scenario, if we pass an object to the DetailsPage, it is quite frequent to set the DataContext to this object in the OnNavigatedTo method, such as shown here in Windows 8. These are the two main ways to set the DataContext, either in XAML through a resource or in the code behind. One thing to consider is that when the DataContext is set in code behind and not in XAML, the Visual Designer Tools do not run this code. In fact, they never run any code behind because, like this, we avoid some issues, for example with animations or other things that are typically triggered in this code. In the earlier demos, we saw the advantage of having Blend run some of the application's code, like this we can create some design time data. If, however, if we set the DataContext in code behind, we need to come up with another strategy to create the design time data. Thankfully the XAML Tooling Team thought of that and created a design time data context, which is very convenient. Here is an example. First, we declare an xmlns, pointing to the namespace in which the ViewModel is declared. We add another xmlns used by Blend in the Visual Studio Designer, typically with a prefixed "d", like design. This prefix is declared Ignorable. This indicates to any XAML parser that it should ignore any attribute prefixed by "d"; however, the Visual Designers look for these "d" prefixes and will use them for design time tasks. For example, here, the design time DataContext is set to an instance of the DetailsViewModel, which will be created at design time. Right now the MainViewModel is defined as a global resource in App. xaml. This is not very satisfying, because it forces the MainViewModel to be created as soon as the application starts, when the corresponding XAML line is parsed. If we have a lot of ViewModels, it means that all of them will be created when the application starts, which can slow down the starting time and is really not ideal. This is why MVVM Light proposes an additional degree of flexibility, with the addition of the ViewModelLocator. The ViewModelLocator provides some additional flexibility to control the lifetime of services and of ViewModels. In MVVM Light applications, we declare the ViewModelLocator in the global resources in App. xaml. The ViewModelLocator declares the most important ViewModels of the application as public properties, for example, here, the MainViewModel, so that it is easy to bind to them, for instance, using a visual tool such as Blend. Not all ViewModels are declared by the ViewModelLocator, however. It depends on how long they will be alive, when they are created, and so on. In MVVM Light, here is how the ViewModelLocator is declared in the App. xaml file, and here is how you can bind to the Main property of type MainViewModel in the view. Of course, if you have multiple ViewModels, you will have multiple properties with different names.</p>
<h3>Binding to a ViewModel (Demos)</h3>
<p>Let's implement these changes in our application. Again, I want to stress out that this application is a Windows Phone app, that the toolkit and all the implementation works exactly the same on every other XAML framework, such as WPF, Silverlight or Windows 8. We will use a NavigationService, which is closer from the one we use in Production Windows Phone applications. It has one more method, which we add in INavigationService. (Typing) This method allows to navigate to a URI and pass an object, a user state, to the page that we navigate to. Let's remove the primitive NavigationService we were using until now. And replace it with another one, which implements the new method. (Typing) This NavigationService implements the new NavigateTo method, it will save the state, and it also provides a new method, GetAndRemoveState, which is static and that every page can use to easily retrieve the state when it is navigated to. Then we will take care of the ViewModelLocator. Let's add this class in the ViewModel folder. (Typing) This is a plain object, which we will make public, and it exposes one public property, which is the MainViewModel. This property is exposed for data binding purposes. Then, let's add a constructor, which will take care of creating all the services, as well as a MainViewModel. As you can see here, we use a DesignMode detection to create the correct FriendsService, either the DesignFriendsService or the runtime FriendsService here. We also create a dialogService, a navigationService, and we pass those to the MainViewModel constructor. The ViewModelLocator should be exposed as a global resource in App. xaml, let's open this file. And here we see the MainViewModel that we were using until now. We can replace this with ViewModelLocator, and change the Key for clarity to name it Locator. As we mentioned, this is an additional level of flexibility in the creation and lifetime management of the services and of the ViewModels. For convenience we can add a static property in the ViewModelLocator class, which retrieves this instance from the application's resources and exposes it to other objects. Then let's take a look at the MainViewModel. The default constructors that we had created were here as a kind of a hack to allow the creation of the MainViewModel in XAML. However, now we don't need this anymore because the creation is taken care of by the ViewModelLocator, so we can simply remove this default constructor. As such, we have delegated the creation of the MainViewModel to another object, the ViewModelLocator, thus implementing a common design pattern, named Inversion of Control, or IoC. For design time, let's just add the call to the Refresh method in the unit constructors that we have now. Then, we will remove the SelectedFriend property. (Typing) While it is not wrong to have the MainViewModel hold a SelectedFriend, it is cleaner to pass this object to each page and to let the page set its own DataContext in code. This way, each page is responsible for its own state. Also, this minimizes the risks of memory leaks by letting the page handle the SelectedFriend's lifetime. So we can just remove this property here, and then in the ShowDetailsCommand, instead of saving the SelectedFriend here, we will remove this line here, and we will pass the Friend to the new NavigationService that we just added. The Friend will be passed as a state to the page that we navigated to. Let's take care of the XAML now. First, in MainPage. xaml, we need to modify the DataBindings, which we are going to the MainViewModel. Instead, we use the Main property of the Locator that we declared as a global resource. The rest remains the same. Then, in Styles. xaml, we are going to do the same to locate the ShowDetailsCommand on the MainViewModel. So here, I'm using the dot syntax in order to drill into the MainViewModel and to locate the command inside it. Of course this is in reference, here, to the Locator, which is exposed as a global resource. Finally, let's open the DetailsPage. And here I need to retrieve the state from the NavigationService and to assign this object as a DataContext of the page. So let's add an OnNavigatedTo method, which is going to take care of this. We also need to modify the SaveClick Event Handler to retrieve the MainViewModel from the ViewModelLocator, and to execute the SaveCommand. In the XAML, we will remove the DataContext from the XAML here, because it is now taken care of in the code behind. Then we need to remove the mention of SelectedFriend in every Binding, since the reference for the Binding is now the Friend itself. (Typing) Now we can run the application and see that we have the exact same functionality, but with a cleaner architecture. We can load the Friends list, navigate to a friend, edit and save changes, etc. The only small different now is the design time experience in the DetailsPage. If we go to Blend, we see that the fields are empty. This is because, as mentioned earlier, Blend does not run the code behind where the DataContext is assigned. What we can do now is specify a design time experience for the Friends class in the default constructor. So let's do this in Visual Studio. I will open the Friend class, and add a default constructor, which is going to take care of creating design time data here. Then, using the design time DataContext that we introduced in the slides, we instruct Blend to use that constructor at design time. After we build the project, we can switch back to Blend and we will see that we now have some design time data appearing in the details page. In MainPage. xaml, however, the design time experience remains exactly the same as before. With these changes, we are getting much closer to the MVVM Light application architecture, which offers a clean, decoupled structure, as well as a great design time experience.</p>
<h3>Why an Extras Assembly?</h3>
<p>As we mentioned, MVVM Light components come in two separate assemblies, named GalaSoft. MvvmLight and GalaSoft. MvvmLight. Extras. Many people have asked why there are two different assemblies. The reason is that the components in the Extras DLL require external references. The SimpleIoc container needs a reference to the Microsoft. Practices. ServiceLocation assembly. As for the EventToCommand behavior, it needs a System. Windows. Interactivity assembly. We will understand a bit later why these external references are needed. For some users, adding external references can cause problems, for reason of Licenses, or because of the Procurement process. In order to allow the maximum number of people to use MVVM Light without issues, I split the components in these two assemblies. If the external references are a problem, the user can nonetheless use a Core DLL and leave the Extras aside.</p>
<h3>Introducing Dependency Injection and Inversion of Control</h3>
<p>Now let's talk about the SimpleIoc container. Before we start, it is interesting to recapitulate two important concepts of modern programming -- What is dependency injection and what is an IoC container? Dependency Injection is a programming concept. It delegates the creation of services that an object consumes outside of this object. For example, it is quite common to do something like this. We have a DataService and we create the DataService inside the object that uses it; for instance, here in the constructor. Of course, this causes a number of questions. What happens if multiple objects use a DataService; does it need to be created multiple times? What if we want to switch to a different implementation of the IDataService interface? For example, in order to test the MainViewModel class. Who is responsible for the lifetime of the DataService, etc.? On the other hand, let's consider this code. Here, the IDataService is injected inside the MainViewModel constructor, which then Saves it. As a consequence, the MainViewModel is kept completely ignorant from the IDataService implementation. It is much easier to swap the IDataService implementation for another one, without the MainViewModel being aware of it. So Dependency Injection is a way for an object to say, I want to consume a service, but I don't want to be responsible for the creation of this service. Instead, the dependency is injected inside the consumer. Here is an example where an external class, named Startup, takes care of creating the correct implementation of IDataService based on a condition. Then, this service is injected inside the MainViewModel constructor. Now let's talk about another modern application development topic, IOC Containers. The abbreviation IOC stands for Inversion Of Control; in the sense that instead of creating the object within the consumer class, like we saw before in the MainViewModel, the creation is delegated to someone else, thus passing the control to that external instance. An IOC container is an object responsible for a few things. It will create services on demand. It is responsible for composing objects together by resolving dependencies and injecting the correct instances. It is also responsible for caching the created objects and providing an access to them. There are multiple IOC containers available to. NET developers. In fact, many of them are available as open-source projects. Here is a non-exhaustive list of a few well-known IOC containers.</p>
<h3>Registering Classes with SimpleIoc</h3>
<p>MVVM Light provides another IOC container, called SimpleIoc. You might ask yourself, with all the available IOC containers on the market, why is another one needed? Well first of all, SimpleIoc is very well suited to MVVM applications, because it has been developed specifically for them. It works also in Blend and in the Visual Studio Designer, which is great to create design time data for your ViewModels. Also, consider that many developers have never used an IOC container before, and many don't know the concept. On another hand, many developers do have a favorite IOC container, and it is almost impossible to select one which works for everybody. So instead, I decided to provide a very simple one with basic functionality, a little bit like a "gateway drug" to Inversion Of Control and Dependency Injection. Once the developers get familiar with the concept, they may be interested to check more advanced components, and of course it is possible to replay the SimpleIoc of MVVM Light with another IOC container later. Because of these considerations, SimpleIoc was born and integrated into MVVM Light. An IOC container always has two important phases, the registration and getting instances. In SimpleIoc, this is how you register a class with a container. Simply use a Register method, like here using it with a class. Another even more frequent case is registering an interface and specifying which implementation to use; like here, the IDataService interface and its DataService implementation. This allows for conditional registration; for example, here, based on the condition. One typical usage for this is a detection of design time mode, when the application runs within the Designer, such as Blend. In that case, we can register a design time DataService, and then at runtime, rather use the actual DataService implementation. Note that when the class is registered, it still does not mean that any instance is created. The creation is on demand, only when the GetInstance method is called for the first time. Also, the created objects are cached and can be accessed as many times as needed. The SimpleIoc act is a global cache for the application, which can be very convenient. However, if an object must be removed from the cache because it is not needed anymore, this must be done explicitly. Another way to register a class is to use a Factory. This is a delegate that returns an instance of the given class. Typically, factories are expressed as lambda expressions, like here. These can be useful, for example, if we want to return an instance that had been created earlier, or like here, if we need to pass parameters to the MainViewModel constructor. Here too, the execution of the factory delegate does not happen immediately when the registration occurs. It is only executed on demand when the first instance is retrieved from the SimpleIoc. The factory is executed once only, and the result is cached just like before. There are a few options that can be used when registering to SimpleIoc. First, the option to immediately create an instance as soon as the class or the interface has been registered by using a Boolean as shown here. This can be useful if you want to guarantee that the class exists as early as possible. For instance, imagine that you have a service that needs to listen to a web circuit in order to receive messages from a server and to cache them. Of course, it is good if this object can be created as soon as the application starts. Or, imagine a Settings object, which needs to load the saved settings from the file system as soon as the application starts. Note that it is also possible to force the immediate creation of the instance when a factory is used, like here or here. Another very useful option is the possibility to register a class or an interface with a Key. This allows having multiple instances of the same class or interface inside the IOC container. Of course, the corresponding instance needs to be retrieved with the same Key, so there must be some kind of contract between the class responsible for the registration and the consumers that will get the instances later. A little bit later in this module, we will see how to recreate instances using a Key.</p>
<h3>Creating and Getting Instances from SimpleIoc</h3>
<p>This is where the GetInstance method is useful. It is quite straightforward; for example, here, retrieving the Default instance of MainViewModel, or of IDataService. During registration, it was possible to pass a key to the Register method. Back then, we mentioned that it was useful in order to have more than one instance of the same class or interface inside the IOC container. Now we can also use the same key to retrieve the registered instance. Of course, it means that the same key must be used during the registration, and by the consumer. On the other hand, if the instances are registered without a key, it is possible to use a key anyway to retrieve an instance. In that case, one specific instance per UniqueKey is created and cached. This can be useful if you need a number of instances of the same type for some reason. However, be aware that all created instances are cached. If you want to remove the instance from the cache in order to free memory, you need to explicitly unregister the instance using the same key. We will talk about unregistering a little bit later. One of the advantages of using SimpleIoc to create instances is that it will also take care of creating the necessary dependencies and to compose them. For example, consider the following MainViewModel constructor. It requires two services, one instance of IDataService and one instance of INavigationService. In MVVM Light, typically the registration to SimpleIoc takes place in an object, called ViewModelLocator, that we discovered earlier in this module. Inside the constructor, we can register the services, like shown here. Then, we take care of registering the MainViewModel itself. Later, when the GetInstance method is called for the MainViewModel, the SimpleIoc will check if it already has an instance of this class in the cache. If not, it will create one, but of course in order to create the MainViewModel, SimpleIoc needs an instance of IDataService. Again, same story; it checks if it has an instance of IDataService registered, if not, it will create one. Then, the same scenario happens again with the INavigationService. And finally, when all the parameters are ready, the MainViewModel can be created, cached, and returned. Let's take a moment to talk about two ways to do Dependency Injection in a class. Of course, we already mentioned the injection in the constructor, which we use in various examples. This is convenient when the service is created in the IOC container and never changes. When the MainViewModel is created here, the instance is retrieved and stored as a private attribute for convenience. There is, however, another way to inject a dependency in a class, through a property. Here, every time that the property is accessed, it is retrieved from the IOC container. This way of doing is useful if the instance of IDialogService may change during the application lifetime. In this case, it is not safe to inject the instance in the constructor and to save it as an attribute.</p>
<h3>Unregistering Classes from SimpleIoc</h3>
<p>Of course, since we can register to the SimpleIoc component, there is also a way to unregister. This is pretty straightforward using the Unregister method. A few things to take in consideration, though. When you unregister a class or an interface, you also remove all the instances from the cache automatically. If that was not the desired effect, you must take care of retrieving the instance before you go Unregister and to save it separately. Unregister can take a parameter, or not. If we call the method without any parameter, like here, the class or interface is completely removed from SimpleIoc. Any subsequent call to GetInstance will cause an exception to occur. It is, however, possible to pass a parameter to the Unregister method. So parameter can be an instance itself. In that case, the instance passed as parameter, like here the (this) keyword, is removed from the cache. However, the IDialogService interface itself is not removed completely from the IOC container. Calling GetInstance again, at this point, will force the creation of a new instance, which will then be cached again. Similarly, the key can also be passed to the Unregister method to identify an instance with the same result. Note that even if you try to Unregister a class, an interface, a key or an instance that do not exist in SimpleIoc, there are no side effects. So really, it is a good clean policy to think about unregistering your objects, once you don't need them anymore, in order to optimize memory usage.</p>
<h3>A Typical Scenario with SimpleIoc</h3>
<p>In Navigation Applications, like in Windows Phone and Windows 8, a typical scenario involves navigating away from the current page and to a new page. In that case, it can be interesting to add and remove services from the IOC container. For example, a custom dialog may be displayed to the user, using an IDialogService interface, which is implemented by each page. So each page, when it is displayed, becomes a current IDialogService, and the page that was previously displayed needs to unregister. This is how we do it. In the OnNavigatedTo method, we add the page itself in the IOC container as the IDialogService. Notice how we use a factory to do this and how the factory returns a this keyword, the current page itself. For the consumer, which is typically a ViewModel, this is a good way to access functionalities of the View in an abstracted manner. The functionality is exposed in the IDialogService interface. At no time does the ViewModel know that it is, in fact, using the page itself; this is a clean, decoupled implementation. When we navigate away from the page, we Unregister the page, like this. Because we passed the (this) keyword as parameter, the instance only is removed from the IOC container.</p>
<h3>SimpleIoc's Utility Methods and Properties</h3>
<p>In addition to the Call methods, SimpleIoc proposes a set of Utility Methods. For example, sometimes it is useful to know which classes or interfaces have been registered to SimpleIoc. Also, we might be interested to know if a given class or interface has been not only registered, but also created and cached. This is what the IsRegistered and the ContainsCreated methods do. Consider this code; if we register an interface, in this case IDataService, the call to IsRegistered will return true, as expected. However, a call to ContainsCreated will return false, because even though IDataService has been registered, the cache does not contain any instance yet. If, after that, a call to GetInstance is made, the SimpleIoc will create an instance of DataService and cache it. This is why the next call to ContainsCreated returns, this time, true. Another useful method is GetAllCreatedInstances. Because the cache can contain multiple instances of the same class by using key, this method allows retrieving them all. Note, however, that this method only retrieves instances that have already been created at the time where it is called. If a class is registered, but GetInstance has never been called yet, the GetAllCreatedInstances method will return an empty list. Let's illustrate this with some code. Right after registration, GetAllCreatedInstances returns an empty list. If later we call GetInstance twice with different keys, two instances are created and cached. The next call to GetAllCreatedInstances will, this time, return them both. On the other hand, the GetAllInstances method acts differently, so do not get confused. Calling GetAllInstances does force the creation of instance per class, if that was not already the case. This is what we call the default instance of each registered class. For example, here, we register the IDataService interface. Even though GetInstance has never been called, the next call to GetAllInstances returns one instance. The creation of this Default instance of IDataService has been triggered by the call to GetAllInstances.</p>
<h3>The ServiceLocation Assembly and SimpleIoc</h3>
<p>In the beginning of this module, I mentioned that an additional reference is needed by SimpleIoc. The Microsoft. Practices. ServiceLocation DLL. This assembly contains a ServiceLocator class, as well as a few helper classes, which are quite useful to standardize the usage of IOC containers. Indeed, there are quite a few IOC containers available on the market. Choosing which one to use depends on many factors. During the course of the lifetime of an application, it is not unconceivable that the Development Team decides to swap their IOC container with another one. This is especially plausible in the case of SimpleIoc, which is very easy to use, but has limited functionality compared to more powerful offerings. In order to facilitate the swapping, the makers of the most popular IOC containers agreed on an abstraction model. First, the user can define which IOC container instance should be used everywhere. In the case of SimpleIoc, the Default instance is named SimpleIoc. Default. You should register this instance with a ServiceLocator class, as shown here. Following this initialization, it is possible to interchange SimpleIoc. Default and ServiceLocator. Current. For example, the GetInstance method can be called here, on ServiceLocator. Current. This is exactly the same as calling SimpleIoc. Default. GetInstance. Of course, the advantage is that ServiceLocator is a standard, and so, if at a later point the Development Team decides to use another IOC container using the same standard, all the ServiceLocator methods can be left unchanged in the code, which reduces greatly the number of lines of code to modify.</p>
<h3>SimpleIoc Demos</h3>
<p>The WhyMvvm application that we built in the previous modules of this course runs fine without an IOC container, but adding SimpleIoc to it brings some advantages. Most importantly, it will make it easier to extend the application with new features when the time comes. In a typical MVVM Light application, the IOC setup is done in the ViewModelLocator. Of course, this is not compulsory and objects can be registered in other parts of the application too. It is a good practice to keep the registration instructions somewhat centralized in order to make it easier to make changes to the IOC container when needed. Here we are in the ViewModelLocator class in the ViewModel folder. We will initialize a SimpleIoc in the static constructor of the ViewModelLocator. First, we will let the IOC container create the friendsService on demand. So we can replace the creation of the service here and here with a registration instead. Let's start with a DesignFriendsService and the runtime service. Now of course I can remove the creation of the service here, here, and here. Then, there is a registration for the DialogService and the NavigationService. Here, we don't use a conditional registration, but if needed, it would be easy to change. Let's add the registration here. Finally, the MainViewModel, which uses all these services, can also be registered. In order to trigger the creation of the MainViewModel and all the associated services, the GetInstance method needs to be called at some point, but we also need the Main property, which is located here, because this is what is used by the DataBinding in XAML. So let's replay the Main property by a property with only a getter, and call GetInstance from here. To illustrate how easy it is to get the MainViewModel instance or any other cached instance from anywhere in the application, let's move to the DetailsPage. Here, we are getting the MainViewModel instance from the ViewModelLocator through a static property, which is not very elegant. We can replace this by a more decoupled approach using the IOC container. Effectively, the instance of the MainViewModel is the same, but we are not using the ViewModelLocator anymore, which is cleaner. This was just a small example of how to use SimpleIoc, and there are many other scenarios where this class is very useful. Because it is Blendable, that is to say that it works just fine in Blend and in the Visual Studio Designer, it facilitates a creation of design time code or can be used in a similar manner to execute unit tests without having to modify the ViewModel classes. It is a very handy component of the MVVM Light Toolkit.</p>
<h3>Introduction to Behaviors</h3>
<p>Now let's discuss the last component of MVVM Light Version 4, the EventToCommand. This is a so-called behavior, or like we sometimes hear, Blend Behavior. First, let's understand what Behaviors are. Initially, behaviors are a modified version of a pattern that the WPF community came up with, called Attached Behaviors, and based on attached properties that are available in all XAML-based frameworks. For more information about Attached Behaviors, see the link here. I won't go deeper in the details of Attached Behaviors, because this is off topic for this course, but it is enough to say that these are very powerful and useful in certain situations. The behaviors we are using here are sometimes called Blend Behaviors, because they were developed initially by the Blend Team. Mostly, they are a response to the problem that the original Attached Behaviors were not easy to use in a tool such as Blend and had to be added in XAML manually. On the other hand, the so-called Blend Behaviors were great in Blend, as you would expect. However, they are not directly related to Blend, and you can use them, even if you never stop blending your life, which of course would be a pity. Behaviors are small pieces of code behind that are encapsulated and very easy to redistribute, for example, as part of a DLL. When Visual Studio gets installed, you also get all the necessary pieces to use a set of behaviors as part of the SDK, especially now that Blend gets installed for free. With Visual Studio 2012 and 2013, you have all you need to use behaviors and clean your code behind. Behaviors attach to a UI element. As mentioned, you don't need Blend to work with Behaviors, but if you do use Blend, it makes it much easier to find behaviors, place them in your XAML, and configure them. Here we see the Blend Assets Library and we see, for example, the MouseDragElementBehavior that we will drag and drop on the rectangle and then configure. Let's see a quick demo. This is a Windows Presentation Foundation Application created in Blend. Now I will add a rectangle to this window, let's make it blue, and in many applications we need to implement dragging of an element. This is quite repetitive and honestly quite annoying, because we need to handle multiple mouse events and do some calculations to see by how much the mouse moved. The first time we implement this, it is interesting, but after the second time we already wish we had something better. Thankfully someone encapsulated this code in a behavior named MouseDragElement. Once we find this element in the Assets Library, we can drag it on the rectangle and drop it. Then we can run the application, and immediately the rectangle can be dragged around the window. This particular behavior has one property, so if I select it in the object and timeline, I see the property here called ConstrainToParentBounds. If I check this property and run the application again, we will see that the rectangle is not constrained to the Window's boundaries. So in Blend, it is really easy to just drag and drop the behavior on the element and then to configure it. Here is how the code looks like in XAML. Notice how the behavior is neatly attached to the rectangle using the Interaction. Behaviors construct. Also, note the usage of two namespaces here; the interactivity namespace, which is where the base classes for all the behaviors are found, and also the interactions namespace, which contains a MouseDragElementBehavior itself that we just used.</p>
<h3>Introduction to EventToCommand</h3>
<p>In addition to Behaviors, there is another group of elements we can use in a similar manner, named Actions. There are differences between Behaviors and Actions. Behaviors are standalone and self-sufficient. On the other hand, Actions are always attached to a trigger to be useful. In hardware terms, you can think of the action as an actuator, an element that will perform an operation. On the other hand, the trigger is a kind of a sensor. One trigger can have one or multiple actions. When the trigger fires, it will execute all the actions that are attached to it. There are multiple kinds of triggers; for example, the most common one is the Event Trigger, which triggers when an event is fired on the attached element. For example, you could use a SelectionChanged event of a ListBox to execute a series of actions. Or, another trigger is a Data Trigger, which is great in case of MVVM. The trigger will fire when a certain property reaches a certain value, which is set in the Trigger's properties. Of course, you can also develop your own behaviors, triggers, and actions. I highly recommend any client developer to take a good look at behaviors. In MVVM Light, there is one action which is very useful in relationship with RelayCommands; the EventToCommand. In fact, EventToCommand is not a very good name, and in retrospect, I wish I would have chosen a better one. It is really an action, meaning that it can be attached to *any* trigger, not just Event triggers. The intent of EventToCommand is rather simple; every time that it is triggered, it will execute a Command. Because a Command property is a dependency property, it can be set by DataBinding, which allows a nice decoupling of the View and the ViewModel. In addition to the Command property, there is, of course, a CommandParameter property, which can also be data bound. If it is set, this parameter will be passed to the command. Remember from our study of ICommand and RelayCommand in an earlier module that the ICommand's methods have a parameter, which can easily be set or left null. So which are the scenarios in which you may want to use EventToCommand? Well one frequent scenario is whenever you want to execute the command from an element which doesn't support them. In fact, in. NET, only the ButtonBase class supports a Command property. It means that the UI elements, which derive from ButtonBase, will support Command, such as Button, ToggleButton, RadioButton, Checkbox, etc. Any other element does not support Command out-of-the-box, and this is where EventToCommand can be useful. That said, even for this control that supports Commands, the Command will only be executed when the control is clicked. For any other event, such as MouseOver, there is no built-in way to execute a command. Here, too, the EventToCommand component can be used. Of course, because EventToCommand is an action, it can be triggered by any type of trigger, such as a Data Trigger. We will illustrate this with a demo a little bit later. The last scenario is when an event handler simply cannot be used. There are such cases, for example when the XAML control is placed in a file, which does not have code behind. This is a case for resource dictionaries. If you have a Data Template which is neatly placed in a Resource Dictionary, either in order to be reusable or to keep the XAML code clean, there is no way to execute an event handler from this Data Template. In this case, too, EventToCommand can be used.</p>
<h3>EventToCommand Demo 1: Handling MouseEnter Event</h3>
<p>Let's illustrate this with a few short demos. This is a WPF application, but the exact same demos can be done in any of the other XAML framework. Here we have a Button with the Command property data bound to a RelayCommand on the ViewModel. If I run the application and click on the Button, the command fires, no problem here; but if I want to handle the MouseEnter event, this won't work. So here I can add an EventToCommand. Let's do that in Blend. Because this application had MVVM Light installed, I can see the EventToCommand behavior in the Assets Library under Behaviors, here it is. Let's drag and drop it on the Button here. Then, in the Properties panel, we can customize it. First, we can choose a type of the trigger, which by default is set to EventTrigger; this is what we want. Then, we choose which event will trigger the action. Let's find the MouseEnter event, here it is. And finally, we need to set the Command which will be fired. Here I can use a Data Binding Editor, let's create a Data Binding. And because MVVM Light is set up properly, I can see that the DataContext is a MainViewModel and I can select the correct property, this SayHelloCommand. Let's click OK. Now if I run the application again, and I pass the mouse on the button without clicking, we see that the Command fires as soon as the mouse cursor enters the Button.</p>
<h3>EventToCommand Demo 2: Moving a Template to a ResourceDictionary</h3>
<p>Now let's show something different. This is a ListBox in a Silverlight application. Here, too, what I show is applicable also in WPF. In Windows 8, we would use a ListView or a GreetView, and in Windows Phone, a LongListSelector, but the principle is exactly the same. It has some design time data defined in a DataTemplate. If we switch to Visual Studio and in the XAML, we can see that the DataTemplate is defined directly in the UserControl. Resources. So I can add a MouseLeftButtonDown event to the Grid, and I can implement the Event Handler directly in the code behind. (Typing) If I run the application now and click one of the items, we see that the event handler fires and everything works well. However, I may want to clean up this XAML and move the DataTemplate inside a ResourceDictionary. So now I'm going to cut this out, and I'm going to go into the MainSkin. xaml ResourceDictionary, which is already merged into the UserControl. Resources. Let's do that. Here is MainSkin, and I'm going to paste the code that I copied just before. If I try to run the application now, I'm going to get an error, because the MouseLeftButtonDown event handler is not found. And, of course, there is absolutely no way to add this event handler inside the ResourceDictionary, because there is no code behind. Let's modify this example to use EventToCommand to select a Command defined on the item represented by this DataTemplate. So first I'm removing the event handler, and then let's show the Command itself, which is defined here inside the DataItemViewModel. So here we see the ShowItemCommand, which is going to show a MessageBox using the Model. Title. Here is how you would do this in Blend. First I'm going to edit the DataTemplate of the ListBox. (Typing) And then I'm going to take an EventToCommand in the Assets Library and drag it on the Grid. Then I'm going to go to the Properties panel and I'm going to configure the Command property using the Data Binding Editor, and here Blend knows that the DataContext of this DataTemplate is the DataItemViewModel, on which the ShowItemCommand is defined. Now if I run the application again, we can see that we can click on the item and then the Command is executed, which is just fine. If we want to move the Command to the MainViewModel, this is possible too. Here we are inside the MainViewModel class and we have such a Command here. This Command receives an item, this is a DataItemViewModel, and then it will create a message and use a MessageBox to show this message. Notice how we use item. Model. Title. In Blend, it is very easy to retarget the Command. Let's go and Edit the ItemTemplate. Then I will select the EventToCommand and open the Data Binding Editor. Because of the way that the MVVM Light Application is structured, I can see the ViewModelLocator as a data source, I can select it and see the MainViewModel property, and here, the ShowItemCommand. Notice that this Command expects a DataItemViewModel as parameter. So let's select it here. And after I press OK, I need to set up the CommandParameter property. I need to pass a reference to the DataItemViewModel itself. This is a little unusual, because the DataItemViewModel is the DataContext of the DataTemplate. Let's open the Data Binding Editor, and now we see that the DataContext of this Binding is a DataItemViewModel, which is just what I want. So I don't select any property, but instead I just press OK. Now I can run the application again. And this time if I select, we see that we are in the MainViewModel, and this is item #1, and here is item #2. Here is a syntax in XAML. Here we see the Interaction. Triggers, this is an attached property, just like before we had Interactions. Behaviors. Then we have the EventTrigger, which is configured to use a MouseLeftButtonDown event. Here is the EventToCommand itself, which is using the Command property data bound through the StaticResource Locator, to the Main. ShowItemCommand. And finally, we have the CommandParameter, which is a Binding to the DataContext itself, represented by this DataTemplate.</p>
<h3>EventToCommand Demo 3: DataTrigger and EventToCommand</h3>
<p>For the next sample, we will use a DataTrigger inside of an EventTrigger in the Windows Phone Application. In standard MVVM scenarios, it is actually quite rare to use DataTrigger, because most data operations can be done directly in the ViewModel. But here, I will show an example where we use two ViewModels located in a satellite assembly. We will pretend that both ViewModels cannot communicate with each other, and so we will use an EventToCommand coupled with a DataTrigger to do that. Here is the application in question. The MainViewModel and the SettingsViewModel are located in a referenced assembly here. The MainViewModel has one Command, called ValidateCommand. This command will simply set a text into the string property named Result. As for the SettingsViewModel, we have the Value property, which is an integer, and then we have the IncDecCommand, which we use to increment or decrement the Value. Both these ViewModels are exposing the ViewModelLocator as properties for easy access. Now let's open the MainPage in Blend. Here we see the Decrement and Increment buttons, which are using the corresponding command in the SettingsViewModel. The Value is shown below the buttons. The textbox below, which shows ‘Waiting…' for the moment, is bound to the Result property on the MainViewModel. So really this view is a composite of two ViewModels, which is a little bit unusual, but which happens sometimes when you build larger applications. The scenario we want to fulfill is to listen to the Value property, and when it reaches a Value of 0, we want to trigger the ValidateCommand on the MainViewModel. There are, of course, multiple ways to solve that, and here for the illustration, I will solve this using a DataTrigger. Let's add an EventToCommand to the page from the Assets Library. As we saw before, the default TriggerType is an EventTrigger, but here we want to use a DataTrigger, so I will click on the New button. In the dialog, I will select a DataTrigger from the Microsoft. Expression. Interactions DLL, which is a library from the SDK. There are multiple other triggers, such as KeyTrigger for the keyboard, a TimerTrigger, etc. Here I select the DataTrigger and then I click OK. The DataTrigger requires a Binding, which we will set thanks to the Binding Editor. Let's navigate through the ViewModelLocator, as a data source, to the SettingsViewModel. And here we select the Value property, and I can click OK. You can verify that the Value is correct thanks to the Value -5 shown here. Then we will set the Trigger Value to 0. So when the Value property reaches 0, the trigger will fire. Know that you can use some Comparison operators, such as Equal, NotEqual, GreaterThan, LessThan, etc. Finally, let's configure the Command. And here we will make a Binding to the MainViewModel's ValidateCommand property. This way, we have established the connection between the SettingsViewModel and the MainViewModel without touching these two components, only through Data Binding. Now we can test the application. If I click on the Increment button, when it reaches 0, we see that the Command was executed, and the Result property is set, as expected.</p>
<h3>EventToCommand Demo 4: EventArgsConverter</h3>
<p>In this example, we will handle the MouseClick on the blue rectangle. We want the ViewModel to know where the MouseClick occurred, relatively to the top-left corner of TheRectangle itself. The MouseButtonEventArgs has a method called GetPosition, which allows us to do this calculation. If we set PassEventArgsToCommand to true, the MouseButtonEventArgs will be passed down to the Command as its parameter, but this is not a clean interaction, because ideally the ViewModel should not know about the objects at all. So let's see how we can set an EventArgsConverter up. Here is the EventArgsConverter, this is called MouseButtonEventArgsToPointConverter, and implements the IEventArgsConverter interface from MVVM Light. This interface requires only one method, called Convert. It has two arguments, the value and the parameter. Let's first set up the XAML markup. Here we have the EventToCommand code. We set the EventArgsConverter property to a StaticResource, which is defined in the page's resources. This is an instance of the MouseButtonEventArgsToPointConverter class that we just saw. As EventArgsConverterParameter, we set the Binding to the ElementName, TheRectangle, itself. Here we can see the Name of TheRectangle element. This is the actual element on which the EventToCommand is applied. And here in the page resources, we have the MouseButtonEventArgsToPointConverter, which is defined. Of course, as usual, this converter could also be defined in the application resources. Inside the converter, the MouseButtonEventArgs is received as a value and TheRectangle is a parameter. So we can cast these two elements and do the calculation here. The returned value, in this case a point, will be passed to the Command as a CommandParameter. Finally, here is a RelayCommand code inside the MainViewModel. Notice how the point, which is a result of the calculation of the EventArgsConverter, is received and how we can use it to format a message and then show this message in the MessageBox. Of course in a real-life application, we would probably use this point to do additional calculations. If we run the application now, we can click on TheRectangle and see the position relatively to the top-left corner of TheRectangle. Here I am very close from this corner, as you can see. We can also easily change the parameter to reference a page itself. Here, the page has a Name set to PageRoot. So if I go into the Parameter value here, I can change TheRectangle with PageRoot, and then if I run the application again, we will see that the position is now displayed in reference to the page's top-left corner; for example, here, the top-left point of TheRectangle itself. This example is quite clean, because the ViewModel only knows the point class, which is not directly related to the View. It is a level of abstraction, which is comfortable. We could, of course, imagine other examples; for example, with Drag & Drop. The EventArgsConverter is an advanced tool, but it is very convenient when you want to perform specific calculations inside the ViewModel.</p>
<h3>EventToCommand vs. InvokeCommandAction</h3>
<p>If you've used the Blend SDK before, you may have noticed an action named InvokeCommandAction. This action fulfills the same purpose in EventToCommand and can be used instead of EventToCommand in many scenarios; however, it does not have a way to pass the EventArgs to the Command or to convert them. This is why EventToCommand is still the recommended way to trigger commands in advanced scenarios. In Windows 8. 1, however, the Blend Team took our feedback and added a way to convert EventArgs and pass them to the Command. This is what the InputConverter and InputConverterParameter are for. Note that the InputConverter is an IValueConverter, so it is a slightly different implementation than in MVVM Light. Because the InvokeCommandAction is fulfilling the same features as EventToCommand in Windows 8. 1, there are currently no plans to port EventToCommand to this version of the XAML framework. In Windows 8. 0, there are no Blend behaviors at all; however, at this URL, you will find a workaround, which allows you to use something similar to EventToCommand, even if you cannot upgrade to Windows 8. 1 for some reason. For reference, here is a XAML syntax in Windows 8. 1 for InvokeCommandAction with a Command Binding, the InputConverter, and a Parameter. And again, in other XAML frameworks, InvokeCommandAction does not support the InputConverter, in which case you may want to use EventToCommand instead.</p>
<h3>Summary</h3>
<p>In this module, we talked about the architecture of an MVVM Light application and about the extra components of MVVM Light. We started this module with a discussion about DataContext and how it can be data bound to the View. We introduced the ViewModelLocator, an object which is not part of the MVVM Light assemblies, but rather introduced in typical MVVM Light applications as a place to set the application services up, to set up the IOC container, and to provide some binding points for the View in a way that is optimized for the Visual Designers. Then, we talked about the reasons for having a separate assembly for the SimpleIoc and the EventToCommand. We understood that it is because of the search party reference assemblies that these components use, and one thing to make it easier for everyone to use the core components. Then we had a long, in-depth study of SimpleIoc; an IOC container that is easy to use, but powerful enough to cover many of the needs for a client application. SimpleIoc is well suited for MVVM applications, and it works beautifully in DesignMode with Blend, so it is a good component to know when working closely with designers, which is a trademark of the MVVM Light Toolkit. The last component of MVVM Light that we studied is EventToCommand, an action that works coupled with a trigger, such as an EventTrigger or a DataTrigger. First, we understood what Blend behaviors are and how they can be added to an element and configured. Then we saw specifically how EventToCommand can be used to handle any event of any UI element and invoke a command when the event fires. We also saw how EventToCommand can be used with a DataTrigger instead. And finally, we discussed the EventArgsConverter, which is useful to cleanly handle event arguments in the Command directly at the ViewModel level. The next module will show how MVVM Light is installed on a machine, either as a standalone complete installation or with NuGet. Then we will review the Project Templates, Item Templates, and the Code Snippets; some important components that can get you started faster.</p>

            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>

</html>