<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

<head>
  <meta charset="UTF-8">
  <title>MVVM Light Toolkit Fundamentals</title>
  <script src="https://unpkg.com/vue"></script>
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
    integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
  </style>
</head>

<body>
  <div class="container" id="app">
    <div class="panel-group">
      <div class="panel panel-primary">
        <div class="panel-heading">
          <h2>MVVM Light Toolkit Fundamentals</h2>
        </div>
        <div class="panel-body">
          <div>
            <h2>Installing the MVVM Light Toolkit and Additional Components</h2>
            <div>
<h3>Introduction</h3>
<p>Welcome to Module 5 of the MVVM Light Toolkit reference course. In previous modules, we saw what the advantages are of an MVVM architecture over an event-based architecture for XAML-based applications. We understood what steps were needed to refactor an event-based app to an MVVM app. And we saw that some repetitive operations could benefit from some automation. This is when we introduce the MVVM Light Toolkit's components, starting with the Code DLL and then following up with the Extras DLL. This rounded up the presentation of the first-half of the toolkit's elements. In this module, we will introduce additional elements, such as project templates and code snippets. These additional tools are the reason why we don't talk of MVVM Light as a framework. In fact, it is a suite of tools, as well as a guidance to build applications, which is why the name toolkit is more appropriate. First, we will see how you can install MVVM Light in your application using NuGet, or, on your PC using an installer. We will understand the differences between these two approaches. Then, after the whole toolkit is installed, we will learn more about the additional components, starting with the code snippets. We will understand how they can help you to be more productive in Visual Studio, especially when writing repetitive code. Then, we will review a typical application created with an MVVM Light project template and see how it is structured and what are the advantages over a classic app. We will also talk about the item templates used to create new Views, new ViewModels, or a new ViewModelLocator.</p>
<h3>Using the Assemblies From Nuget</h3>
<p>First, let's talk about NuGet, the package manager that has become very popular in recent years to manage the dependencies of an application, notably of. NET applications. NuGet makes it convenient for application developers to find the most recent version of a library, and to make sure that all the dependencies are loaded correctly. Instead of adding references to a single assembly, the developer manages references to packages of assemblies, which in turn can reference other packages. When the package is referenced in the project, the NuGet system will load the newest version of all necessary dependencies. In addition, if later a newer version is found of the package itself or of a dependency, it is easy to get notified and to load the newer version if desired. NuGet is available as a command line tool, which makes it easy to integrate it with automated tools. It is also available as a more human-friendly Visual Studio extension, which is what we will use in this module. There are quite a few advantages in using NuGet to manage your project dependencies. First, a package can contain more than just binaries. When a package is installed, it is possible that it also adds files to the project. It is even possible to run a PowerShell script to modify the target project. In the case of MVVM Light, the user can optionally take advantage of this to create an almost fully-functional MVVM Light application just by referencing the NuGet package that we will see later in this module. Before NuGet,. NET developers often had to manage the dependencies either by referencing a series of single DLLs, which had to be committed to source control, or by installing an SDK on each developer machine. If the SDK was missing on the new machine, it was not possible to build the application after pulling it from source control. With NuGet, however, the whole packages are saved and can be committed to source control, too. This way, when the project is pulled on a new machine, it is immediately ready to be built. As we mentioned, NuGet makes it easy to handle updates to a package or to its references. Also, NuGet servers can be handled by a firm, a group of developers, etc. This makes it possible to deploy packages that are not for the whole world to see, but only to a restricted group of developers. In this module, we will use Microsoft's nuget. org server to load MVVM Light. There is one main disadvantage to NuGet, however. If the PC is not online when the package is added to the project, it cannot find the NuGet server and the process fails. Note that the PC must only be online at the moment of the addition of the NuGet package. Once the package has been added, the development can continue offline without problems. In the case of MVVM Light, we will see that an offline mechanism is also available to create new applications, even when the target PC is not online. On Visual Studio 2012 and 2013, NuGet is already available by default. In Visual Studio 2010, however, you need to install it manually. It is quite simple by using the integrated Extension Manager. Here is Visual Studio 2010. Now I can open the Extension Manager from the Tools menu, and here we see that NuGet is already installed. If that is not the case, I can search in the Online Gallery and install NuGet from there.</p>
<h3>A Quick Nuget Demo</h3>
<p>Let's see a quick demo about NuGet. Here we have a WPF application without any additional components. This application needs to load and parse a JSON file from a web server when the Main button is clicked. Here is a code, which is using the WebClient to connect to the web server and load the JSON file as text. And here is a small C# class, which will be used to contain the data parsed from the JSON file. Instead of writing the passing code ourselves, it is easier to use an existing package; for example, the popular Json. NET. This great library is available on NuGet, so let's look for it. Here I will right-click on the References folder and select ‘Manage NuGet Packages'. Then, I make sure that the nuget. org option is selected on the left, and I search for JSON. I make sure to select the correct package and then I select Install. What just happened now is that Json. NET was downloaded from the NuGet servers and the assemblies were referenced in our application. Then we can close this dialog, and go back to the code. The last thing I need to do, is go back to my MainWindow. xaml and add the line which is going to deserialize the JSON text into an instance of MyClass. Let's inspect this line, and here we see the usage of the JsonConvert class, which comes from Json. NET. If I run the code now and click on the button, we see that the deserialization takes place and the properties were passed properly. (Typing)</p>
<h3>Libraries Only vs. Full</h3>
<p>When you search for MVVM Light in NuGet, you will see that there are three versions of MVVM Light there. Let's understand the differences. One of the packages is named libraries only. This is a package most suited for people who have a certain experience with MVVM Light already. It adds only the necessary DLLs, so that all the components we saw in previous modules can be used. But it doesn't modify the target project at all. Similarly, if you add MVVM Light to a class library in order to use its objects, you must select the libraries only. The library is loaded with Core and Extras elements of MVVM Light, as well as the System. Windows. Interactivity DLL required by EventToCommand. On platforms where it is available, it also adds a dependency to another NuGet package, named CommonServiceLocator. In addition to the libraries, the full version of MVVM Light available on NuGet also installs a ViewModelLocator and a MainViewModel. This version of the package is most suited for new applications that have just been created. It uses an Install script to add additional plumbing in App. xaml, so that the ViewModelLocator is loaded as a global resource, as we saw in the previous module. Note that in this version of the package, the libraries are added as a dependency through the "libraries only" NuGet Package. It makes it easier to handle the DLL. Notably, the application has a main application and some satellite assemblies, which also need MVVM Light. In that case, the DLLs are loaded only once from NuGet. Finally, there is also a portable class library version of MVVM Light, which is handled as a separate package.</p>
<h3>Adding MVVM Light to an App With Nuget (Demo)</h3>
<p>For the demo, I created an empty WPF application here. Then, I will add the MVVM Light Libraries using NuGet. We do the same things as we did before with Json. NET. First, we right-click on the References folder and select ‘Manage NuGet Packages'. Once a dialog is loaded, we search online for MVVM Light. Here, I will add the libraries only package. Notice that you can see all the details on the right, including the description, the tags, dependencies, and the link to the license. Let's click on Install. After a short while, the MVVM Light libraries are installed. If I close the dialog and expand the References folder, I can see the DLLs here and here. From this moment on, I can use all the objects that we studied in the previous modules. For example, this is the MainPage. And here I can use the Messenger to send an initialization message when the MainPage has been loaded. (Typing) Now let's see what happens when we pull the Full MVVM Light through NuGet. First, I created a new empty Windows Phone application. I will, again, use NuGet, but this time I will select the Full MVVM Light package. Let's search here for mvvmlight. And this time I click Install on the first package here. (Typing) And once installation is complete, we notice what we mentioned before; the Full MVVM Light package also uses the libraries only. Now I can close this dialog. I see a new folder, named ViewModel. Inside it, we find the ViewModelLocator and the MainViewModel. Also, if I switch to App. xaml, I see that the ViewModelLocator has been added to the application's global resources, like we explained in the previous module. So now we can do the following. First, I'm going to open the MainViewModel and I'm going to add a property named Message. This is a simple string property. Now let's build the application. Then I can open the application's MainPage in Blend. If we switch to the Data pane and check the DataContext of the page, we see that it is not set. The NuGet version of MVVM Light does not set the MainPage's DataContext, because it would be too dangerous to tinker with an existing application's DataContext. But in Blend it is very easy to correct. Notice that on the Project, we can see the ViewModelLocator in the Resources. This is the content of the App. xaml's resources. The ViewModelLocator is visible to Blend, because the NuGet Install script took care of setting the IsDataSource attribute to true. So now it is possible to expand the ViewModelLocator and to drag the Main property, which is the MainViewModel, on the application page. Blend proposes to set the page's DataContext to the MainViewModel, which is what we want. And now the DataContext has been set. Note that in WPF the experience is just a little bit different, but the same steps can be followed and the end result is the same. Now that the DataContext has been set, we can expand the MainViewModel here and drag the Message property on the MainPage, which is going to create a TextBlock with the appropriate DataBinding.</p>
<h3>Installing the Whole Package in Visual Studio</h3>
<p>NuGet is great when you want to make sure that you have the latest version of the package, but it also has limitations. As we mentioned earlier, it only works when you are online. If not, the Package Explorer cannot connect to the server. Of course nowadays it is mostly not a problem, but I sometimes encounter situations, for example on a plane, where I cannot use NuGet. The other problem is that NuGet cannot install templates or snippets, at least not without some kind of workaround. These additional tools are very convenient. The project and item templates are creating projects, respectively items, which are already formatted to follow the MVVM Light recommendations. We will check these items more in details later. As for the code snippets, they are shortcuts adding code at the cursor location and allow easy replacement of certain tokens. For example, you can use the MVVM Light code snippets to add a RelayCommand or an observable property to your code easily, as we will see in just a moment. Note that because the installation process changes in the latest versions of MVVM Light, you should uninstall previous versions before you proceed with the installation of the most recent. To do this, please follow the steps on the page listed here. To add the full MVVM Light installation to your development environment, we are going to use another installation medium, also directly from within Visual Studio, the Extensions Dialog. Here we have a fresh new installation of Visual Studio without MVVM Light installed. We can see that, because if I select File, New, Project, we don't see the MVVM Light Project Templates here on the Visual C#. So now let's open the Extensions and Updates dialog from the Tools menu here. I'm going to select Online and then I'm going to type mvvmlight here. (Typing) Immediately we see the latest version of MVVM Light available, and we can install it by selecting Download. Here we need to Accept the license. And after the installation is complete, we need to restart Visual Studio, which can be done very easily. Now if I reopen the File, New, Project dialog, I can see the MvvmLight Project Templates. For example, on the Windows Store, Windows, Silverlight, Windows Phone, etc. Also, the code snippets have been installed. So, for example, if I create a new MvvmLight application for Silverlight 5 here, I can open the MainPage. xaml, here is a code behind, and then I can type anywhere in the code, mvvm, and here we see the code snippets installed. We will talk much more about the code snippets in a moment, so don't worry if you don't see them yet after you install MVVM Light on your machine. So to recapitulate, in order to install the full-blown MVVM Light installation, first uninstall previous version. Then, from within Visual Studio, you can select Tools, Extensions and Updates, Online, and then Search for "mvvmlight". Or if you prefer, you can also navigate to mvvmlight. codeplex. com, and then download the Installer package from the Downloads page. However, make sure that you select the correct version of the VSIX Installer package; for example, there is a different one for Visual Studio 2012 and for Visual Studio 2013. If you are using Visual Studio Express, you cannot use a Visual Studio Gallery to install MVVM Light, unfortunately. There are a few technical restrictions in place. So here, what you want to do, after you install Visual Studio Express, is to navigate to mvvmlight. codeplex. com, and install the VSIX Installer from the Downloads page. Here, too, make sure to select the right version.</p>
<h3>Introducing the Code Snippets</h3>
<p>All MVVM Light code snippets start with the letters "mvvm". So like we saw earlier, if you place your cursor in the code and type "mvvm", you should see the list of all snippets shown in IntelliSense. Then you can expand the snippet by using the "Tab" key. Once a snippet is expanded, you can navigate from token to token in order to replace them by using the "Tab" key again. MVVM Light snippets are grouped by functions. For example, we have mvvminpc, which are all snippets used to add an "observable property". inpc is the abbreviation for INotifyPropertyChanged. Or, mvvmrelay are for RelayCommands, etc. Then, you can select the snippet that is adapted to your needs. For example, the mvvmrelaygeneric adds a RelayCommand with a generic parameter. In the demo later, we will review these snippets. Here we see the IntelliSense window with all the MVVM Light snippets. Note that each snippet is documented, so if you select it without pressing Enter, you will see what this particular snippet does. One small known issue, if you are using ReSharper, this tool has its own snippets, which are not compatible with the standard IntelliSense ones. This causes the MVVM Light code snippets to be invisible, just like any other Visual Studio snippets. So if you want to restore the standard IntelliSense, you need to change the ReSharper Settings, on the ReSharper, Options, IntelliSense, and then General. And then you can switch here, from ReSharper to Visual Studio, and press Save. (Typing)</p>
<h3>The "INPC" Code Snippets Demo</h3>
<p>Now let's see a few code snippets more in details. We cannot review all of them, because there are too many, but we will see the most important ones and then you can study the others on your own. Here is the ViewModel class, and I will add some properties to it. Because the ViewModel inherits a ViewModelBase class, I have access to some Utility methods like we saw in Module 3, but we also saw that adding an observable property requires quite a bit of typing; what we call boilerplate code. Note that because this snippet group uses methods defined in the ViewModelBase and ObservableObject classes, it will cause a compilation error if you add an inpc snippet in a class that doesn't inherit from these base classes. To automate adding a property, let's just type mvvm. In the inpc section, we have a few choices. Here, let's start with the basic mvvminpc. If I expand the snippet by typing Tab, we can see the expanded code. There are a few tokens that can be replaced. You can jump from token to token using the Tab key. The first token is a property's name. Let's type the name "Status" here. The second token is a property's type set to bool by default. Let's change that to a string. Then, we add the name of the private field. Let's use _status too, but with the attribute conventions. Of course, you can use anything you prefer. Finally, we type the initial value, in this case a _status message, such as "Initializing". Once you are done, press Escape and the snippet is complete. Notice that this snippet had the constant for the property's name, which can be useful when you are outside of this class and need to handle the PropertyChanged event. Here, there is a check of the new value and then we raise two events; PropertyChanging before the value is set, and PropertyChanged after the value is saved. Let's add another property for the user's first name. This time we will use another snippet; for example, let's select the one called mvvminpclambda. This snippet uses a RaisePropertyChanged method overload, which takes an expression instead of a string for the property's name. We mentioned some of the advantages of this approach, notably it makes it easier to refactor a property's name. Here, too, we can replace a token; FirstName for the name of the property, the type is a string, the private attribute is also called _firstName, and the initial value will be empty. And then we can see the result, which is almost the same as the previous example, but this time using Expressions instead of the string-based property name. Now, let's add the last name too. This time we can use a Set method. If you'll remember, we saw in Module 3 how this method simplifies the status code a bit. Let's replace a token; LastName for the name of the property, string for the type, _lastName for the private attribute, and no initial value. After we replace the tokens, we see that the setter is only one line of code, instead of seven like before. We saw the meaning of the Set method in Module 3 about the ViewModelBase and ObservableObject classes. This convenient method simplifies ViewModel code. As a reminder, it also returns true, if the event has been raised. Finally, let's see a special case. Sometimes it can be interesting to not only raise a PropertyChanged event, but also to send a message using the Messenger class that we studied earlier. There is an overload of the RaisePropertyChanged method for this. Here is how we can use it with a snippet. Add any of the mvvminpc snippets with a Name and with the letter msg. For example, here I will use mvvminpcsetlambdamsg, which is quite a long name. When the snippet is expanded and after we replace all the tokens, this is the Age property. Note that the Set method here takes a Boolean parameter set to true, which will call the Messenger to send a PropertyChangedMessage. This is one of the built-in types in MVVM Light. To illustrate that, I built a small UI here in Blend with the FirstName, the LastName, and the Age. These fields are data bound to the corresponding properties on the MainViewModel. Now, in Visual Studio, let's check this Emailer class that I added. We see that when it is created, it registers a handler for a PropertyChangedMessage of int. First, it will check the type of the Sender and the Name of the Property. If the Property is the Age, it sends an email here using the NewValue that it just received. In addition, just for test, it will show a MessageBox here. This example is a little bit silly, but it illustrates the youthfulness of the PropertyChangedMessage, which extends the concept of the PropertyChanged event. And to show that it works, after we run the application, we can change the Age here, and here is a MessageBox from the Emailer class.</p>
<h3>The "RELAY" Code Snippets Demo</h3>
<p>Another useful group of snippets is used to add a RelayCommand to your code. This snippet can be used in any class, though in general we use that in ViewModels too. Here, too, there are multiple variations of the snippet. The default one is called mvvmrelay, which adds a RelayCommand without any parameter. So let's go back to the MainViewModel. And I'm going to extend it with a new RelayCommand used to show the user's full name. First I'm going to Tab mvvmr and then I'm going to select the mvvmrelay snippet. Let's expand it. And then I can Tab to replace the tokens. The first token is the name of the field hosting the command. We are going to type _showFullNameCommand. And then Tab to the next one, which is the name of the property itself, again, ShowFullNameCommand. And now we are done already. So I can go back to the first token and type Enter, which is going to automatically place a cursor in the location where it makes the most sense to start typing code. Here I will cheat a little bit and use some code that I prepared already. And here we go, this code is going to use a MessageBox to show the user's full name. Let's get ready to build the application, here we are. Now I can build. Now I go back to Blend, where I added a button saying ‘Show full name'. And what I'm going to do is bind the Command property of the button, to the command that we just added in the ViewModel, here we are. Here, too, I can run the application directly from Blend. Let's Enter my name, and now I can click on ‘Show full name', which is going to show the full name as defined. This last snippet was a basic RelayCommand without the canexecute delegate and without a generic parameter. We can, however, use a full-blown RelayCommand with all the options, using the snippet called mvvmrelaygenericcanexecute. Let's consider this UI here. We have a textbox and a button. Now let's extend the MainViewModel and add the RelayCommand with a generic parameter and the canexecute method. So I'm typing mvvm and I'm going to select the mvvmrelaygenericcanexecute, here we go. Then I will replace the token. The first token is a type of the Command parameter. Here, I want to check the string entered by the user, so I set this parameter type to string, which is a default. Then I Tab to the next token, which is a field name for the command. Let's call that _sendEmailCommand. If I Tab again, I have the name of the property itself, SendEmailCommand, and then another Tab is going to enter the name of the Execute method's parameter; this is the emailInput. Finally, we Tab once more to enter the canexecute expression. Here I will enter a simple expression, just checking if the user entered some characters. Of course in production, you will want to validate the email address against a regular expression, etc. Let's build the application now to have everything up-to-date in Blend. Now we can do some data binding. I can bind the Command property of the button to the new Command that we just declared on the MainViewModel. Let's use a ‘Create Data Binding' Editor, and here I can see the ShowEmailCommand. Then, I will bind the CommandParameter to the text value of the EmailTextBox. Let's go here and select ElementName, then EmailTextBox, and here I will choose the Text property, which is down there. Whenever the parameter changes, the canexecute delegate will be reevaluated. If the returned value is false, which is when the email field is empty, the button will be disabled, like we see now on the screen. Let's run the application to test what we just did. And here if I go to the email field and enter something, you see that the button is now enabled. If, on the other hand, I delete everything, the button is now disabled.</p>
<h3>'The "PROPDP" and "PROPA" Snippets Demo</h3>
<p>The few snippets that we just saw are the ones that are the most useful when implementing the ViewModel. There are a few other snippets that are less directly related to MVVM itself. In this category, we find the Dependency Property and Attach Property snippets. Dependency Properties are a specific feature of XAML-based frameworks, such as WPF, Silverlight, Windows 8, Windows Phone, that enable a lot of interesting features, especially in controls. In fact, if you use a default installation of Visual Studio, there are already two snippets available by default that allow you to declare a new dependency property and a new attach property. Let's see why MVVM Light also has such snippets, and how they are different. First, let's add a dependency property in a WPF application. Note that you cannot declare a dependency property in a ViewModel or in a plain old object. It needs to be a DependencyObject; for example, here, the application's MainWindow. I will use a default non-MVVM Light snippet. I simply type propdp and then I expand the snippet. We see the typical declaration of a DependencyProperty, including the type, the convenient getter and setter for the value, and the registration itself, with the property's name declared as a string, the property's type, the typeof the owner, which should be MainWindow, and the metadata instance that declares some value, such as here the default value of the DependencyProperty. This is quite complex, and I cannot go too deep into the details of the DependencyProperty System, but I encourage those of you who are not familiar with this system to study a WPF or Silverlight course. Now let's declare a DependencyProperty using the MVVM Light snippet; it is called mvvmpropdp. If we expand this snippet now, we see that there is one single difference; the property's name is declared as a constant, which is a much better practice. Notably, when an external object is listening to the DependencyProperty for changes, it will need to know the name of this property to analyze the change and verify that it is a correct property. Having this value declared as a constant, it's cleaner than the original version. Note that having a string-based id is not a very clean situation anyway, but this is the basis of the DependencyProperty System and there is not much that we can do about it. Here is a recapitulation. First we have the mvvmpropdp, which we just saw and which declares a dependency property in WPF, and there is also another snippet called mvvmpropa, which declares an attached property in WPF. Also, we have Silverlight versions of those two snippets, mvvmslpropdp, which you can use in Silverlight, Windows Phone, and Windows 8, and of course there is also mvvmslpropa. The differences to the built-in snippets are minor, but they can make the developer's life easier when you code a lot. Also, they don't really have to do with MVVM directly. In fact, dependency properties are almost never declared in ViewModels, but it is still a very common task for XAML developers to declare dependency properties, and as such, these snippets can be useful.</p>
<h3>Introduction and Demo of the Standard Project Template</h3>
<p>Now let's talk about the Project Templates. Once you install the MVVM Light Toolkit, as shown previously, you get a series of templates available in the File, New Project dialog. At this time, the Project Templates are available for Visual Studio 2012 and Visual Studio 2013. For Visual Studio 2010, I do not provide Project Templates at this time. However, I am considering creating a VSIX Installer for VS10 too. For now, if you use VS10, please use the NuGet method that I showed earlier in this module. The Project Templates are available for Silverlight 4, Silverlight 5, Windows Presentation Foundation 3. 5, 4. 0, and 4. 5, Windows Phone 7. 1 and 8. 0, and for Windows Store 8. 0 and 8. 1. Note that depending on your development environment, you might see only some of these templates. For example, Silverlight 4 is not supported in Visual Studio 2013, nor Windows Phone 7. 1. Let's see now what you get when you create a new MvvmLight application. For this demo, let's select File, New, Project, and then on the Windows we will take a (WPF45) application. Let's click OK. Once this application is created, let's run it. We see a new window with the text, "Welcome to MVVM Light". This is not earth-shattering, but let's see what happens when we open the application in Blend. Here, when we open the MainWindow, notice that the text is different. We already saw before the power of design time data, and this is exactly what we witness here. The application is architected in a way that triggers Blend to run some of the code. This, coupled with the fact that we can know in the code if we are running in a Visual Designer, allows us to tailor the data to allow the best visual design experience possible. The most important point of a new MvvmLight application can be seen in the code. First, let's open App. xaml, and here we see that the ViewModelLocator is defined in the global resources. Then, in MainWindow. xaml, we see that the DataContext is set to the Main property of the ViewModelLocator. Let's open the ViewModelLocator itself. Here, it is configuring the SimpleIoc with a DataService. Of course, this is just basic scaffolding and the DataService will be expanded or replaced in your application, but this gives you a good starting point. Let's take a look at the DataService, which is located in the Model folder. It is very simple and only creates a dummy DataItem and then returns it. This is where you will connect to an actual data service, a database, a web service, etc. There is also a design time implementation of the DesignDataService in the Design folder, and this is where the text that we saw in Blend earlier is set. Of course, in your application, you are going to do a lot of operations in the DataService, and some of them will be asynchronous. Note that for now, I am not using the async and await keywords, mostly for reasons of code compatibility, but it would be easy to modify the DataService to support these keywords. Finally, let's open the MainViewModel to look at the code. Here, we see the DataService being injected inside the constructor and then we call it immediately. Here, too, in your production application, you will have some logic to handle user input and call the service on demand, refresh the data, etc. A few small details that are not critical, but interesting to note; here, in MainWindow. xaml. cs, we call the Cleanup method on the ViewModelLocator when the MainWindow is closed. This method is not doing anything at this point, but it would be a good place to put code to close database connections, save the application states, etc. Now let's open App. xaml. cs, and here we see that we Initialize the DispatcherHelper. The exact location of this line of code is different depending on the framework that you are using; for example, Windows Phone, Silverlight, WPF, etc. But you can be assured that the DispatcherHelper is initialized as soon as possible when the application starts, so this is one less thing to worry about. Using a Project Template to start a new MvvmLight Project is, of course, not compulsory, and the NuGet option is quite popular. But if you want to get started fast and without having to worry about the plumbing, File, New Project, MvvmLight is a great option.</p>
<h3>The Windows 8.1 Project Template</h3>
<p>For Windows Store 8. 1, I tried a new concept for the Project Template and I added some meat, you could say, to the original template in the form of additional files in the custom folder. This is a little bit of an experiment and I am waiting for feedback from the community to know if it is considered as a good idea or not. When you create a Windows Store 8. 1 application, here is what you get. Let's run the application in the Simulator first and see how it is built. The application starts with the MainPage and a few elements. There is, here, a button that does navigation. I decided to have a standard button in order to put the emphasis on the navigation service that it is using. If you press the button, the application navigates to the second page, as expected. Let's go back to the MainPage. Now you see that the label changed with the date of the last visit. This is done to demonstrate how you can save the state of a page, and you can find the corresponding code in MainPage. xaml. cs. At the bottom, we notice a red area. This is a user control. The purpose here is to show how you can handle the different page mode. For example, let's see what happens when we move the Simulator to Portray mode. Here, we see that the User Control turned to green. Let's go back to Landscape mode. And now it is red again. Now I will place the page in Split mode. At first nothing happens, but if we resize the slider here, after a stress hold, the page's layout changes again. The User Control turns purple and its layout is different. The Navigation button goes from top-right to bottom-centered; also, the page's title is using a smaller font now. Let's play the transition a few times to see what happens. (Typing) Most of the objects that make this happen are added here in the Common folder. The purpose is mostly educational, in order to show to MVVM Light users how certain operations are done in Windows 8. We handle storing and restoring state for a page, navigation, showing dialogs, handling Orientation and Split mode, etc. Let's see how the Orientation and Split mode are handled. I am using a behavior to do this. Remember that we already talked about behaviors earlier, when we learned about the EventToCommand component of MVVM Light. Here, we have the Behavior implementation for the User Control. There are a few properties used to enter the name of the visual states defining the control's appearance. Then we have the Attach method. This method will be called automatically by the system when the page is loaded and the behavior is attached. The key of the process here is that the Behavior registers to the MVVM Light Messenger, for an OrientationStateMessage. When this message is received, the HandleOrientation method is called. We use a VisualStateManager to go to the correct state. This Behavior can be attached to a User Control. For a page we use a slightly different one, called OrientationStateBehavior. Let's open this one. In fact, it is inheriting the one that we just saw. The main difference is that this Behavior is an additional property, called SnapViewMaximumWidth. This can be used to specify when the page should go from Landscape mode to Split mode. Further below, this is where we attach to the OrientationChanged event and to the SizeChanged event for the page. Finally, here is where the Messenger is used to send the OrientationStateMessage. This will be received by the Behaviors attached to User Controls and they, in turn, will go to the correct state. Let's open the second page in Blend and see how we can use this Behavior. First, I will add a new User Control to the project. (Typing) Now I build the User Control with three columns, a big button on the right, three buttons in the middle, and a blue rectangle on the left. Let's add the Behavior to the UserControl. In the Assets Library, I will select the OrientationStateControlBehavior and drag it on the UserControl itself. On the right-hand side, notice the name of the visual state. Here, you could change these names if you want to, but here in the demo I'm going to leave them by default. Now let's go and define the state. I have to do that in the States tab here. Let's add a StateGroup name, OrientationStates. And here, I will only handle two states, the Landscape mode and the Snap mode. Now I am in recording mode; this is shown by the red border around the designer area. So here I can specify how the Snap mode is going to look like. For example, let's select this big button, and I'm going to make it Invisible. I can also select Button #2 here and hide it as well. And finally, let's take this blue rectangle here and turn it red. Now let's exit the state recording mode and go back to the page. After I build the application, I can go to the Assets Library, and on the Project, I will see the UserControl that I just created. Let's add one to the page. When the page gets created, it already has an OrientationStateBehavior; this is in the Project Template by default. Notice that this is the other behavior, the OrientationStateBehavior, in the contrary of the one we used in the UserControl, which is called OrientationStateControlBehavior. And here on the right side, you can see, again, the Visual StateNames, as well as a SnapViewMaximumWidth for the page, which is set to 500 pixels by default. In the page, the states are already defined by the Project Template, so I don't need to redefine them. Now let's go to Snap mode, and what I'm going to do is take this UserControl and move it down here to this location. Let's run the code and navigate to the second page. If I resize the application in Snap mode, we will see that after a certain stress hold, the application is going to toggle to Snap mode, as well as the UserControl here.</p>
<h3>New View, New ViewModel and MVVMLOCATORPROPERTY Snippet</h3>
<p>The last component that MVVM Light installs are the Item Templates. When you have an existing project, like here a Windows Phone application, you can right-click the Project and select Add, New Item. In the dialog you will see a few MVVM Light Item Templates. Unfortunately, there is a bug in the way that items are filtered by Visual Studio, so you need to pay attention to the items that you add. Here, for Windows Phone, look for the (WP8) suffix. We can add a new View, a new ViewModel, and a new ViewModelLocator. In this case the application already has a ViewModelLocator, so it doesn't really make sense to add a new one. Instead, let's add an MvvmView and we can call that SettingsPage. This page has a few predefined attributes, notably the DataContext is set, by default, to the MainViewModel. Let's change that to a new ViewModel called Settings that we will create in a moment. Let's add the SettingsViewModel inside the ViewModel folder. Then I will select an MvvmViewModel and call that SettingsViewModel. Let's add a new observable property, called DefaultEmailAddress. Then, inside the ViewModelLocator, I will add a property for this ViewModel. Let's open it. And for this I can use a snippet that we didn't see yet, called mvvmlocatorproperty. Here we go. Let's replace a token, this is a SettingsViewModel, and the name for the property is going to be Settings, just like we added in the SettingsPage a moment ago. This snippet creates noncompilable code, because it adds a static constructor for the ViewModelLocator, but in fact we have one already. This is done this way so the developer can simply cut this line out, then I'm going to remove the ViewModelLocator here, go to the actual constructor that we had before, and here I can paste the line that I just cut. After I build the application and open the SettingsPage in Blend, we see that the DataContext is set to the SettingsViewModel as expected. So, for example, I can add a TextBox to the page, and then if I take the DefaultEmailAddress property and drag it, it's going to data bind the TextBox. Text property to this property in the ViewModel, and here we go, we have the DefaultEmailAddress that we defined just before.</p>
<h3>Summary</h3>
<p>In this module, we started by seeing how the MVVM Light Toolkit gets installed. There are two ways to get access to the MVVM Light Libraries, either by using the NuGet Package Manager or by using an Installer. In the case of NuGet, you can choose between the libraries only, most suited when you are developing a class library or when you have an application that is already in development. Or, you can select the Full MVVM Light Package, which also installs a ViewModel, a ViewModelLocator, and adds some markup to App. xaml in order to provide the basic plumbing for an MVVM application that is also designer-friendly. Then, we saw how the Full MVVM Light Toolkit can get installed using the VSIX Installer from within Visual Studio, using the Extensions Gallery, or from the mvvmlight. codeplex website. This led us to study the additional tools that get installed, in addition to the Components Library. We started with the code snippets. These allow the developer to work faster by adding pieces of boilerplate code and some tokens that can easily be replaced to create working code. We talked about the inpc family of snippets, which add an observable property to a ViewModel, then we saw the relay snippets, which add the RelayCommand with various options. Finally, we saw a few more snippets less directly related to MVVM, but that the XAML developer will find quite useful. We finished the module by talking about the project and item templates. We saw how a typical MvvmLight application created by one of those templates looks like. We also saw how the more complex Windows 8. 1 project template installs additional components that are useful to build decoupled applications. Finally, we took a quick look at the item templates for review in the ViewModel. In the next and final module, we will see a lot of code examples and learn how MVVM Light can be used in some specific situations. For example, we will talk about adding MVVM Light to a plugin-based application, we will also see some practical usage for the Messenger and SimpleIoc, as well as see how unit tests can be created for the ViewModel layer.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>

</html>