<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>Building an API with ASP.NET Core</title>
  <script src="https://unpkg.com/vue"></script>
  <!--<link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"-->
  <!--integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" rel="stylesheet">-->
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
  </style>
</head>
<body>
<div class="container" id="app">
  <div class="panel-group">
    <div class="panel panel-primary">
      <div class="panel-heading">
        <h2>Building an API with ASP.NET Core</h2>
      </div>

      <div class="panel-body">
        <div>
          <h2>Course Overview</h2>
          <div>
            <h3>Course Overview</h3>
            <div>
            <div>
              <h2>Pragmatic Rest</h2>
              <div>
                <h3>Where We're Headed</h3>
                <p>Welcome to building an API with ASP.NET Core. My name is Shawn Wildermuth. In this module, we're going to start by talking about pragmatic REST. In this course, we will teach you creating an API using ASP.NET Core, creating API controllers, querying and modifying data, using association controllers, defining operational APIs or APIs that don't conform to data or entities, and then versioning your APIs with MVC 6. Currently, the course is built with Visual Studio 2017 version 15.9, ASP.NET Core 2.2, and Entity Framework Core 2.2. You can get each of these by going to get.asp .net. If you have questions during the course, I'll be available on the Discussion tab of this course. That's the best way to reach me, ask questions, help get unstuck, even find problems with your code. I check that virtually every day, and I try to keep on top of the questions. Just stop by the Discussion tab if you have any questions. </p>
              </div>
              <div>
                <h3>How Does HTTP Work?</h3>
                <p>
                  If you're taking this course and you already know ASP.NET Web API, the version before ASP.NET Core, there're some key things that are different between ASP.NET Web API and how ASP.NET Core are handled. Microsoft has merged the Web API stack that you're probably used to with MVC. So there aren't these two different worlds any more. They're really one world that can both answer requests. Some of those requests are APIs, some of them are web pages. A lot of what I'm going to show you will be familiar, and there are parts that are quite different. But this is really the future of where ASP.NET is going for building APIs. Some of the facilities we're looking at are even back supported in ASP.NET Web API. So the core of what this course is trying to teach you is this idea of making requests over a network connection. Your client may be a web app, may be a mobile app, may be even a desktop app, may be a way to expose an application interface to some other program. But this is a bit different than building an API in process or some of the old ways. We really are creating an API that needs to be called over a web connection. And the way that web requests work is different than simple networking. All the requests we're going to make are going to be over the Hypertext Transfer Protocol. Whether we're using HTTP or HTTPS, the way that the web works is important to understand, when we're designing and building APIs, what actually is going on. So in a standard request, you have some user that wants to make a request to a server. This might be for a web page, this might be for an API, a JavaScript file, an image, whatever. The bulk of what we're going to see works in exactly the same way. The request itself has three pieces, a verb, which is what you want to do, headers, which include additional information, and then the actual content. In the case of a simple request for a web page, a content might actually be missing. But if we want to go ahead and, let's say, send the phrase Hello World to the server, and we're doing that to ask the server to create something, we can see that the verb is POST, so create something, the header is telling the information about the request, how long the content is that it can expect, and then the body is the actual Hello World, which makes up 11 characters. The server, once it completes the operation, wants to send a response back that is chiefly the same structure. There's a status code for whether it succeeded or not, there's headers that might include information, and it may also include content. So in this case, it's going to say, hey, I got your request, I completed it successfully with a 201 response, which means created, and I'm going to return to you what I created, some text, and here's the text in the body. Your APIs have to live on top of this world, and so understanding how this works is really important because if you've built APIs before by writing .NET code or writing Python code or wherever that was, you may be thinking of building web APIs in the same way. And it doesn't work because one of the key ideas about this is that the server is stateless, the server isn't maintaining a constant connection. Every API request is a one round trip call, and the server's not going to remember who you are, what you are. You're going to have to send everything it needs to know about to do an operation in the request. It needs to be part of the header, the verb, or the body of that request. In this way, to make these calls, we're going to have different verbs that are going to be supported. The most common of these is GET. Hey server, I want you to give me something that you have. And this is essentially to retrieve a resource. You can think about a GET as please give me this webpage, like the homepage of a website, an image, a JavaScript file, or in the case of APIs you may be requesting entities or data that are available on that server. POST adds a new resource. So POST says go create me a new one of these. And this is the data that's related to the new object that I want you to create. The PUT verb updates an existing resource. So essentially it says here's the data that I may have retrieved from you earlier with some changes. Please update it with these changes. There's also one that's a little less used called PATCH, which says update the existing resource with a set of specific changes. And the difference between a PUT and a PATCH is a PUT is going to take an entire resource or an entire thing and update it entirely, where a PATCH might say please update the zip code and the street address, but leave the state alone or leave the city alone. So PATCH is just going to include the data that needs to be updated on the object. And then finally, the one that's most obvious is DELETE, which is remove the resource. There's actually a large number of verbs, but for the case of what we're going to be building, building APIs primarily around the concept of messages or data, these are the five verbs that are most important. Let's take what we've learned about making requests over the web and apply it to something called REST.
                </p>
              </div>
              <div>
                <h3>What Is REST?</h3>
                <p>You may be familiar with this concept called REST, but let's go ahead and define it. REST means Representational State Transfer, and it includes concepts like separating the client data from the server data. It makes sure that all the requests to the server are stateless, those requests themselves can be cacheable, and that they use a URI or uniform interface to get to them. All these ideas came from Roy Fielding's doctoral dissertation about REST. REST actually has some problems in my opinion. It often becomes difficult to make sure that what you're building is perfectly RESTful. And people get concerned with doing it perfectly. It becomes this argument of dogma, building something that's perfectly RESTful that adheres to all of the ideas around REST or building an API that serves the larger pragmatic goal of the project, whether that's to retrieve data or allow your website to work better, or simply to do things like sell more pizzas. At the end of the day, I think that pragmatism is more important than being qualified as perfectly RESTful. REST defines this structured architectural style that may not fit into every domain. Ultimately, your need to be a productive developer, I think, is more important than making sure that what you're building is 100% adherent to the REST principles. Not everyone agrees with me. The problem really comes in this idea of what we're trying to build. We're trying to build maintainable systems that are going to live for a long time. In building, architecturally perfect, RESTful systems can make them more maintainable, but any rigidity or rigorousness in your philosophy will ultimately, in my opinion --- Over the last 30 years my experience tells me that it's going to backfire. That being fully adherent to some principle versus the job you're trying to do --- Ultimately for me, building an API is about serving the people inside or outside my organization that need me to solve something. And if that means that I need to bend the rules of REST to make that work better for them, I'm going to. So trying to find and pick and choose the parts of REST that are super important, like maintaining statelessness and cache-ability and some of the other things we've talked about, are really good ideas, but when you sit down with someone and they want to criticize what you're trying to do really based on the simple concept of whether it's perfectly RESTful architecture or not, I think they're missing the point. I've thrown out this concept of resources a couple of times. Let's talk about what I really mean by that. </p>
              </div>
              <div>
                <h3>What Are Resources?</h3>
                <p>
                  So when we're talking about REST, we're normally talking about a URI that needs a point at a resource. And what do I mean by resources? Resources could be as simple as people, invoices, payments, products. They're things that represent the objects in your system. In some circles they're called domain models. In some systems they're called entities. It really doesn't matter what they are exactly, but they're the things you want to get, insert, update, and delete. So when we talk about resources, it might be easy to think of them, especially in the ESP.NET Core world, as just entities. And so a resource could be something like a person in your system, but often there's a context around it. So when we're talking about resources, we're not always talking about individual items like a person. We want to think about everything in a context as a resource. And sometimes it's a single object inside of this contextual idea like a person or let's say a product, but it also could be something like an invoice and invoice items. Right? Those are contextually one thing, one resource, even though it might be made up of a dozen or so entities. Right? An invoice and maybe the invoice items that are related to them. And so when we talk about a resource, we're talking about these endpoints to resources that are made up of one or more entities. And this can be a quite large entity. Especially for things like reporting, you may find that getting the customers that have invoice items that are pointing at the product means that that graph really is one resource when we want to think about it in that way. So don't get too tied up in thinking that resources and entities are the same thing. They often are not, but sometimes they are. And so, think of them with this contextual model that you'll see from domain-driven design. It works really well to think about what it means to be a resource. These APIs want to expose these atomic units that may be made up of one or more entities. Now that we have a foothold on what resources are, how are resources related to the URLs or URIs that we're going to be building? Let's take a look.
                </p>
              </div>
              <div>
                <h3>Designing the API</h3>
                <p>
                  So when you start to design your APIs, you're going to want to think about what the actual address is to these APIs. They're what we call URIs, or Uniform Resource Identifiers. These URIs are just paths to the resources within your system. So if you have your server, the resource for individual people is just the path to them. While these don't need to be expressly human readable, the humans in this picture are the developers. And so making it in plain English, or whatever language you're developing in, ends up being important. Query strings, on the other hand, can be used for non-data elements. So, when you start to think about formatting and sorting and searching, that's where query strings, because they're not part of the URI itself, they're about optional arguments to those URIs or to those resources --- So where are we headed? We're going to build a whole API. We'll be building an API based on a code base that you're going to start with, and we're not building the database, we're not building the website, we're not building the client-side code. We're not even building the entities. You're going to start from a project that includes a simple Entity Framework model. If you need to know more about how Entity Framework works, you'll probably want to know a little bit about it before we get started here. If you go to Pluralsight and search for Entity Framework or Julie Lerman, you'll find a lot of great courses on that. It's not important that you understand Entity Framework deeply, but we're not going to get into the part of the code that actually builds the database or even defines the data access layer. We're going to be focusing on specifically the API. What our data model looks like is we're building something for our Code Camp. So we have the idea of one or more camps that have a relationship to a location. So, an event on some weekend has a location where it's going to be held, and that's a one-to-one relationship because each camp needs one location. Each camp will have a set of talks for the actual presentations that are going to be shown, and each talk is going to have a speaker associated with it. Now, in a perfect world, this data model could be a lot more complicated, but for our use in building an API this is the data model we're going to begin with. Now this data model may not represent the exact resources we're dealing with. This is actually the data model, the tables that are going to be stored in a database for us. These are the entities.
                </p>
              </div>
              <div>
                <h3>Designing the URI</h3>
                <p>Now that we have a sense of what our entities look like, let's talk about how the API should look. So we're going to start by designing the API around this idea of a camp. So the api/camps is going to return each of the camps that our website can surface. Now these camps may not be different camps that are located in different areas, more likely this is going to be camps that are for each year that a Code Camp is being held. When we want to reach one of these, we're going to use something called a moniker, which is just a string that represents that camp. This isn't the primary key of camps, it's simply a string that uniquely identifies the camp. Once we can identify a single camp, we're going to use an association API to look at the talks that belong to that camp. And so, as you can see, we're going down this by adding different elements to the URI that represent the relationships between the different items. And we can use query strings to change the kind of things we want to return. So by saying topic=database, we might only return the talks in that camp that are of the topic database. We can also look at the individual talk within that camp by giving it some ID and then walking down further to get actually the speaker for that talk for that camp. And so this cascading of extending the API to be explicit, because when you look at this you should be able to make sense of what we're actually looking at, because the API itself is related to the elements within the URI. We're also going to talk about operational APIs, or APIs that don't actually involve or depend on resources. In this case, we might write a handful of APIs that do something functional to the system, as in this example with reloading the configuration. Now I think that's probably enough slides for both of us. Let's start digging in to the actual code. Let's do that next. </p>
              </div>
              <div>
                <h3>Getting the Starting Project</h3>
                <p>So now let's look at the starting project. If you go to github.com /psauthor/CoreApiFudamentals, which is the name of the course, you'll see all the source code for the starting project. It's all in this src directory. If you just drop down and click Download ZIP, you'll get a copy of this directory that includes all the source code. This directory is going to have a solution in it. And if you open up that solution, it'll open it up in Visual Studio. And this solution is going to have a few things that we want to take a look at. First of all, there's a Data directory, and this includes an entire Entity Framework data model, a repository that we're going to use to get and save data from, as well as individual classes that contain the entities that we looked at in the slides. If you're not that familiar with Entity Framework, I do suggest that you understand a little bit about it before you start to do this project. But you don't need to know it very well in order to understand what we're doing. We also have a folder for controllers. And we have this ValuesController that was built by the template for us. And so I'm going to use it just to show the beginning tools, but we're going to delete it and start from scratch soon after. Other than that, it's a standard ASP.NET Core MVC project. We're only going to be building APIs in it. There's not going to be any views, there's no HTML, none of that. It's going to be a pure API project. Let's see how this works next. </p>
              </div>
              <div>
                <h3>Using Postman</h3>
                <p>So now let's talk about the main tool, Postman, that we're going to be using to execute our API calls. Instead of showing you how to call this from JavaScript or from C# or any other language, we're going to talk in the pure language of HTTP. If you don't yet have the Postman tool, it's a free tool that allows you to test and call APIs in a really simple way. You're going to want to go to getpostman.com, and you can simply click to download the app. It is a Chrome-based app so it should work on any operating system that ASP.NET Core works on. This does not require Microsoft Windows, though I'm going to be using Windows throughout our examples. If you switch over to Postman, you'll see it's really made up of a couple of things. I want to give you a brief tour of Postman since we're going to be using it so heavily. First of all, this has a History sidebar that I'm actually going to turn off here to give us a little bit more room. We're using a Beta Feature to show the request and the response next to each other. And your screen may be a little different, but if you go to the settings, and under General scroll all the way down, you'll see the two-pane view here is actually turned on even though, for some reason, it was shown turned off. You'll also want to make sure that the automatically follow redirects is turned off. This will allow us, when we run into problems with errors, for it not to try to send us to some other page. So let's close that, and your screen should look something like this. And let's go ahead and execute our first call. Our server in Visual Studio is already running. And I know that because I earlier hit Ctrl+F5 or used Debug, Start Without Debugging to just execute this. And so, the way that Postman works is we're going to simply give it an address, and in our case that's going to be localhost6600, and then api/values, which is the address of that one sample controller we have. We could also set up parameters like query string values, we could set up authentication, set headers, set the body if it's not a GET, those sorts of things, directly in here. And when we send this request, we can see that it didn't know about it. And that's because the value we're putting for our test server isn't known right now. The sample project that we're using in Visual Studio doesn't have a specific port set, and so I suggest instead of finding out what this is every time, because it can change over time, is to go into the project's properties and under Debug just change this port here to 6600. The idea here is to have a memorable port number instead of some random high number in here. So this could be anything you want, but for our projects here I'm going to go ahead and use 6600. I'm also going to unclick launch the browser because we're going to be using Postman. So launching the browser every time we run this probably isn't helpful. So let's hit Ctrl+F5 again to rerun it. And when we come back to Postman and now hit Send again we'll see we get our first result from this ValuesController. Now you've called your first API here, but I really haven't taught you how any of this stuff is working. Let's do that next by actually going to our project and walking through all the code that gets us to this point in the project, just to give you a reference point to start from. </p>
              </div>
              <div>
                <h3>Trip Around the Project</h3>
                <p>
                  So now let's get the project ready for us to start writing our API. Back in Visual Studio, let's start sort of from the beginning. Because I'm assuming you have some familiarity with ASP.NET, a lot of this should be review. So we're going to go through it pretty quickly. In our Program.cs, we're not doing anything special here. We're not ceding the database or anything. It's just the standard startup that pretty much every project starts from. In the Startup itself, we're configuring a context object for our Entity Framework model, this is what's going to contain our data, and then we're setting up a repository. This is the way we're going to call into our database to get data, as well as update data. In the config here, the only thing that's interesting is I'm using the Developer Exception Page so we can get the exception information when we actually throw exceptions. Note I'm not getting static files or anything else like that because we're not issuing web pages and the files that go with it. And so even though there's a www root, we're not actually going to be serving any files from there. If, for some reason, your API project needed to do that, we could certainly enable this later. But we don't need it right now. In the appsettings file, there's not a lot of information here, but the one to really be aware of is this connection string for CodeCamp. This is how the Entity Framework model is actually reaching the database. So, if you have Visual Studio installed on a Windows device, this is pretty simple where you can just point it at your MSSQLLocalDB version or, if it's on a remote machine, you could certainly put whatever the address of that machine is. The initial catalog here is also important because that is the name of the database that you're going to be creating. And you can call this whatever you want. With all of that in place, we should be able to just open up a console, and in this directory just call dotnet ef database update. And this will take all of the migrations that you got with the project and apply them, even creating the database if one didn't exist before. Now I would suggest you do this before you continue on with the course because you want a database with the sample data already included. The code itself, the Visual Studio project, isn't going to do that. If you want to understand how migrations work, again go see Julie Lerman's great course on Editing Framework or go visit the Entity Framework section of my ASP.NET Core course. Now that the database is all set up, we can start to actually work with the code. The last thing I want to show you here in setting the project up is I'm going to be using some extensions, and so it might be helpful for you to know what sort of extensions in Visual Studio that I'm actually using. So if we go into Extensions and Updates for tooling, we go to All Installed, there's a couple of these that are going to be important and a couple of these that we're not actually using. So a lot of these are built into Visual Studio by default, but there's a few I want to point out. The first of these is Open Command Line, and this is a project where you can simply have a shortcut key, it's Alt+Space by default, to open up a command line. Anywhere in the app I want, I can just hold down Alt+Space and it will open up a directory in the directory that is currently open in the main code window. The other one that you're going to see a lot is this Add New File extension because as I add files to the project I'm going to be using this to quickly add files instead of doing the Add New Item, Project, etc. And you'll see that's going to allow us to create and scaffold our project quicker, but I just want you to see it so you know what it actually looks like. The rest of these are more about ASP.NET development, and especially razor and website development, so I'm not going to bother. It's just those two that I think are pretty important. So let's wrap up this first module and get to building our API.
                </p>
              </div>
              <div>
                <h3>What We've Learned</h3>
                <p>So what have we learned in this first module? I've talked about HTTP being so crucial to understanding how you're going to write your APIs. When we're talking about APIs that live on the web, understanding how the web itself works is really important. We've also explored REST as a way to design your APIs, but to try to be pragmatic about it, not to get so tied up in the dogma or worrying about whether the project that you're building is perfectly RESTful and that someone can come in and say it's architecturally perfect. And finally, I've shown you that we're building a simple project with the idea that we're going to be building a large-scale API project. So I think it's important for you to understand all these basics first, and then we can start to build and extend the kind of APIs that you're going to need within your organization. In the next module, we're going to be talking about building your first APIs and reading data through your API. Let's get started. </p>
              </div>
            </div>
              <div><h2>Building Your First API</h2>
                <div><h3>Introduction</h3>
                  <p>
                    So let's get started by building your first API. In ASP.NET Core, when you're building a web API it works in a very specific way. A request comes in from the server, and we have the route, which is essentially the path part of the URI. This may or may not include things like query strings, but mostly it's just the path to the endpoint on our server. ASP.NET Core then takes that route and tries to match it with existing routes that are found in the project. Once it's found a route, it looks at the action and controller for that route and executes it. When we talk about an action, we're really just talking about a method on a class. All these fancy words really come down to the controller being a class that has methods on it, and so a controller has methods that we call actions. Once that action is executed, we can then return the response of that action from the original request.
                  </p>
                </div>
                <div><h3>Creating an Action</h3>
                  <p>So now let's create our first action. Back in our project here in Visual Studio, I'm just going to open up that Controllers directory, and I'm just going to delete the old controller that was built by the project. We're going to go ahead and create our first controller. And if you remember back to the API, we're going to want to actually execute api/camps in order to get the different Code Camps that are supported by the API. So I'm going to create a new class that I'm just going to call CampsController. And as we saw when we were defining the API, I tend to prefer APIs that use plurals. So even though our data model might have Camp as an individual entity or CampModel for an individual entity that we want to return, I'm still going to have the controllers and the APIs actually use the plural. And one thing we're going to need in our new controller is a route. And I'm going to use the Route attribute to specify the route. And so here, this route is going to be exposed to that route table so it can match it. So if we know our API is api/camps, we could just simply put it in there. But more commonly, we're going to use this bracket controller syntax. And what this does is it says our route is actually whatever comes before the word controller. So it's a way to not hard code with the name of the API here, but to have a relationship between the two. We're also going to want to derive our CampsController from a base class. And we could do Controller, which is a class that all MVC and API controllers can derive from. We're going to actually use one that is really specialized for APIs called ControllerBase. And ControllerBase is going to be found in AspNetCore.Mvc. And you'll see that Route is also in that same namespace. So now that we have this, let's go ahead and create a simple GET to return our first camp. So create a public method. And for now, I'm just going to return an object because we're not yet to the point where we're going to actually deal with concrete types. And I'm just going to call it Get. And the idea here is that we're just going to handle this as an HTTP GET. Someone's going to request a GET on our controller, and we're going to return some data. So let's just return just a new anonymous object that has a moniker, which is some user-identifiable string that we're going to use. And I'll just call that Atlanta this year. And then I'll give it a name as well, Atlanta Code Camp, just so that we can see that we can actually get data directly from our API in this very simple way. If we run this, we'll be able to execute this inside of Postman. We can do that by just calling our localhost. And if you remember, we used 6600/ api.camps. We can see that same data coming out of the API. It took the name of Get and assumed you meant that it needed to be an HTTP GET. And it formatted it in a way that's friendly as JSON, including changing the case to camel versus Pascal case. All those are things that we can actually control, but right now this is the default behavior that we're going to be using. But if we come back here, we actually have a problem because this always expects an object to be returned, and what if we actually have a problem where we want to return some other value? Because if we look in Postman, we'll see that we actually have a status of 200. That, from an API standpoint, is what you want to see when it was successful. But how do we then communicate to it that something bad happened? Maybe the request was incorrect, maybe the error was incorrect, and we can do that with status codes. Let's look and see what status codes are like next. </p>
                </div>
                <div><h3>Status Codes</h3>
                  <p>So in the first module, we talked about what made up an actual request and response. And part of the response was this thing called a status code, which is a simple number that represents whether an operation was successful. Did you find the web page, did you find the image, are you allowed to see the image, did something catastrophic happen? And so the general status codes you're going to be looking at are these. So 200 OK is the standard status code for saying everything's fine. 400 is when you've asked for something that is incorrect. You can see the 401 and 403 are about whether you're allowed to look at it. And then finally that 500 is about the server has done something wrong, something catastrophic has happened. And so, even though we have all these status codes, these are the three that you're going to use most often. There's actually more that you'll use, but at a minimum you should be using 200 for OK, 400 for bad request, and 500 for internal error. And these really mean, 200 means ooh it worked, 400 means you did something bad, you included some part of the request that I can't fulfill, and 500 says we did something bad, the server threw an exception, something bad happened. There're other status codes that I suggest you also take a look at like 201 for created. Later, when we're creating new resources in our API, we want to return 201 to tell it that we actually created the new element. Three-hundred four is useful for representing cached objects. The thing you requested hasn't been modified since you last requested it. And then 404, which of course we're all familiar with, in that someone's requesting something that we can't find. And then of course 401 and 403 for the security measures. So let's use these status codes in our API. </p>
                </div>
                <div><h3>Using Status Codes</h3>
                  <p>So now let's use status codes in our API. If we modify this to use status codes, what we're going to want to do is actually change the response type here to something called IActionResult. And this is where that term action comes from in that we're going to return an action from this method. And an action could be success or it could be failure. And the way we're going to really do that with ActionResult is just surround it with a method on ControllerBase called Ok. So we're essentially saying return this data and set its status code to 200. Something bad happened, we could also return BadRequest with some message like bad stuff happens. Right? So, this is giving us more control over success and failure. And instead of doing things like throwing exceptions, which are going to cause sort of top-level errors to be thrown, you're really allowing yourself to use these status codes because the clients of your APIs are going to be able to use those status codes to figure out what went wrong in case there's not a 200 being returned. So in this case with the BadRequest, it may be that some parameter that's being sent to us is one we don't expect. And so, we're going to return BadRequest. Or it might be that there are no camps, and so we might want return NotFound, which is essentially a 404. We can see these by just hovering over them. It's going to give you a sense of what they actually do. Again, these are directly on the controller base. So this. and then looking at things like NotFound, Redirects, all sorts of things that are going to tie us to the actual status codes that we want to return. Of course I'm going to get rid of this because we're not actually going to do this. And, for good measure, Get is going to work because it's inferring that Get is a GET. But I like my APIs to be nice and descriptive, so I'm actually going to use another attribute directly on the action to say which of the operations I want to actually use. In this case, I want to make sure that it knows that this GET, because this could be called GetCamps if we wanted, like the name of this isn't as important, we're just saying that this is going to be a GET to the same route that we have here. Right? We're not changing the route, we're just using the route that's on the class. We'll create a new action soon, and you'll see what that looks like as well. So let's go ahead and look at this in Postman again, just to make sure we've done everything right. And if I go ahead and send it, you'll see we're still getting it and we're getting that 200. But this time it's more explicit in our code the reason we're getting the 200. So what I'm hoping you'll take away from this is that the route plus the verb on the action is how you get some operation that someone can call. This is the endpoint, not the class, not the controller, but the actual action is the endpoint. So let's take this as a starting point, and let's next get data from our data access layer and return it directly through the API. </p>
                </div>
                <div><h3>Using GET for Collections</h3>
                  <p>
                    So now let's create our first GET for a collection, and we'll use our data access layer that we've been supplied for that collection. So what we'd like to do in this GetCamps, or just Get method, is actually get all of the camps that are inside of our data store. And we haven't spent a lot of time looking at this, but the real part of the data access that we're going to care about, because I'm not going to really explain the Entity Framework magic here, is this ICampRepository. This has the ability to add and delete objects, to save changes, and then different queries for different kinds of objects; camps, talks, and speakers. And we want to use this GetAllCampsAsync. But before we can do that, we actually have to get an instance of this repository. If we go back to the startup, we can see that this repository is actually added to our service collection so that we can inject it into different classes. And we're going to do that with the controller by simply creating a constructor. So by saying ICampRepository, and we'll need to bring that namespace in, and let me just use some Visual Studio magic to make it happen, we're just going to end up with a repository that's being passed in, and then we get this member of our class that we're going to use. So instead of returning an anonymous object, we're actually just going to call _repository.GetAllCamps. But you'll notice this is async. And so, the result here ends up being a task of camps, not the actual operation. And so, when you're using a facility, like our repository, that happens to support synchronicity, like you should in many cases, you're going to want to make your action asynchronous as well. So let's go ahead and make the method asynchronous and then wrap our action result in a task. That way we can use async and await to make the magic happen. We don't need to think about the asynchronicity here, we can just let the compiler do the magic here. And then we should be able to, just inside the Ok, just return results. But what if something bad happens? Right? What if a database is offline or something else bad? We're going to want to actually create a try-catch block, and let's go ahead and move our code into the try. And what happens if we get a catch? Right? We can simply say BadRequest Database Failure. But this isn't actually a database failure. Right? The request is fine. We actually want to return a status code of 500 or server failure. And so, this base class doesn't have a method for doing this, but it does have a method for returning any sort of status code you want. And so what we can do here is actually return StatusCodes, which is an enumeration that you'll need from AspNetCore.Http, and that gives us all the status codes with sort of a description of what they are. So when you run into one of these situations where you need to return a status code that isn't one of these standard ones, you have access in this way to return any status code. And in the case of a database failure, we're going to do it by actually just returning a 500. This should be a very exceptional case, no pun intended, for this to actually run. And so this may be more work in absolutely every case than you actually need, but I like the belts and suspenders of knowing that when something fails we're going to get it to fail well. So we go back to Postman. We issue this request again. Remember we haven't changed the endpoint, we've just changed the guts of what it does. You can see we're now actually getting an array that right now only has one camp in it. And this is the Atlanta Code Camp, that ATL. This is all information that's prebuilt into our Entity Framework data model inside the database. So we're pulling this actually from the database and just returning that. And we're returning not only the camp, but this nested object as well. So, I'm going to think about what I'm returning here as a hierarchy, a complex object, not just necessarily a single entity in that way. And one of the things I want you to think about is this idea of knowing what we actually want to return here. So one idea I want you to get here is that the guts of what it's actually doing here should be able to be read by somebody that understands the way that HTTP works, and it should make sense. I want to issue a GET, I don't have any parameters, I'm going to do some operation like getting from a database, and then when I return it I'm going to return it with the status code of Ok. And if something goes bad, I'm going to simply return this status code to say the world is falling apart so I'm going to return you a 500 error. Make sense? In this example, we're returning actual entities from the database. We actually don't want to do that. Let's see how to use models instead next.
                  </p>
                </div>
                <div><h3>Returning Models Instead of Entities</h3>
                  <p>So in the last video, I hinted that we're going to use models instead of entities. And why is that? It's important to me to have an abstraction between the entities and the models and all but the simplest projects because that payload ends up being the contract with your users. You want the model to represent what you cannot change until you absolutely have to change. You often want to take the data that's coming from a datastore and filter out data that might be bad for security or that you just don't want to leak. Surrogate keys are often useful here as well so that they are more human readable or not tied to specific implementations inside of a datastore. So let's change it so that our API is returning a model instead of directly entities. So if we go back to the code, let's create a new folder for our model. And I'm going to call the folder Models, and I'm going to create a CampModel.cs. And all this CampModel is going to do is represent a smaller or even a different version of what the camp is. So, when we look at the Camp class here under Entities, we can see that it has an ID, which is the primary ID in the database. And it also has some other properties that we want to use. And let's just start with a small subset of these. I'm going to actually just copy these. We'll get into how we're going to do talks later and how we're going to do location, but we're not going to use all of these properties. I'm not going to include the location for now, just a date, the length, a moniker, which is something that users will be able to see in the URI, and then the actual name of the camp. So let's take this model and use it in our API. So I'm going to go back to that CampsController because we want to turn these results, which are an array of Camp, into the real results. We might need to write a bunch of code to map it from one thing to the other. So if I have a models, let's say this is going to be CampModel array, and let me bring in the namespace, we need some way to convert results to that CampModel. And we could run code in here that does this. We could use a link statement, we could do a foreach, whatever we want to do. But we want to be able to do it a little simpler. And so we're going to use a mapper, and I'm going to use AutoMapper. Though if you're already using another mapper the specific one you use isn't as important as having a good way to map between these two types. So let's include AutoMapper. I'm going to first manage my NuGet packages so I can add a couple of new packages. And I'm going to look for automapper.extensions. And you're going to see this AutoMapper.Extensions .Microsoft .DependencyInjection. This is a set of extensions to allow AutoMapper to work with ASP.NET Core a little easier. And it'll also install AutoMapper as its dependency, which is something we also are going to need. So it gets all of those. So we can go ahead and close it. And before we come back and fix this, let's go into our startup because what we're going to want to do here in the ConfigureServices --- And so we're just going to add services.AddAutomapper. And we'll probably need to add using AutoMapper in order to get that. And so what AddAutoMapper actually does is look for these things called profiles. And we're going to actually create one here in the Data directory so you can see what AutoMapper is actually doing. So I'm going to create a CampProfile, just a simple class, and it's going to derive from AutoMapper's Profile class using AutoMapper. Make sure that it actually added using AutoMapper because that term profile is used in a bunch of different places. And all we're going to then do is create a constructor. And inside the constructor we're going to create a map from the Camp class to the CampModel. And we can do that by calling this, so that you know it's from the Profile class, CreateMap, and we're going to give the two classes we want to map between. So we want to go from Camp to CampModel. And we're going to need to bring in both Camp and CampModel. And as long as it can discern the mapping between them, and because we're using the same names and the same types it'll be able to do that discerning for us. This is all we'll need to do to create a mapping. And so to use the mapping, it becomes pretty simple. Here in the controller, we're going to inject a new type called IMapper. And this will be in the AutoMapper namespace. And I'm just going to create a local variable like I've done with everything else. And now I can use this mapper here to say _mapper.Map, and I want to create a CampModel array from our results. Now we could map a CampModel from a Camp individually, but this will also support all sorts of collections of those types as well. It includes IEnumerable and IList and List and arrays and all these standard, sort of generic collections that you're going to see and use inside of ASP.NET Core automatically. And since we're going to be using arrays, I'll just change this to models. And this should just simply work. If we go ahead and run this and look in Postman again, and we now look at that same API and execute it, you'll see what it returns now is just what is in the model. And it's done the mapping to bring in the name and the moniker and the eventDate and the length all automatically. And so if we had a bunch of these, which we will by the end of the course, you'll see that these models represent what we want to expose to the user, not necessarily what internally we have. Because this moniker is unique, we're using it as essentially a surrogate key. So we're going to be able to look up existing camps through the moniker. And the moniker is something that's going to be visible to the user in different places, especially in the URL. And so we're using it as the ID here. Let me show you one more thing that's important here, and that is I'd like this method to be able to tell me what it's actually returning. This way I could do certain things to expose the API. Maybe generate documentation with different tools. Maybe I just want the APIs to be documented well. And we can actually change this IActionResult to ActionResult that takes another generic parameter. And this generic parameter is the return type. So I can say CampModel array here. And what it actually allows us to do is in the case of Ok it's going to assume that if we're returning a type that matches this that it's going to return Ok for us. And so, we can do a little bit more about cleaning up just a little bit more code in here. In fact, let's make this even easier, and let's get rid of the temporary. And we're going to see this is a pattern I'm going to use a lot where I'm just going to use the mapper directly on the return because I can expect that until we get into very complicated scenarios that this should just work. I don't need to be able to debug down to the individual line. From our Postman side, nothing should really change at this point. You should just go ahead and execute it and it will give us an array of these new CampModel objects. Next, let's try to get an individual object from the API so we can see how to design those endpoints. </p>
                </div>
                <div><h3>Getting an Individual Item</h3>
                  <p>Now let's show how to get an individual item through the API. So here, we're back in the CampsController, and while this GET is getting all the items from the database, we want to be able to support actually just getting an individual camp because that may be another use case we need to worry about. So I'm going to start with just a new action like we've done before. And instead of IActionResult, I'm actually going to use that templated version to know that I'm going to return just a CampModel here, and I'll call it Get, but I'm going to include another parameter. In order to get an individual model, I'm going to want to know which camp they're looking for. So I'm going to specify as that moniker. That way the user of our API can use that moniker to get individual items. So they're not numbered, and often the moniker has some information that can make sense to developers. In order to do this, I'm going to do HttpGet again, but inside of the GET I'm going to actually give it a string that is the extension of the route. So let me talk about that for a minute. We have this route here that says that everything in this Camps is going to start with api/camps because that's the name of the controller. This HttpGet says we're going to do a GET, but the route is fine, we don't need to extend it. Here, we're just going to say moniker as a name. This will be a route value that's going to be after a slash after the controller. And it's going to take this moniker and bind it to this string called moniker. And that way we can actually make this work. So, let me just create a quick try-catch. And I'll borrow this 500 error. See me do that a little, and I call that editor inheritance. Not sure I would suggest that in every case. But let's go ahead and get our result by using the repository again, GetCampAsync. And this is going to ask you to get the moniker. So we'll just pass it in there. And of course it's async, so we need to use await here and then convert our method here to async and then wrap it with a task. Here, we can then check if result is null, we can return NotFound. Right? Otherwise we can just return result using our mapper to map to a CampModel. So we'll do the same thing that the map did here except it's not taking an array of camps and converting it to an array of models, it's simply taking an individual camp and turning it into an individual model. So if we run this and head back into Postman, let's go ahead and change this. I'm actually going to duplicate this tab, because we might need to come back to that later, and I'm going to change this to be ATL2018. Now that's the moniker that I know we're using. And it should execute and give us just the object that represents that Code Camp. This will still return an array of Code Camps, we happen to only have one right now, but what we're doing here is returning just the item that is inside that Code Camp. Make sense? And the trick here is that we added the moniker as a part of the route that could be then mapped to the input variable inside of our database. So it's important that the name we're using here is mapped to this. And a route value here on its own is assumed to be a string. If we had another moniker that need to follow a certain pattern, like if this happened to have been an integer, there's a class of ways to make sure that it matches both the type and the name. And so, if it was an integer we could actually use this :integer to say make sure it's an integer. And there're a number of these for different types. But of course, we are using a string so we're not going to need that because it's essentially going to take any string that's valid. Now let's talk about including additional information that may not actually be part of our entity. </p>
                </div>
                <div><h3>Returning Related Data</h3>
                  <p>
                    So now let's talk about returning some related data. When we look at the entities for Camp, we'll notice there is an object here called Location. Now, even though the database thinks of it as a separate entity, we really don't want to necessarily think about a camp as being separate from that. And there're a few ways we can represent this. We could return Location every time we return a camp. We could certainly do that. We could copy some of the location data directly onto the CampModel since that better represents maybe what we want. Since it's a really one-to-one relationship, we could probably do that. Or we could optionally include the location information. And I don't really like that method either. So, what we're going to do is instead of making a Location model is we're just going to extend our CampModel with the location information. So I'm going to go ahead and grab these pieces of information because these are pieces of information that anyone using a camp will probably need. They are pieces of information that are going to be exposed to any users that might be needing to go to the camp. And I'm just going to copy them here. And AutoMapper has sort of a nice facility, and that is if we just prefix each of these with the name of the object it'll actually automatically bind them for us. So this is nice information to have. And so all we've done is add these properties to the model. If we go back to Postman and just execute this again, we'll see it now is bringing in all that relevant information. In fact, it's going to be relevant everywhere because we're making it part of the model. We're making it part of the contract to the user. Now you may not like these names at all. And so there's actually another way to do this. The other way is to actually look at the profile. The way that CreateMap works in AutoMapper is it's going to allow us to create the default map, it's going to attempt to match all the properties in the way we want, and then it's going to allow us, with a fluent syntax, to make exceptions. So, we'll be able to call ForMember. Here, we're able to make an exception for the CampModel when it tries to be mapped from the Camp. So let's go over to our model for a minute, and let's just change VenueName to just Venue. Right? We just want to simplify to the LocationVenueName. And so here, I can include a small lambda so I can pick the property. And you'll see that this is in fact a CampModel that it's picking from. And the second parameter here is another lambda. I know, we start to get nested deep into lambdas, but it'll make sense in a second. And here are the different things I can do. I could decide to allow nulls, I could do an explicit expansion, ignore, which is a very common case here, but I'm actually going to do MapFrom. What MapFrom lets me do is say where is this actually coming from. And in the same way, we'll do a third lambda that is essentially going to say I want to get this from Location.VenueName. So I'm saying that when you find Venue, go look for it on the resulting Camp object by going to Location and VenueName. And I could do these for all the properties if I wanted to. I want you to see you can make AutoMapper do the default behavior, and then when you run into something that isn't automatically dealt with out of the box you can make those exceptions. If we build this again and execute this again in Postman, we'll see we now have venue, and it is binding from that same property that we had been binding from LocationVenueName earlier. And because it's in the profile, it ends up being used throughout your application. You don't have to make each of the APIs really think about this. And it becomes this way of mapping from a camp to the model of that camp. Let's take a look at query strings next.
                  </p>
                </div>
                <div><h3>Using Query Strings</h3>
                  <p>Now let's talk about how we can use query strings. Back in Visual Studio, let's go back to the CampsController, and let's go back to that Get where we're getting the array of CampModels Because there's actually an optional parameter to the repository API that says should I include the talks for this camp. And by default, it says false. So instead of just saying true here, what we'd really like to be able to do is have a parameter. Without changing the URI, we just said includeTalks as a Boolean. And we'll even give it a default value of false. The default value of false is important because this allows us to have parameters that are mapped from query strings. Now by including it false it means that the query string may or may not exist. And that's sort of the nature of query strings. They're different from the main part of the URI because we want to be able to take query strings and add them to add new control to the query for our users. So it may be that sometimes they want to get all the camps to just show a camp list, sometimes they actually want to get them all so that the user can see all the talks that are at different camps. So we want to make it optional, and we probably want to make the easier thing to be the default. So I'll take this includeTalks and I'll put it and pass it in to our AllCamps. Because remember we're returning a model, so we're going to have to change this to support our model being shown. The way we do this is, unsurprisingly, we create a new model for Talk. And we can do the same behavior where we look at the Talk class, and we'll just copy only the properties that are actually required. We're going to start with these three, Title, Abstract, and Level. We'll get to Speaker in a minute. And we're not going to use Camp here because that's going to be a link back to the original camp, and we don't really need that in the API. It's going to be very confusing. Because remember we're talking about creating a model that can then be serialized out through the API, and having a circular reference like that is sure to get it confused. Well let's copy those properties here. And then in our CampModel we're just going to add a new property here for ICollection of TalkModel. And I'll just call this Talks. So, all I've done is added to the model here. I haven't changed the way we're doing any of the other code. And if we send this now, we're going to get the camp, but the talks are going to be empty because we didn't include the query string. So here, we can say IncludeTalks=true. And now the talks will actually be returned for us. These are the two talks that we have in our sample data so far. And so this gives us that ability. But let's take it one step further and include the speakers as well. So we come back to the TalkModel, let's create a public property for SpeakerModel, and we'll just call it Speaker because we don't have more than one speaker for our talk. In fact, if we come back to Talk you'll see this is a one-to-one. So to get the SpeakerModel working, we'll just go ahead and create a SpeakerModel, and then in Speaker we're just going to grab everything but the ID. So if we've done this right, again we've just added these to the models, and send this with the IncludeTalks=true, we'll now see we have the talk, and we have all the information on the speakers as well. And so this becomes the contract with your user. Not just this flat entity that you're returning, but also the information that they may or may not need for the rest of this. So each of those models becomes a contract with the user. You're going to have to do some things to make sure that the talks and the speakers are identifiable in some way so if someone does want to update it. So far I haven't really done much except maybe title or abstract might be unique. So it might be useful in the case of these models to actually include the IDs. And I'll do the same for TalkModel. That way we can actually identify them by what they actually have to be. Make sense? Let's talk about one more thing, searching through your API. </p>
                </div>
                <div><h3>Implementing Searching</h3>
                  <p>
                    Now let's talk about searching. Let's go back to our controller, and I'm going to add yet another GET here. And I'm going to do that by just creating a new, and I'm going to need the async. Because we're going to be using the repository, we can pretty much guarantee it's going to need async. And so we'll start with our task of ActionResult. And we're going to return CampModel array from our method because we're looking for one or more camps that follow some sort of mechanism. And I'm going to call this SearchByDate for now. And I'm going to take in a DateTime, and I'll call it theDate. And so we go ahead and say HttpGet. We're going to include search as an extension to the URI so that we can search against the CampModels, and we're going to accept in a date. This date is going to be a query string unless we specifically match it here and say something like theDate as the value we want here. But instead of doing that, we're just going to use a query string since queries feel like actual queries. I'm also going to include here the Boolean for includeTalks and also turn that off because we want to include the talks even if we return the events happening on the same day optionally. So let's do what we've done before. I'll create a try-catch block, I'll copy the failure, and then inside the try we'll just use the repository. I'll say we want the results, and the results should be await _repository.GetAllCampsByEventDate. And just pass in that date. And we can actually pass in the includeTalks as well since we're already getting that. And if the results.Any, so if we don't have any results then we can just return NotFound. The assumption is that if you look for a date and it doesn't find any, we can return an empty array or we return a NotFound, which I find a little bit more satisfying. And then we'll just use the mapper again to map to CampModel array and then pass in the results. Make sense? Over in Postman, let's go ahead and duplicate this tab again. In here, we'll type in search? TheDate, and I'll give it a date that I'm hoping is going to be right. And I'll say 18 to get the one we have. And there we're returning it. And what if we ask for a date that wasn't correct, like the 17th? Actually, see this is now returning 404. And that's sort of the style of API you want. You may want to just return the empty array or you want to return a 404. I think not finding any camps based on that day might be the right thing. When we look at the code, what I'm trying to do here is allow search to have different query parameters. So I might create one or more of these based on the different kinds of searches I want to do, by name, by moniker, by location city, by whatever. So, it gives you a sense that you can still search through the API, but it just allows you to have some flexibility about how you go about that. Let's wrap up this module.
                  </p>
                </div>
                <div><h3>What We've Learned</h3>
                  <p>What have we learned so far? We've talked about using return types to handle errors in really in an HTTP way. So using status codes instead of just letting exceptions be thrown. We talked about using the ActionResult and the IActionResult so that however serialization is supposed to happen it'll happen outside of the controller. And I also showed you how you can use query strings to do things like declaring different formats or doing searching or including or excluding certain information like we did in the example. Let's head to the next module where we can learn how to actually modify data. </p>
                </div>
              </div>
              <div><h2>Modifying Data</h2>
                <div><h3>URI Design</h3>
                  <p>
                    Now that we've seen how to expose data through the API, let's talk about modifying data. First of all, we have to think a little bit more about URI design. One of the concepts I want to make clear is that there is a relationship between the resource you're going after, in this example customers, and the verb you're going to use, GET, POST, PUT, or DELETE. GET, which we've been using, is about getting data back from the server, POST is for adding a new item, PUT is for updating an item, and DELETE is for deleting. But when we go ahead and do a GET, POST, PUT, or DELETE on the end for a resource like customers, I want you to think about what that should mean. So like we've done with the GET in the previous module, executing a GET against the URI is going to get us a list of those customers. If we were to do a POST against that resource, we're going to create an individual item. We're essentially telling it we want to add a new item to that resource, one that doesn't exist yet. PUT is going to allow us to update a collection of those items because we're pointing at this resource. And DELETE should give you an error. You should never support deleting all of a resource in this way. This is where using the navigation to individual items becomes more interesting. Just like we did before where we're doing a GET against an individual object, we should be able to get that individual item. But posting to that individual item shouldn't work. Right? If we're going to create a new item, we should do it at the customers level, not at the individual customer level. And PUT should work in both cases. We're only going to implement the update item in this case. Many systems go ahead and just return an error if we try to PUT on a collection of customers, but it is also valid to update the batch of them. But more commonly, you're going to be doing a PUT to an individual item. And then DELETE against that individual item as well should allow you to delete just that resource. So what I'm saying is that for the customers endpoint, the collection, we should get a list of the resource. For the individua, we should get an item. For a POST we should get that new item. It should be returning that new item. And if we try to do a POST against an individual we should get a status code. That status code should be an error code like a BadRequest. When you issue a PUT against a collection, you should only get a status code whether it succeeded or not. You shouldn't necessarily return the entire collection. But if you update an individual item, you should return that updated item. And then in the case of DELETE, you should get a status code if you try to delete the entire collection, which is an error, or you should get a DELETE with success if it actually deleted the individual item you were looking for. I think this will make more sense when we start to look at the code.
                  </p>
                </div>
                <div><h3>Model Binding</h3>
                  <p>Before we go ahead and implement the data changes, let's talk a little bit about how data comes into the server. We're going to do that in the form of something called model binding. Back in our code, I'm just going to open up our CampsController again, and I'm just going to create a new method down here. In the same form that we have for the other methods, we're going to say public async because we're probably going to be using an asynchronous method from the repository. And I know we want it to be a Task because it's asynchronous. I know we want to return an ActionResult because it is an API action. And I know that we want to return a CampModel or an instance of the newly created CampModel. And I'll just call this Post for now. To implement this, I'll just put a try-catch like we've done every time before. And I will again steal this status code. Again, this should be a more descriptive error. But just to get through this so that you don't have to watch me typing for hours and hours, we're going to leave it as that. And what we want to do in here is create a new camp. But how does the data get into this method so we can create the map from that? Let's go over to Postman and craft what should be our post. So if we go ahead and just duplicate this GET, and I'm going to change the verb to a POST, I'm going to post directly to the actual camp. But what I'm going to need to do is send some data, and this could be form-data formatted, it could be form-urlencoded formatted, but, like a lot of the code that's going to use our API, we're going to actually use a raw format of JSON. And I'm just going to hand code a tiny bit of what this should look like. So I'm just going to give it a name of San Diego Code Camp. And I'm just going to give it a moniker. And we could go through for all the properties here, but a moniker of SD2018 let's say. Right? This form here should match our CampModel. Just like it's an API to return the data to us, it should be this same form of the data to actually send to us. So back in here, let's go ahead and accept as a piece of data here CampModel. Now I'm just going to call it a model. And I'm just going to end this with a return Ok for now just so that our method will actually run. And so let's set a breakpoint here, and let's see if we can actually get this. I'm going to run this with debugging. And when you run this, you will get a warning about the async since we're not using async yet, but you can just ignore that for now. And let's go ahead and send this. It comes into our code, and we can see that our model here, it has sent us in a model, but it doesn't have any of our data in it. Now there're a couple ways we can solve this. There is an attribute here we can add called FromBody to tell it that we want to map the data that's going to be sent to us via a body. Here in Postman, we can see this is part of the body. Or if you're using ASP.NET 2.1 or later, like I am, I can also come up here and tell it that it is an API controller. This attribute tells the system a lot about what we want as far as expectations. And the first is it's going to attempt to do body binding because it knows it's an API. Remember this same code we're looking at here could be used to return views or HTML to the browser. We're telling it that we're really using this as an actual API. And as we go through, I'll explain some other things that this API controller magically does for us. But for now, let's go ahead and run this again and see if this changes that behavior. Back to Postman, let's go ahead and just send it. And we can see now our model has San Diego Code Camp and our new moniker. It doesn't have anything else because we haven't sent that information, so it's giving us a default value for it. And you had to bind what was in the body into this object because we've told it that this post is expecting certain properties. And if we had included, in fact let's do that, let's include, you know, something that isn't going to be important. Right? Some other piece of information accidentally. When we come in here, it's missing because it couldn't bind it to the type of class that we specified. So it is going to be lost. There are ways to validate that and do some other things, but for the most part you want this to be the contract. If someone puts in the wrong value, you want it to actually do that. Now that we know that model binding's working, let's implement this POST next. </p>
                </div>
                <div><h3>Implementing POST</h3>
                  <p>So now let's implement that POST that we started with the model binding. So let's stop the debugger, and let's actually make this happen. So, here we're going to rely on the model binding and the AutoMapper to help us do this a little easily because remember that this CampModel is going to include more information than just our individual object. So let's do this. Let's create our new camp, and we're going to do it by calling _mapper.Map from our model. So this is going to take the camp model and map it back to a camp. So this is the reverse of what that modeling code told us to do. And from here, we can just use our repository and add our new camp. And then we can check SaveChangesAsync, which is a method that's going to return a Boolean if changes worked. And then we can actually return the right data. Right? And at the bottom here, let's go ahead and return a BadRequest. If something bad happened that didn't cause an exception, in other words if this SaveChanges failed, then let's just fall down and tell it that we had a bad request. And so we might want to go ahead and just say Ok and get our data back. But, in fact, the POST method requires you use a different return value. And that return value is Created. Created is still a 200-range status code, but it requires you to say I created a new object and include something called the location, which is a URI for getting that new object from the server. And so, I'm going to start by just giving an empty string for the location. And let's go ahead and map this back again. Now that we've gotten the camp from the database, it might have additional fields that were generated by the database. So we're going to need to map our new camp back to our CampModel because, remember, that's what we're returning here. Now just like we've done before, we can just do that one-to-one mapping of it. So in order to create the link, what we really want to do is figure out what the URI is of our new object for this method, right, which is going to be getting an individual object. We want to be able to return the URI that represents getting it back from the server from the URI that's described here. Now I could certainly say because I know that it's api/camps and then whatever the moniker is. And that would work except that this becomes fragile. This is hardcoding the string, and what if later on we decide to change that? In order to do this, what we're going to actually do is bring in a new class. This is actually a class that's available only in ASP.NET Core 2.2 and later called a LinkGenerator. This is in the Microsoft.AspNetCore routing namespace. And I'm going to go ahead and initialize a field for it like we've done everything else. Now that we have the LinkGenerator, let's go back down to our POST and let's implement that. We want to be able to generate what the link is here, but we don't want to wait until we get into the SaveChanges because in case there's a problem getting that link we don't want it to accidentally add it to the database for us. So up here inside the try, I'm going to start by trying to get a location. And I'm going to do that by using our new LinkGenerator. And one of the methods here is GetPathByAction. This allows us to specify what action on a controller, whether it's this controller or another controller that I want to use. So I'm going to say GetPathByAction, and I'm going to simply give it the name of an action. And in our case, we're trying to do a GET by the action name of Get. Next, I'm going to need the name of the controller, which is just Camps. I don't need CampController, just Camps. So I'm tying it to the controller and the action on that controller. So I'm specifying which of those methods we need. And lastly, I need a new object of any route values. I'm going to use an anonymous type to just specify. In our case, if we go back up here, our GET for an individual camp includes moniker. If there were more than one input I could include more than one, but I'm just going to include moniker here. And I'm going to get it by saying model.Moniker. That moniker that was sent in. Let's make sure that the location is valid by just checking for string.IsNullOrWhiteSpace. And if it is null or it's empty, I need a location. So I'm just going to say return BadRequest could not use current moniker, which is pretty much the one reason this wouldn't work. Let's go ahead and debug this so we can see what happens. Over in Postman, I've got all this different data here. I'm just going to go ahead and press Send. And we'll see that it's generated the location for our individual camp. So, this is then api/Camps and then the name of the moniker. It's figured out what that is. And if later we change the routing value there it'll actually adjust to that change. So that's one of the reasons of using the LinkGenerator instead of just hardcoding those as strings. But if I press F5, we'll see our newly created camp is there. In fact, I've even got a 201 here for Created, so I know it's correct. And if I look at the headers, we'll see that one of the headers, if I make it a little big, is this Location header that points at that correct camp. Because we did Created and we passed that in, the subsystem knew that Created needed to set that header and do all the magic for that. So it's trying to be helpful to us about exactly how it should work. And if we go back to the getting of all the values by camps, so we can see now that we have Atlanta and we have the San Diego Code Camp. So, they're both actually in the data store now that we've added them. One thing we have a problem though is there may be pieces of information here that we have to have. And currently we don't have those. So let's talk about validation next. </p>
                </div>
                <div><h3>Adding Model Validation</h3>
                  <p>Now let's talk about validation by using model validation. Back in Visual Studio, one of the things we might want to do here inside of the POST is do things like if model.Name string.IsNullOrWhiteSpace to do some checking that the different parts of the model data that's coming to us are things that are required. But writing this code not only over and over again, but it can be a little clumsy. And this is one of the places where I really like using the model classes. So if we go down and look at the model classes, let's look at that CampModel, I could actually decide which ones of these are actually required and tell it. So, in our case, I know that name is required, and so I can add an attribute of Required. And this actually comes from System.ComponentModel .DataAnnotations to tell it that this model isn't valid unless we have that name. Same for moniker. Same for length. In fact, we don't want to say that length has to equal 1, what we really want it to say is that the range of the length should be 1 to let's say 100, just to be valid. We're not going to deal with events that are more than 100 days. And most of these others probably aren't going to be required because when someone creates a new camp model we may not know the venue or the location yet. And so, we want to be able to create the camp model without necessarily creating the other elements. But we could also use one of these collections of validation attributes. And even, you can write your own if you have specialized logic. But you might want to do something like StringLength. Okay, the name has to have a maximum string length of 100 because it would be silly to have an event name that's greater than that. And so you can use these rules that are part of the contract to the user to know and to validate whether these are true or not. Let's actually run this real quick, and go back to Postman. And let's look at our POST, and let's forget to put in the name. Let's just delete the name for now. And I'm going to change this moniker to MOO2018 so we don't create the same one over and over again. If I go ahead and send this, what we'll actually see is that information is being validated. When that model is attempting to model bind it's going to look for the validation rules that I've put into the model and return a BadRequest with a list of the errors for the user to fix. Now what's interesting here is that this all comes out of this ApiController on the top of the controller. You can actually turn that behavior off to where you can check the model-binding behavior as well. If you turn that off for some reason, you could also come in here and say if ModelState.IsValid, and then do something about that validation that may be more customizable. But I'm finding that using the default behavior is pretty good. And so, by having most of the validation that I want directly on the CampModel is great. And it's great for these sort of simple, weird sort of errors. And I'll call this the South California Camp. We need to put the name of the field as well. And once I put that in, it now works again because we've passed all the validation rules we specified. One of the rules we can't really specify in this way is actually the moniker. If you look at the database as it exists right now, let's go ahead and issue a GET on all of these, we'll see that at the bottom is our MOO2018, but there're a bunch of these San Diegos because of the tests we did. Because this moniker is supposed to be unique, we really want to have a way to validate that. Now while we could set up the database to do that, you also want the code in your business logic as well. So back over in the API, let's go ahead and actually do that. Let's just say let's get the camp and let's use the repository to just GetCampAsync. And I'm going to do it by passing in the model.Moniker. So the moniker they're giving us I'm going to get. And if the camp doesn't equal null, so if it actually found one, then we can go ahead and return some better logic, which is like BadRequest moniker in use. Now this isn't going to fix any of those duplicate San Diego ones And if we build this, of course we'll see that I have messed up the code, and let's just say existing here because I've used the word camp down here. Let's go ahead and build it. Now that I have that rule inside of the API, we'll see now that it's going to return a BadRequest. And I'm sending back that piece of data to the user to say, oh, that moniker's in use. So let's go ahead and make it a MOO2019, and now we can get that again. Right? It's going ahead and creating the new element now that we validated everything we need to. Moniker is unique plus the other data that is required for us creating a good and valid camp. Now that we've created a camp, let's talk about updating one. </p>
                </div>
                <div><h3>Implementing PUT</h3>
                  <p>Now let's implement updating a resource by implementing the PUT verb. So back in Visual Studio, let's create yet another method or action if you prefer. And again, we're dealing with the repository so I probably need async and Task again. And I'll do ActionResult. And in this case, I'm going to return a CampModel, just like we've done before, because we're going to return the updated version. And for Put, I'm going to want two parameters because remember we can't put on the collection, we actually need the moniker here. So let's go ahead and put HttpPut here, and tell it that we want the moniker. This is identical to what we did in the GET, but of course we're saying that this is a PUT now. But I also need a CampModel to be passed in with the changes that I want to make. And I'll put a try-catch, copy the 500, and let's go ahead and add a BadRequest at the bottom so that if it falls through actually successfully updating it, it will continue to be used. And what's interesting here is that this CampModel is going to go through the same validation for this PUT as it would for the POST. So what are we going to do first? We need our old object before we can apply the changes to the new object. So we're going to go ahead and get the oldCamp, and I'm going to use the repository to do it by just GetCampAsync. And I'm going to do it by model.Moniker. Right? We've done this code before. It should be pretty comfortable. But if it doesn't find the oldCamp that equals null, we can just return BadRequest or NotFound. But in our case, I'm going to say NotFound because what we tried to update didn't exist. So NotFound could not find camp with moniker of moniker. And I'm using this dollar sign version so I can just insert what we want here. And in fact, instead of this being model.Moniker, let's use the moniker that was actually sent into the PUT. Right? So we've done the bare minimum here. We tried to get the oldCamp. And what we might want to do is just say oldCamp.Name = model.Name. Right? We could do that mapping between them, but that's not interesting. What we really want to do is just use the mapper to do it. And this is another place where the mapper can be really useful, not just in mapping to create a new object that matches that, but to apply it. And we can do that by sending the map. And we're going to start with the model, And then we're going to put the oldCamp as the second type. We don't need any templated parameters because it can infer them from the two types here. So it's taking the data here and applying it to the destination here. So we're effectively doing what we want to do. We're getting it from the database, we're applying those changes, and then, surprise, surprise, we're going to say if _repository.SaveChangesAsync. Then we can just go ahead and return _mapper.Map to CampModel because, again, we still have the camp that may have been changed by the database or maybe the result of the merge here as we're going to then convert our oldCamp back to our CampModel. Now PUT doesn't require you to have a special return type. Ok, or 200, is the correct return type. And because of the way we're using ActionResult, we can actually just return this without even putting an Ok around it. Okay now let's try to make this update in Postman. And I'm just going to duplicate our POST tab here. And let's go ahead and put SD2018. So let's update the one we just created, and change this to a PUT. And in this case for our body, instead of it being this body, let's get it from our POST and copy our entire object that we got because normally when you're doing a PUT you're going to be putting the whole object back in. The idea of PATCH is something that would support patching just individual fields, but that's not really what we're doing. So let me replace this with our original object. And let's just change a couple of things. Let's change it to be three days long, and let's go ahead and give it an address. So we can see these updates actually happen. And I'll also call this San Diego, and go ahead and put in the California. And let's change a field as well to make it a more valid postal code. And let's go ahead and put USA in here. And if we send this now, it's going to take this entire object and apply it. Now our whole object has now been updated with these new values. In fact, if we come back here to getting just an individual object, and I'll change this to SD2018, we can see that's actually been stored and updated directly in the database. Now that we can create and update an item, let's talk about deleting it. </p>
                </div>
                <div><h3>Implementing DELETE</h3>
                  <p>Now let's implement the DELETE. Back in Visual Studio, yes, yet again, we're going to create a new method. And we'll start with public async because we're going and using the repository. Task because it's async. ActionResult because we want to return a value. But in this case, I'm just going to say IActionResult because we're only going to be returning a status code. There is no body once we delete an item. And let's just call it Delete, and let's include that moniker. Right? There is no body to map to or get because the moniker is going to see if it can find it in the database and delete it. It's going to do the same thing we're doing in PUT and add the verb, and then include moniker since that is going to be required here. Do our try-catch. Do our editor inheritance. I know you've seen it a lot by now, and you're probably sick of the joke, but go with it. It's going to be fun. And we'll do the same thing we did before. We'll go ahead and get the oldCamp. We'll include the moniker. If the oldCamp equals null we'll return NotFound. And then we're going to go ahead and delete it. How do we delete it? Now that we've got it from the database, we can actually just use the repository to say _repository.Delete our oldCamp. And again, we're going to do _repository.SaveChangesAsync to tell the repository we want to update that. And if it's successful it is going to return Ok. We deleted it. We're all good. What's interesting here is this DELETE will work depending on what the database is supposed to be doing. Your underlying database may or may not be set up to delete all associated objects, which is probably what we want to do here. We don't want it to delete in case there's still talks and there's still speakers and those sorts of things. We might want someone to go through and actually delete all those items individually. But that's business rules that you're going to want to be put in here depending on your use case. Because we don't have any associated objects yet, this is exactly what we want. And I want to return a BadRequest in case something bad happens here, in case the database doesn't change and it is found for some reason. Right? Let's go over to Postman, and let's duplicate this tab again. And I'm going to change this to a DELETE, and I'm going to go ahead and delete that San Diego one. Now, this has a body, but it doesn't need to. Right? In many cases it shouldn't. Anything in the body is going to be essentially ignored in a DELETE. And so if we send this, we'll see we get an Ok, which means that it was actually deleted. How do we know? Let's go get all of the objects, and we can see we're back down to just the Atlanta Code Camp. So let's validate this all the way through. Let's go ahead and post our new object as San Diego. And so it says it's created it. Let's go get the San Diego one to make sure it's actually stored. Yep. Let's go make a change to it, which is why I kept a lot of these tabs. Make that change. Let's make sure that kept by going ahead and issuing the GET again. Okay, those are there with the changes. Notice length 3, and we have the full address. And then we'll go ahead and delete it. It says OK, so it deleted it. And if we do the query again, it should be missing. So we've created an end-to-end API that will deal with one single resource. This is exactly what we want to do. You may have other operations in here. You may want to implement batch updates, you may want to be able to handle some different situations like being able to update related objects as well, but we're not quite there yet. So let's wrap up this module. </p>
                </div>
                <div><h3>What We’ve Learned</h3>
                  <p>
                    So what have we learned in this module? I showed you how model binding can allow us to take the data that is in the request and map it directly to .NET objects. I've shown you how to use the same models that we created in the last module to include basic validation into your models. And I've shown you how to match those verbs to the operations so that you can create an API with the same URI that does all the different sorts of operations you're going to need against these resources which happen to be in our example's database entities. The fact they're database entities and what they should look like is actually separate from what we're doing in the way of using models to expose the data contract with the actual user. Next, let's look at related controllers. Let's start to look at the talks for a particular camp and how we would build that as an API.
                  </p>
                </div>
              </div>
              <div><h2>Creating Association APIs</h2>
                <div><h3>Introduction</h3>
                  <p>
                    In this next module, let's create some association APIs. What I mean by associations are APIs that are related to other resources. We've talked about this before with the idea that we have some camps, those camps that you can get an individual camp, and then to be able to get the related talks for that camp, and even an individual talk inside of that camp. In order to do this, we're actually going to segment this into two controllers. The existing controller we've already written, the CampsController, and then we're going to build a new one for dealing with talks. Even though you could build these all inside the CampsController, I find when you're dealing with different resources to segment your controllers based on resource even if they're related in this way. Let's see what that looks like.
                  </p>
                </div>
                <div><h3>Create an Association Controller</h3>
                  <p>
                    So let's go ahead and create an association controller. Back in our project in Visual Studio, I'm going to just create a new file called TalksController. And much like we did with the other controller, I'm going to derive it from ControllerBase, and I'll bring in that namespace of AspNetCore.Mvc. And I'm going to add that ApiController attribute. And go ahead and just create a constructor because we're going to need those same dependencies. ICampRepository, which will be in our CodeCamp.Data namespace. And I'll just use the magic refactoring to go ahead and create the member. We're also going to need the IMapper interface from AutoMapper and a LinkGenerator again, just like we did before. And now we have the beginning of our class, and we're going to want to create that first action. So I'm going to create public async, since we're going to be using the repository, Task, ActionResult, of type probably our TalkModel array. Bring in that TalkModel namespace as well, and just say Get. So here, we're going to want to go ahead and get the list of models that are related to the camp. The idea of talks outside the camp may be useful, but that's not what we're trying to do. We're trying to create a controller that's related to another part of the route. So let's do that by specifying the route for our controller. So let's, if you remember, add that route attribute. And then we're going to just construct our API. And our API could be just talks, if we were going to expose indirectly, but because this is an association controller, or a controller that's associated with another part of our URI, I'm going to actually say camps, just like we did before. And here, I'm going to say the parameter. And what is that parameter? It is the moniker, if you remember right, and then talks. Right? Because in essence what this controller is doing is looking for the talks that are related to the camp. So if we just add to our action here just HttpGet, it's going to use the same URI as the base part of this TalkController. So if we were going to build this like we were the others, we'd start with the try-catch block. And here we just want to return a StatusCode for StatusCodes, bring that in, of status 500. Right? Just like we did before. And here, we're going to want to go ahead and get our talks. Right? So we'll go ahead and use the repository and GetTalksByMoniker. Oh, in order to know what talks belong to a camp, we're going to need to know some information. And what is that information? The actual moniker. Remember, this moniker is already part of our route here, so all we need to do is include, as a parameter, the moniker. It's going to map this moniker to the part of the URI that is specified in the route here. So we're going to need this moniker, in fact, in every action we build, unless we completely override the route, because this is going to be required in each and every call we make. So let's go ahead and include the moniker, and we'll put await on here. And we'll just return using the mapper, just like we have before, map to TalkModel the talks. Right? Nothing magical about any of that. That should just work. So let's go ahead and see this in Postman. So over in Postman, I'm just going to take our GET here, and I'm going to duplicate it. And for our camp, I'll just include atl2018, which I know is the built-in one that was included in our project. And I'm just going to say talks. Right? It's still just a GET using the extension or the URI that we've been using to look in an individual camp. Let's go back and run this. Make sure it actually builds. Then we can go ahead and send it again. And there are our talks that are related to our camps. Notice, we're not returning any camp information here, we're just including the talks themselves. So we've now built the API to just get all of the talks for this particular camp. Let's see what it looks like to get an individual talk inside that camp next.
                  </p>
                </div>
                <div><h3>GET an Individual Talk</h3>
                  <p>So now let's get an individual talk. A lot of the code we're going to be building here will be similar to what we did for the camps. And of course, we're going to have that little bit of difference that's going to be related to it being an association controller than just an entity controller or a resource controller. So let's go ahead and do the same thing we've done before, async Task ActionResult. Of course, this time we're just going to return an individual TalkModel. And then we want to be able to get this TalkModel. And what do we need? We of course need the string moniker again because that's going to be key to being part of that top-level route. But we're going to get an individual one. So what we really want is to also include a GET with another parameter. Right? Because we're going to be looking for inside of this camp get this individual talk. And in our case, we're actually just going to use the ID. So we're adding the individual identifier just like we did before. That means we're going to need another property. So this name is being bound to this id here because of the name, and we're just using a descriptor here to say please make sure that only IDs that are actual integers, that are actually numbers, are going to be mapped to this. Otherwise, it won't make any sense on finding this mapping. And then everything is pretty similar. I'm actually going to do a little copy and paste here except that what we're going to do here for GetTalksByMoniker is actually GetTalkByMoniker. And this is going to require us to pass in that id as a second parameter. And then, of course, our map is now going to be to an individual item. Make sense? So we're doing effectively the same thing. The only thing that we're really interested in is that your GET needs to include the ID for the individual object you're looking for in this relationship. But it also must include whatever parameters are up here in the main URI route. Because moniker is going to be here, we need it each and every time. I know I'm repeating myself here, but it's an important concept that I want to make sure you can get. If we build this and go to Postman, we should be able to --- Let's go ahead and duplicate this tab again, and let's just add to the URI /1. Now we're going to get that individual object. Because remember, this has two talkIds here, 1 and 2, so we should be able to go ahead and get either one of them by just changing the URI to include that information. And so we're giving ourselves the ability to do both in getting an individual talk that is part of that camp. Let's see how to create new talks for the camp next. </p>
                </div>
                <div><h3>POST a New Talk</h3>
                  <p>Now let's create a new talk by posting to the same controller. So here, let's make ourselves a little more room, and we're just going to create a new action. And because we're going to be dealing with the repository, it needs to be async, of course, Task ActionResult. And what are we going to return? We're going to return a TalkModel from our new action. And so in this case, we'll just call it Post. And just like the rest of the controller, we're going to need that moniker because again we're creating a new object in the context of a camp. We're not creating it just willy nilly that could be assigned to any camp. And what are we going to need in order to create it? We're going to need a TalkModel. Right? The data around the model, and I'll just call that model. Now, because it's a POST, we're actually applying it to the collection of talks so we don't need an ID here, but we will need an HttpPost attribute here. But we're not going to include any information about the route because we're actually going to be posting to this same URI. So how do we implement this? We're going to start with this regular try-catch, and I'm going to borrow that status code again. Again, copying the status code result isn't a best practice. It's just to get us there quickly. And so, what are we going to want to do here? We have this TalkModel, and we'd like to be able to go ahead and add it to the database, but before we can do that we're actually going to need to get the camp. So we're going to say await _repository.GetCampAsync. And what are we going to do? We're going to supply that moniker. The reason we're doing this is that we haven't validated that this moniker belongs to a valid camp. In the case of GET, we don't need to worry about that because it won't return any data if the camp doesn't exist. But in our case, if we're going to add something to the camp, we need to know that it exists. And if camp equals null, in other words it didn't find it, we're going to return a BadRequest. We could do NotFound, but it doesn't make sense in this case. What we're actually going to do is say camp does not exist and be done with it. Right? A good way to guarantee that the data they're sending in is valid. If the camp doesn't equal null then we can go ahead and actually do this. We can go ahead and say I'm going to take my talk, and I'm going to use the mapper to map to a talk from our model. Before we actually add this to the context, what we can do now is take our talk and attach our camp to it by taking the camp that we found here and saying that this talk belongs to this camp. And then we can just, in our repository, add our new talk. And because the camp was related to it, it's going to do that fix up in the database for us. It's going to make that foreign key relationship actually work. But here we can just go ahead, now that we've done this, we've added our new talk to the repository, we can just say _repository.SaveChangesAsync. So if it succeeded, we're going to go ahead and send the data back. Otherwise, we're just going to return a BadRequest failed to save new talk back to the user. See if you remember back to the last module, one of the things we needed to do was create that URL. That URL is binding us to the individual talk on the server because we need to send the location back not just a new object. And so we're going to use that linkGenerator to do it. And here, we'll GetPathByAction. And like we did before, we're going to pass in that HttpContext and then the name of the action, which in our case is going to be Get. And then we need to give it a new anonymous object that represents the parameters to that GET. Let's break this up into three lines so we can read it a little better on the screen. And then we're going to set the values for our LinkGenerator, just like we did before, by just saying moniker and id equal talk.TalkId. This is essentially saying we want the first parameter to be moniker, but we don't need to assign it because it knows that if we just put a name in here that it's going to put a name with the same object name. In the second case here, because TalkId is different than a local variable, we need to go ahead and assign it. But essentially, these are the parameters that will go into the GET for an individual object. Right? We have to figure out a way to pass these in. Even though they're not all in this ID, they're somewhere in the URI. And then we can actually return Created with the new URL, and then use the mapper, just like we've done before, to map from talk to TalkModel. Right? Because that's essentially what we're returning is the TalkModel. Even though we've converted our model into a talk, we want to convert it back to a TalkModel and not just take the input model because this save operation will likely change some pieces including things like the actual TalkId. Let's make sure I typed it all in well. And let's see what this looks like in Postman. So let me go ahead and just duplicate this tab for our individual talks because we're going to want to actually change this to a POST to the actual endpoint for all the talks for a specific camp, not an endpoint for the individual talk itself because we're creating a new object here. And let's go into our body, and let's make sure it's raw and JSON. And I'll actually just borrow our last object here from the GET. So let's get rid of the talkId since we're not actually going to send that ever, and let's write a new title. And we'll just call that Building APIs since that's what you're doing. Building APIs can be fun. And we'll even change the level to 300. But we get down to the speaker, and we'd like to be able to actually specify a speaker here. Because remember, we're getting the speaker when we're returning that data, but we'd like to be able to actually specify a speaker here. So what we're going to do is just say SpeakerId is, and let's just say 1 because I know that's a valid speaker ID. We could include an entire speaker that we post in there, but for now that's going to be good enough. A speaker that just includes the actual ID that we're going to need. But we haven't accounted for this in our code. So back in our code, we're going to need to come in here, and before we add it to the camp we're going to need to actually add the speaker as well. So let's go ahead and say our speaker equals await _repository.GetSpeakerAsync. And this is one that we'll just go ahead and get a speaker ID. And where are we going to get that? We're going to get that from the TalkModel. So we're going to assume that the TalkModel is going to actually give us that by saying Speaker.SpeakerId. But before we can do that, we're going to have to just check and make sure. So if model.Speaker equals null then return BadRequest Speaker ID is required. Right? We can't add a talk if we don't know who the speaker is. If speaker equals null, we're going to also need to return a BadRequest. Right? Speaker could not be found. Again, not a 404 because we're not trying to tell them we couldn't find some object they were looking for. We're telling it that they haven't given us enough information or that they've given us bad information. But if all of that goes okay then we can simply say talk.Speaker = speaker. And when we add the talk to the repository and eventually save it, we'll include that speaker information. So let's actually debug this so we can see what's happening because we talked about a few moving parts because we're starting to get into more details around it. Now some of this information that we're doing here might be something that would be hidden behind the repository. That's certainly possible as well, but I want you to see the moving pieces. So let's go ahead and try to post this. And there it's going to attempt to get the camp. Luckily, we have given them a good camp so we get passed them. And then we go ahead and map our TalkModel back to a Talk, and it throws an exception. And in fact, the exception is unmapped members were found. It couldn't figure out a way to map a TalkModel to a Talk. Well that's weird. Right? Let's go ahead and stop this for a minute. Let's go back to that camp profile where we had this. Oh, we haven't specified it. And what's interesting is that out of the box, by default, if you have members that happen to be entities or classes or models it will attempt to do the inference between the types you want. And that's why we've gotten these type-to-type models to actually work out. But because we're actually trying to do a top-level mapping now, we're going to need to go ahead and create profiles for them. In fact, we'll create it for both. We're going to create a map from Talk to TalkModel and then reverse that map. I'm not going to put in any exceptions now. Just create the map. And because we know we probably are going to need it at some point, we're going to need to do a Speaker to SpeakerModel and reverse that map as well. And if we've done this right, let me go ahead and move the breakpoint down to the mapper since we know we're getting that far. And let's try to send it again. We should be able to get that good talk. And we can see that the camp is null. It has attempted to put in a speaker here with just the speaker ID, which is fine in some respects, but we're going to replace it in a minute because we want it to be an actual speaker from the database. And the same with camp. The rest of our pieces of information have come in, and the TalkId of 0 has been just defaulted. And 0 often tells the database to go ahead and assign one anyway. So let's assign that camp. Let's see if we can get a speaker. We found the speaker. We're going to assign that speaker. We're going to attempt to add to the repository and see if it'll actually save it. So it's now in the database. linkGenerator should go ahead and generate a good URL, which is out to our third talk, and then return it correctly. And so, one of the reasons we're returning the raw talk and not just the model that came back is that we need this newly assigned ID of 3. In here, it's going to include the entire speaker information in what it returns. Now, I told it just speakerId 1, but that's going to map to whatever it found in the database, which happens to be me. Right? This also implies that maybe we want these to return the speaker information as well. Because we have some of the logic, we could go up here and just actually say true here. Instead of like what we did with the GETs earlier in the camps, I'm just going to tell it, you know what, I always want you to include the speakers. That's just a business decision I'm doing. This optional argument for IncludeSpeakers I'm just going to ask you to do in every case. We could add the query string and add the ability, but because it's a one-to-one relationship, often that is what I'm going to want it to do. So back here in Postman, if I come back and send this GET, we can see we're going to get the speaker. And if I go ahead and look at all of the talks for this camp, we should now see a third one. That includes the one we just generated with the POST. Make sense? </p>
                </div>
                <div><h3>Add Validation</h3>
                  <p>So now let's add validation to our TalkModel so that we can make sure we're getting good, valid information in there. So we've walked through our POST here, and it actually worked except for one thing, we don't have any rules about what the talk actually looks like. So let's go down into our models, and open up that TalkModel. And let's go ahead and make sure that we have Required for our talk name. And I'm actually going to put in a StringLength here also to say that the title can only be let's say 100 in length, so that we're doing a couple different kinds of validation here. We'll do the same for abstract. And for StringLength here, I'm going to give it a pretty large maximum, but I also want to give it a MinimumLength of about 20. Right? I don't want it to be too short. And I'll also include in here not a Required, but actually a Range. This is going to allow us to say the minimum value is 100 and the maximum value is, let's say, 300. Right? We're only going to accept beginner, intermediate, and advanced, and so those levels should be 100-300. We'll probably want to do better validation here of actually checking those three values, but I'm not going to go through that because that can get complicated. I want you to be able to get through this course. But having this validation means --- If we go back over to Postman, and let's make sure that the abstract is too short. And let's make this version of it use the other speaker. And let's say Advanced here just so we have a different name. Then let's go ahead and send it. We're going to see that, hey, the Abstract field has to be 20 or 4000. So it's giving us those errors for us. And we can go ahead and fix this. Go ahead and send it. In this way, we should go ahead and get that new talk as well. So just like we were doing before, we can use validation in those models in order to guarantee that the kind of data we're going to get back is going to be of a high quality. So next, let's go ahead and implement PUT. </p>
                </div>
                <div><h3>PUT to Update a Talk</h3>
                  <p>Now let's update a talk. Back in the TalksController, let's go ahead and create a new action. Again, async because we're going to be dealing with the repository. Task, ActionResult. This time we're going to return a TalkModel, just like we did in the last one. And I'll just call it Put for now. And we know that we need the string moniker. And we're also going to need the integer that is the ID of the talk we're going to update. Right? And we're going to do HttpPut just like we saw before. And here, we're going to need to include the ID for the individual talk. Again, this is identical to what we did with this second GET. Right? This is about an individual talk, and PUT should be about an individual talk. So we'll do our try-catch again, and then again I'll copy this status code. Again, not best practice to just copy this over and over again, it should be more interesting than that and obviously have logging. But to get you into this, remember that we actually need the data for the update. So we're also going to include a TalkModel, which is the model here. Right? And just like the POST, this TalkModel will be validated as it comes in. So the first thing we need to do is instead of getting the camp what we actually need to do is get the talk. Right? This is the old talk from the repository. So I'm going to say await _repository.GetTalkByMoniker. So we're going to give it that moniker we were brought in and the ID we were brought in. And I'm going to say true to get those speakers because one of the pieces of information that might change is who's doing the speaking. Right? If talk equals null, that means we haven't found it. We can go ahead and return a NotFound. Right? In this case, we're saying we want to update this individual talk, and we're saying we didn't find the talk so it wasn't found. Now that we have the talk, we want to map our changes from TalkModel into the talk. Just like before, we're going to use our mapper to map from the source, which is going to be the model, and we're going to map it to the talk. So it's going to copy the properties from here into here. And then we can simply await _repository.SaveChangesAsync because we've pushed the changes into the object we got from the repository. So we can tell it to go ahead and save those changes. Then we can just return _mapper.Map to TalkModel our talk. Right? So this should work just as is. Right? But it actually won't. It's actually going to be doing something we really hate, and that is this _mapper.Map is going to map anything in the model to anything in the talk. And that includes the camp and the speaker. So because we're including information, especially as it relates to nullifying what is on the camp or the speaker in here, we're going to accidentally sheer them off. And so, to fix that we're going to actually go back to the profile, and we're going to say when we map from the TalkModel to the Talk, so after the ReverseMap, we're going to say ForMember t.Camp. We're going to actually tell it to ignore the mapping. Not ignore the value, but just don't map it in this direction. And the reason we're doing this after ReverseMap is we only care about it going from TalkModel to Talk. From Talk to TalkModel we want it to do the mapping. And so, if this were about Talk to TalkModel, we would do it before the ReverseMap. But we're doing it after on purpose. And we're going to do the same thing for Speaker because we don't want any of those properties that could be accidentally overwritten, especially the relationships, to be dealt with at all. If we need to do the mapping, we can do them by hand. And in fact, I'll show you us doing them by hand in just a moment. So now that we're telling it don't sheer off the camp or the speaker just because they weren't specified in the TalkModel, let's go back to the TalksController, and let's add the ability to do the speaker. So, if model.Speaker does not equal null, so if someone included the speaker on purpose, we're going to make an assumption. We're going to get the speaker by calling the _repository.GetSpeakerAsync. And what are we going to use? We're going to use model.Speaker .SpeakerId. Right? Whatever it is, we're going to manually override it. If speaker doesn't equal null, in other words if we found it, then we can just say talk.Speaker = speaker. Right? We're going to change that. We want this all to happen after the mapper does its mapping job, but before we save it. So here, we're simply saying if the model sends in a speaker we're going to assume that you want to change it. Therefore, SpeakerId is going to be in here. But the TalkModel is not going to accidentally override any of these things for us, we're just going to simply tell it to ignore during the mapping and then attach it as we need it to be. I'm actually going to need down here either an else or a catch all. And I'll go ahead and put an else, and just say return BadRequest Failed to update database. Let's go ahead and run it. And here back in Postman, let's just duplicate this tab and change it to a PUT. And of course, we want to update a specific talk. So I'm just going to pick the third talk that we created. And our body still has this object in here. So let's just change this to include all the information they're going to want. But let's go ahead and change it to a level 100 talk instead. And when we get this, it says we failed to get Talks. And one of the reasons is we're going to need the entire object here except for the speaker, unless we want to change it. And that includes our talkId. Now we could also support changing this inside of the controller, but I like to prefer to force it to include this talkId. I might include a requirement for the talkId as a property as well, but for now let's go ahead and make sure we assign the talkId, and this is 3. But of course, we're changing talk 3 as well. Let's go ahead and send it again. Now we have the update. Notice the speaker hasn't changed, but we did get the level to change to 100. But what if we go ahead and include the speaker? And again, remember, because it's a related object we need to actually put speakerId. And let's change it to the second speaker. Now this isn't going to change the speaker at all, it's just going to change the assignment. Now we have Resa assigned to that same talk. And so we're given the ability to change any part of what actually is a talk that we had already created. Let's go ahead and figure out how to delete one of these next. </p>
                </div>
                <div><h3>DELETE a Talk</h3>
                  <p>Now let's go ahead and delete a talk. Let's do what we've done every time before, and that is create another action. Again, we're going to be dealing with the database. And in this case, we just need IActionResult because we're not going to be returning an actual model of any sort. We're just going to be saying pass or fail effectively. And I'll call this Delete, though of course you could call it whatever you want. And like every other piece here, we're going to need the moniker because we're deleting it in the context of a camp. But we're also going to need that ID to know which talk to delete. So let's go ahead and add our DELETE and then the ID part of the URI. And we'll do our try-catch again. So we're going to first need to get our talk, and we'll do that with await _repository.GetTalkByMonikerAsync. Give it that moniker, and give it that id. And then we can simply use the repository to say delete. Right? And we can just say delete this talk. And this works because what we're getting from here is actually a database type. But let's go ahead and check to see if it found our talk. If it didn't, we can go ahead and say NotFound. Then here, once we've deleted the talk, we can, just like before, _repository.SaveChangesAsync. And if that worked, we can just say Ok. Right? I'm just going to say it worked. We can put in a body if we want to. Else return BadRequest Failed to delete talk. Right? That something bad has happened. And it even could be a 500 error. It's really up to you in the way you want to design your API. What's interesting here is when we are suggesting these, because we're using both pieces of our information to get this ID, we can trust that this talk belongs to the camp because these IDs we're not guaranteeing are unique within the entire database only within the camp. What actually happens under the covers inside of the data access is ancillary to that. Our business rule should be that we're only going to delete the ID for this talk based on whatever that moniker is. So let's go over to Postman. And here, let's go ahead and duplicate this tab as well. Change this to a DELETE. And we'll leave it at just that talks/3. Right? And we don't need anything in the body. In fact, let's get rid of the body because it'll tell us that DELETEs don't send bodies. And let's go ahead and send this, and let's see what happens. Two-hundred, that means it's okay. So if we go and try to do a GET of the third talk, we should get NotFound. But of course, we're getting this No Content. Let's see what that's about. If we go up to our GET for individual methods here, remember we never checked to see whether this was a valid talk. So in fact, we're getting a null back. So, let's just go ahead and add our if talk equals null return NotFound. And this is where doing these integration tests can really help you. </p>
                </div>
                <div><h3>What We've Learned</h3>
                  <p>So what have we learned so far? I've shown you that the API that you're building should imply the structure to your users even if internally you're building them in separate pieces. We've talked about breaking up that API into individual controllers to make it a little easier to manage and that these associations can be deep or shallow. I haven't shown you creating a speaker controller to handle adding and editing of speakers within those talks, but you could certainly see that happen as well. </p>
                </div>
              </div>
              <div><h2>Functional APIs</h2>
                <div><h3>Introduction</h3>
                  <p>
                    We've talked a lot about using resources in your APIs. And now let's talk about another topic, functional APIs.
                  </p>
                </div>
                <div><h3>Functional APIs</h3>
                  <p>So we've talked about using APIs on the web and how REST, and especially pragmatic REST really sits in the middle of using RPC and the full scope of REST in this piece that I'm calling pragmatic REST, these pieces that make the most sense for the majority of people writing REST, but may not extend to every single piece of REST that you might want. And so far in this course, we've really focused on resource-based endpoints or resource-based URIs in order to do things like get, post, put, and delete different resources that we want to expose through our API. But this leaves a hole in some functionality that we might actually need. And that's where the idea around functional APIs come in. These are APIs that have a purpose to the application, but aren't really dealing with resources. Because REST defines URIs as resources it tends to confuse some developers about whether this is allowed or not. And I put up big quotes around the idea of it being allowed. Because most applications need functional APIs at one point or another, they make up a small percentage of your API space, but usually they do form some amount of the code that you need to write. So on the whole, I would say don't be afraid of them. Just because they're an exception to the rule doesn't mean the rule is invalid. I would avoid trying to use functional APIs to just create remote procedure call or RPC-style APIs at all costs because then you're trying to use the wrong tool for the wrong thing. But at the end of the day, you'll want to use functional APIs. And what do I mean by this? I'm talking about operational APIs. And these APIs typically are things like clearing the cache, restarting servers, starting batch jobs, those sorts of things. Operational needs that aren't specifically around resources. I would avoid this for reporting because reporting really is just returning data. And if you're returning data of any sort it's not a functional API. Let's build one so you can see more practically what I mean. </p>
                </div>
                <div><h3>Creating a Functional API</h3>
                  <p>So let's create a functional API. So I'm going to open up the controllers, and I'm just going to add a new controller called OperationsController.cs. And like we've done before, I'm first going to derive from ControllerBase. And let's bring in that namespace. And I'm going to add in ApiController as an attribute and Route, like we've done before, as an attribute as well. And what I want to be able to do in this controller as one of the operations is to reload the configuration. So I'm just going to create a constructor, and I'm going to bring in that IConfiguration interface. And we'll have to bring in Microsoft.Extensions .Configuration. Don't bring in AutoMapper.Configuration because that can confuse it. And I'll just call config, and create a field like we've done so many times so far. You can see sort of my pattern for doing it. And I'll go ahead and create an action, a public IActionResult. And in this case, I'm actually going to use an ActionResult bool because we're not going to be using an asynchronous API in this case. Of course, if we do for some reason change that later we can always refactor this. And I'll call this ReloadConfig, and then start with a try-catch. In here, what we want to do is reload it, but there is no method for reload. What we actually need to do is create a root of our config by just casting this as an IConfigurationRoot interface. This is an interface that guarantees it's the root of the configuration, which is the way we've handled wiring up configuration. And root will then allow us to reload. If it gets this far, we can just return true for our success. If it doesn't get this far, we can just return false. But more appropriately, we probably want to, inside of the catch, go ahead and say return StatusCode StatusCodes. We've done this a bunch of times before. And we'll go ahead and put look for Status500. Something really bad has happened if we get there. And in fact, this is warning us because false is never going to be called. So maybe let's change this because we know we really only want to return Ok in 500. That's the indication. This bool really isn't telling us anything. So it's fine to actually use IActionResult and just return Ok here. There's nothing wrong with that because your using the status codes for the call to the API accurately indicates success or failure. And of course, this needs to be _config to make sure it all works. So if we build this and then go over to Postman, let's just create a new request. And if I remember, we use 6600/ap/operations. And then what do we want it to do? We want it to actually say reload. Right? But we've actually not done anything yet to make this work. Because back in our project we haven't given it a verb. Because ReloadConfig isn't the name of a verb, we actually have to specify it here. And the reason I waited was to make you really think about it because we've used GET, PUT, POST, and DELETE, but there're actually quite a few of these different verbs. And there're even other verbs that you can implement. This is one of those where I would suggest going ahead and using a non-resource-based verb. So I'm going to suggest we actually use options, which is the name of a verb, and then go ahead and say we want to look for reloadconfig. Yeah, let's call it reloadconfig. Because we don't want someone accidentally, you know, tripping into this and wanting to use it on a very common basis. But when we need it through the API, we're going to need it through the API. You can imagine our configuration maybe being loaded by something that couldn't trigger that it knew the reload happened. Like changing the configuration inside of a database. And so, forcing it to reload might actually be something useful in an operational sense. So in Postman, we can just use the verb, you can see we have tons of verbs here, OPTIONS, and let's just change it to reloadconfig, and let's see what happens. And there we can see it happened. We get a 200 for our status code, so we know it actually happened. The reload happened. We can go along our day. Only if something really tragic happened would we get a 500 error saying that something on the server went really bad, we couldn't reload the configuration, it's failed in a way that we were unexpecting. The rest of your operational or functional APIs, you should think about them in this very similar way. You don't want them necessarily that simple to call or write a lot of them. If you feel like you're writing a lot of them, the suspicion is that you're probably starting to delve into remote procedure call territory, that you're no longer building a RESTful API, you're just building RPC over HTTP, which you can do, but it's not what this course is trying to teach you. Let's wrap up this short module. </p>
                </div>
                <div><h3>What We’ve Learned</h3>
                  <p>
                    So what have we learned? We talked about how REST is important, but being pragmatic is probably a good idea. That being able to go outside the scope of REST in order to get your job done is way more important than just having something purely RESTful and dogmatic. So I say that you should create functional APIs if necessary, and some projects simply just need some functional APIs. And adding them to an API that you're building doesn't make the API bad or wrong. Necessary is necessary to get the job done. But you can go too far, as with anything, and end up in the remote procedure call trap of creating functional APIs that really aren't functional, but are more about doing things like remote procedure call. Now that we've built an API, let's talk about versioning it next.
                  </p>
                </div>
              </div>
              <div><h2>Versioning Your API</h2>
                <div><h3>Introduction</h3>
                  <p>
                    Now that we've built the API, let's go ahead and talk about versioning the API. So what do I mean by versioning an API? When you create a new API, you should be setting it in stone. And the reason for this is your users or customers, whether they're internal or external, tend to rely on that API. You don't want to break their code just because you make changes. But as requirements change, you will need to make changes and have a way to manage that. In essence, you need a way to evolve your API as requirements change. At the end of the day, my goal is always not to break clients and to give them a head's up so that they can move to the newer versions of an API or they can stay with the older versions for some time. Remember that API versioning isn't product versioning. So, they don't need to necessarily be tied together. Now we can talk about API versioning and say yes you should do it and this is why it should work, but there are some issues. In .NET when we talk about versioning in an API, not a web API, but just an API, this is done with package versioning. In other words, having assemblies of a specific version. API versioning is more difficult. You need to be able to support old and new users with usually a single code base instead of having different versions of your actual code. Dealing with things like side-by-side deployment isn't feasible because the API you're dealing with is some endpoint out there. You don't want to just create a whole new deployment for each of these versions. You'd like to have one code base that can fix bugs that may be internal, but also have new versions of APIs as requirements change. The key difference here to remember is that you're taking your single code base and supporting one or more versions of your API. There are a number of standard API versioning schemes. Now it doesn't mean you need to use any of these, but you should have some scheme for versioning your API. But as APIs have matured, we've seen some patterns form. I'm not going to personally recommend that all of these are a great idea, but because you see them a lot in web APIs I do want to talk about them. The key here is to find a mechanism that works for your organization. Remember that versioning in an API isn't just changing the code base to support it, but also the communication to your users, especially if they're external users where you have to use more formal ways, letting them know about new versions of an API. At the end of the day, you're serving your clients, not yourselves. So all this extra work that you're thinking about is really to make that process easier. Next, let's take a look at some of those schemes.
                  </p>
                </div>
                <div><h3>Types of Versioning </h3>
                  <p>
                    So to deal with API versioning, you can use the URI to help you. So one approach we've seen quite a lot is using a part of the URI to specify what version of the API someone wants to work with. You can see this both in query strings and in using it as part of the path. Another pattern we've seen is versioning with headers. In this case, we're adding a new header that's going to specify what version that the user wants to use. There's a special kind of header called an Accept header that you can also use for this. So instead of having a custom or your own kind of header, you're actually just adding to an existing header to say this is the format of the data and this is the version of the API I want you to use. You can do this same thing with content type. Now while this is more complex, the idea here is that the actual content you're sending will have the notion of what version is in it. So not only are you dealing with the version of someone calling your API, but the data they get back from it has a notion of what version they got your data from because some of this data may be cached for a long time, and you don't want to not know that the structure of what they're sending back to you has actually changed. And in this same way, you can use an Accept header to say what versions of the APIs are you actually going to use yourself? Each of these version types have pros and cons. It's just hard to implement them with ASP.NET Core. I'll talk about when you should or shouldn't use some, but there may be cases where you're not going to have a choice about the versioning scheme because it's set by your company or you want to keep on doing what you've done with other APIs. So I want to show you how to use all of them even though I don't recommend all of them for every situation. Let's jump into the code.
                  </p>
                </div>
                <div><h3>Introducing Versioning</h3>
                  <p>
                    Now let's introduce API versioning into our project. Here we're back to the CoreCodeCamp project, and the first thing we're going to want to do is actually add a reference. API versioning isn't built in, it's actually another NuGet package you're going to need. So, let's go ahead and just manage our NuGet packages. And what we're going to look for here is Microsoft.AspNetCore .Mvc .Versioning. It's important you get the Asp.Net Core version versus the Asp.Net version because the Asp.Net Core version works with ASP.NET Core. A lot of what we're going to talk about there is actually a version that also works with ASP.NET. But the way it actually works is a little different, so you could certainly use it in those projects, but a lot of the way it wires up is very different. So let's include that. Let's install it. And now if we open up our startup, we're going to want to actually add API versioning into the product. And we do that inside of ConfigureServices because a couple of things are happening here. We're not only configuring the way that API versioning should work, we're also telling it that we're going to need some facilities from API versioning. So we can just say services.AddApiVersioning. This will add API versioning to our project. Let's actually run the project, and then go over to Postman. And I'm going to duplicate this tab, make sure it's maximized, and let's just execute it without knowing that we need anything for versioning. And we're getting all the data here because versioning actually isn't working. Let's talk about that for a moment. In the current state of API versioning, the current project we've been working with is an ASP.NET Core 2.2 project. You can tell here in that the compatibility version has been turned on for 2.2. But something interesting happened in 2.2 and that was that the ASP.NET team made a pretty big change in the way they do routing. And as of the recording of this course, API versioning hasn't been able to make a change for that yet. It's coming, it may be working by the time you get here, but I want you to be aware of it. So if you're using ASP.NET 2.2, especially near after its release, you're going to have to turn on one other option here to make versioning work. So here in AddMvc, we're going to need to add in a lambda to set the options. And the option we want to set is EnableEndpointRouting, and we just want to turn it off. Now if you're using version 2.0 or version 2.1 of ASP.NET Core, this is not required. This endpoint routing is a new feature in 2.2, and the two aren't compatible yet. The promise has been that it will be compatible with it at API versioning once ASP.NET Core hits 3.0. So just be aware of that difference. With this compatibility turned on or, more importantly, the endpoint routing turned off, AddApiVersioning is going to work the way we expect it to. So let me restart it. And back in Postman, when we call it we're going to actually get an error. And that error is, hey, you didn't specify what version of the API you wanted. Out-of-the-box API versioning requires you to specify a version. So let's come up here and add a new query string for api-version, and let's add for 1.0. We'll see it works because by default it's going to assume the whole project is actually using 1.0 as the version it's going to support. Because you haven't put anything in, it's just going to assume your API is version 1.0. What if we actually want to support a new version called 1.1? If we call it with 1.1, we'll see that it says hey this URI does not support version 1.1. Let's see what that looks like. Back here in the code, I can add a lambda here to add API versioning to add options to configure the way that API versioning works. So let's first add an option to change the default version number to a new API version. And here we're going to give it either a DateTime for the version, a minor and major version, or there're a few other ways to specify it. And so in our case, I'm going to say, you know what, the default version is 1.1. For every API that's written, if we haven't specifically told it, which we haven't yet, what version we want to use, we're going to assume 1.1 is the default. So back in Postman, now that we're asking for 1.1, if we send it it'll actually work. If we ask for 1.0, nothing is specified as 1.0. We're going to get that same problem, 1.0 isn't supported. And back here, let's add one more option, and that is just saying ReportApiVersions as true. And what this will do is it will add headers to the responses to say what API versions are going to be supported by a certain URI. If we come back and change the version to 1.1 and send it again, we'll get a proper version. And we'll get a brand-new header here that says API supported versions and be able to figure out exactly what that is. But that is just the default behavior out of the box. We're going to talk about using this same versioning mechanic of being able to specify what versions directly inside of our controllers. So let's see what that looks like next.
                  </p>
                </div>
                <div><h3>Versioning Actions</h3>
                  <p>
                    So now let's talk about versioning our actions. If we go ahead and open up one of our controllers, and I'll just start with Camps, I can tell a few different things about versioning. So in this case, I'm going to tell it that I want this controller to support 1.0 of our API and 1.1. So in this case, I'm going to say this controller is going to support both 1.0 and 1.1 for the most part for our controller. So I come down to the GET for the individual camp, and I'm going to actually make a copy of this. I want each one of these to be treated by a different version. So, in this one I'm going to say, because I don't want to break the old code, I want to say MapToApiVersion 1.0. So when someone is asking for API version 1.0 and they're using this as the path, it's going to use both of these to discriminate and call this. So, you can think of the API versioning as just being part of the routing because it's going to look for the version to not only look for that the path to the GET is correct, but that the API version is also that version. So down here, let's go ahead and rename this as 1.1. And we'll say MapToApiVersion, but this time I'm going to say 1.1. And here, we can actually make a change. Let's go ahead and say true here to return all of the talk data as well. So let's see what this looks like. Let's come back over to this one where we're actually looking for an individual API. And let's duplicate that. And if I just call this with our new changes, we're going to say an API version is required, but it was not specified because we don't have a default version for our project. Let's actually go back to the code, and back to Startup, and actually say you know what I want you to assume the default version if someone doesn't specify it. So you can't have a default version and assume a different version. Basically if no one expressly asks for a version we're going to assume it is the default version. Otherwise, it's going to assume that you need a specific version asked for each and every time. And that may not be what you want. Back in Postman, we still don't have any version information here, so let's go ahead and just press Send. What we should get is the camps with all those talks in them, right, because the 1.1 version of our API now returns all the talks. In fact, if we look at the headers, we'll see that this URI actually supports 1.0 and 1.1. And so we can assume that this is getting the correct one. But what if we go up here and add that query string for API version? What's going to happen? We're going to actually get and call the old API, the 1.0 API, that doesn't give us the talks. And so in this way we can make decisions about which actions on a controller are mapped to individual, specific versions. And if we go back and just call this without a version now, because remember this is a different API, right, we just call and get the camps, we're going to see it just still returns because we're assuming that because there's no version information on this method that's it's going to be 1.1 by default. And in fact, because the controller supports 1.0 and 1.1, because we haven't mapped it to a specific one, we're actually telling it to overlap. So, api-version= 1.0 for this API that doesn't have different versions, we're going to get the 1.0 version. And if we put 1.1, we'll also get the same data because it's assuming because we haven't mapped it to a specific version that it's going to support all the versions for the controller. This isn't going to be any version that exists out there because, of course, we could put a version 2 out here and it's going to say, hey, this doesn't support version 2. And it doesn't support version 2 because we expressly said that the CampsController supports versions 1.0 and 1.1 only. So in this way you can add incrementally small changes to only some methods on a controller and support two versions in that very simple way. But we may want to do it where we have a whole new controller that is our new version. Let's see what that looks like next.
                  </p>
                </div>
                <div><h3>Versioning Controllers</h3>
                  <p>Now let's talk about versioning an entire controller. So let's try something. I'm going to actually make a copy of our whole CampsController. Go ahead and paste that. Now we're going to get a copy of this same controller, but this time I'll call it Camps2Controller. Right? Whole new class. And let's just go ahead and just name it here because of course they have to have different names for C#. And instead of supporting 1.0 and 1.1, let's say, hey, this is going to be our 2.0 version. This is going to be more repeated code than you had before, but it gives you the opportunity to have a whole new slate where the entire controller is only happening for 2.0 in itself. And so, let's make a small change here in the way we're actually returning data so that we can see that what we're going to get down here is actually a different version. And let's go ahead and get rid of the MapToApiVersion because we're going to make this whole controller version 2. And I'm going to get rid of the second version of our individual as well. Let's just change for the collection of camps what we're going to actually return. Let's say in 2.0 we're going to change the style. Let's just change the style here and say what we actually want to do is create a new, anonymous type. And we're going to have a property of the anonymous type called Results that actually has our mapped results. Right? But it also might be interesting here to have the count. It's not an uncommon pattern you're going to see. And let's just say result.Count. Throw a comma in there. And in this case, we're going to actually return Ok with our new result. Right? So it's going to be a structure instead of just the bare data. Of course, this doesn't work because what this ActionResult actually returns is now going to be an anonymous type. So let's just change back to IActionResult to make that nice and friendly. And if we build it and come back over to Postman, let's come back here. So we're getting this camps does not support the API version 2 because remember we're trying to map this as a URI, including the version 2 that we've done. Well why isn't it showing up then? If we come back to our copied controller, remember we copied this route as just controller. Right? This of course is going to make the URI be Camps2. Not what we want. So we just need to change this back to camps. And now when we run it, we'll get this new version. We're getting the same data back, but now our results are a property of an object that can have more interesting information. If we change this back to 1.1, same URI, we're going to get a version from the old API. Same with 1.0 because remember the old controller supports both. So here you can see just by changing the version, and in this case in the query string, we can change the way we actually return data, the structure of the data, what code paths we're actually working with, by changing both the controllers or even individual actions. But what if you don't want to use query strings for your versioning? What if you want to use other methods? Let's show you a few different ways to do that. Let's start with headers next. </p>
                </div>
                <div><h3>Versioning with Headers</h3>
                  <p>So now let's see how to version with headers. Let's return back to Startup in Visual Studio. One of the other things we can configure inside this API versioning is the ApiVersionReader. Now version reader is something that is going to figure out how to determine the version you're looking for from some part of the request. By default, this version reader is a QueryStringApiVersionReader. We can see that's coming from AspNetCore.Mvc .Versioning in our project. And so by default, this is the value. We can actually change the query string if you still want to use the query string and support one of the overloads for including one or more parameter names that will match the query string value. So maybe you don't like api-versioning. We could actually just set this as ver here, and it'll go ahead and use that as the query string instead. If we rerun it and then go back to Postman, we'll see that running it without any change is actually going to return us back to the 1.0 version because it doesn't know what this query string is. It assumes you're going to be doing something different with it. But if I change it now to the ver like we specified then we'll go ahead and get our version based on that ver key instead of by the API version. And I told you we were going to do this with a header instead. And you can probably figure out where we're going, HeaderApiVersionReader. And in this case, we're going to specify the name of the header instead of the name of the query string value. So I'm just going to use an X-Version as the name of our header. And let's rerun it. And back here in Postman, instead of using parameters let's go over to Headers and just say we're going to use X-Version. And then let's ask for 1.0 first. Again, this ver is going to be ignored completely because we're no longer looking at the query string to determine it. We're looking at this version down here. Now we can get that. If we change this over to 2, we can see that we're now versioning it with this header value. So it comes down to needing to make the choice about what way you're going to do the versioning. And we're going to look at some other methods as well, but when we look at them you need to think about who your actual users are. Setting a header value isn't difficult. Let's say if people are calling your API from JavaScript or from their own code, it isn't difficult to do, but it does require an additional level of complexity. So if your users are hobbyists or brand-new people or you want people to be able to call these APIs from within Excel or something, that is less of a developer friendly. You might want to avoid using header values because it's just more complex. Adding it to the URI might be less complex. And so, you're going to want to look at these from that perspective of who am I going towards. Is this just an internal API that's going to be used just by developers that are sitting four cubes away? And in that case, complex is complex. You can talk to them and help them figure out the best way to handle this. And you can choose much more rigorous ways of getting and specifying versioning than you could if, you know, script kiddies or hobbyists are really the users you want to target. You know, this is the difference between something like the GitHub API versioning and Twitter's API versioning. Right? The needs of who might write apps for either one of those are very different. Well what if you want to use more than one method? Maybe you really want to say, you know, we're going to support a bunch of different methods and any way people specify the versioning we're going to go ahead and make that happen. Let's see what that looks like next. </p>
                </div>
                <div><h3>Using Multiple Versioning Methods</h3>
                  <p>
                    Now let's talk about using multiple versioning methods. Back in Startup, you'll remember a minute ago we talked about using the API version reader to specify which version. You can actually use ApiVersionReader, that's a static class that has a method on it called Combine. And, unsurprisingly, if you use Combine you're going to be able to specify one or more API version readers. So in this way, we can have one or more methods for figuring out what that version is. If you wanted to use different query string parameters or different header values, you wouldn't do that by adding it more than once. These actually support parameterization so we can actually do things like port ver or version. In case we want to allow them to specify it in a couple different ways. And if we run this, back here in Postman we'll see that, of course, the X-Version works fine. But if we turn that off and go back to Parameters and put in ver for 2.0, it'll read it there as well. And if we put it in as version, it should also read it. What if you specify both? What if you actually turn this on, and let's go ahead and say 1.1 in the query string, but in the header we've left this X-Version at 2. Which one is going to win? You actually get an error that says hey you specified 2, please only specify 1 or make sure that they're the same. So over here, if we make this 2 it'll work, but of course don't do that. Don't specify or force them to specify both because the important part about this is this is saying or. Right? You can have header or query string. You're not saying that they have to supply both. If you need something like that, you'll have to write your own API version reader. Not very difficult to do, but I would avoid doing it unless you really, really have a great reason for it. The other type of API versioning I'm going to talk about is versioning directly in the URL, not in the query string, but the actual path of the URL. I battled myself with whether to include this in the course because I think it's a really bad idea. But if you have to have it or you're working with an existing project that's already using it, I think it's important to know how it works. So let's do that next, and I'll try to talk you out of it while we go through it.
                  </p>
                </div>
                <div><h3>URL Versioning</h3>
                  <p>Then I'll talk about URL versioning. I'm going to start here in Postman. I'm going to go ahead and get rid of our other versioning schemas, and let's talk about what this really looks like. What I mean by URL versioning is actually changing the path here. So doing something like v1 after api for camps. Right? Being able to specify directly in the URI itself some path for it. And the reason I don't tend to like this is it has no good rollover. It assumes that versioning has to be specified in every case. There is no optional part of this. We'll see especially when we implement it that there is no optionality here. You're going to have to support these versions in here unless you do something very special. And so, I don't suggest this because I think it tends to be fragile. There's no way to move organizations from version 1 to 2 very easily without them having to change every URL inside of their own project. There's no graceful way to have that move up, especially if, you know, 99% of your API hasn't changed, but this 1 thing that they may need has changed in 2.0. How do you make them change all parts of their application because this small piece changed? Now let's implement this so you know how in case it actually comes up. The trick here is in the startup I'm going to go ahead and comment out this API version just so you have it here in the code. And I'm going to set the version reader to be new UrlSegmentApiVersionReader. There're no options for it. It's just assumed that the version is going to be inside the URL segment. In order to make this work, we have to go over to Camps, and we have to actually change the API here. We have to say, let's say v, again this is part of the route. We're going to call it version, which we have to, and then we're going to say that the type is apiVersion. So it's going to read from the route what version you're actually mapping this to. This isn't going to change the rest of the controller, this is just saying you're deriving it from the actual route, not from some external piece of data like the query string or the header, content type, or any of those. And we'll need to do this on all of our controllers. Right? So, when we're going to support this we're going to need to do this in every case for anything that's versioned. And in our case, for now that'll just be the two camp controllers. But you can imagine doing this to all the controllers just so we can get that version and understand where it's coming from. This won't be a value that you actually get anywhere in your controller. They could get at it. It's one that's only used by the reader to figure out the version. If we go back over to Postman, now that we have 1.0 we should be able to get the 1.0 version. And then come up here, and let's change this to 2. And we'll see we're getting the 2.0 version just by changing the URL. Again, there's not a technical reason, but more of a process reason why I don't prefer this. But if you need to, you can use the UrlSegmentApiVersionReader, and you should be good to go. Let's talk about conventions next. </p>
                </div>
                <div><h3>Versioning Conventions</h3>
                  <p>
                    Now let's talk about versioning conventions. Back in Visual Studio, we'll see that we've basically specified through these controllers a lot of pieces that are inside of the controller to know about the versioning. And often mixing those pieces of data isn't actually that useful. We'd love a way to specify them that was external to the actual implementations. And we can do that. Let's go over to Startup, and one of the other options we can do is actually set up conventions. So here, we can say conventions for a specific controller. In this case, I will do TalksController. And this is going to allow us, on a per-controller basis, to say what versions it has. And in this case, it'll be a new API version. And of course, we're going to pick 1.0. And then, this being a fluent syntax, we can continue to just add to it or 1, 1. And if we want to specify that the action itself is part of one of these versions, we can do that here by calling a method called Action. Action isn't in the default namespace, so we actually have to come up here and manually add conventions. When we add that, we'll see the extension methods here for Action. And this action is going to take a LINQ expression to determine what action. So in our case, it's going to be the controller. And you'll see that this is an instance of the controller. So we can say, you know what, let's say that Delete only exists in 1.1. We need to pick the version of Delete. Now we only have one overload, but we're still going to need to specify the parameters of Delete so it can match the actual action. If we just said Delete, and we ended up having two versions later, it would be confused. So it does this matching by the parameter types, as well as the name of the method. And so, you can just say default(string) since the first parameter is a string. And let's say default(int) for the second parameter. If they were reference types, you could say null or new object to specify the types there as well. Make sure and add that last parenthesis. And then I'm just going to say MapToApiVersion, much like we did with the attributes, but I'm going to do it with the conventions instead. And then I can just use the 1, 1 here to specify the delete action is only applicable directly on the 1.1 version. And what we've done here is the same thing that we did with the attributes. There isn't a better or worse reason to use one over the other. The idea here really is to allow you to either centralize all your versioning information or to include it on the controllers. It's up to you which method you want to use. Now let's talk about some of the methods that are outside of the scope of this course.
                  </p>
                </div>
                <div><h3>Other Versioning Methods</h3>
                  <p>So there are other versioning methods that I'm not going to cover in this course, and mostly because they're pretty complex. It doesn't mean they're not useful, it's just that the implementation really is going to end up being so specific to your organization that you'll want to use the API versioning stuff we've been using as the basis of it. But going into a detailed implementation is just a sort of niche for this course. So the versioning library supports the idea of versioning by namespaces where you would have namespaces that are tied to individual versions so that you can have the same controller, but different namespaces that support that. You can also version by content type. This is where there is a reader for content type where you specify what version you want. But usually that goes down the rabbit hole of wanting your own reader. Writing your own reader isn't that difficult, but being able to figure out where in that content type you're going to get that version is going to be pretty domain specific. You can also write your own resolvers, and this is code that intercepts the call to not only figure out what version the person's asking for, but how to find the specific controller and action that map to it. So you may have a scheme that doesn't fit into the API structures that they've given you, but because you can write your own readers and resolvers, it's really up to you how complex and how crazy you want to get. Let's wrap up this module. </p>
                </div>
                <div><h3>What We've Learned</h3>
                  <p>So what have we learned? I've shown you a method of API versioning, and this versioning is supported by Microsoft. It isn't just some random library that's out there, it is in GitHub so you can actually look at all the source code as well. I've shown you that you can version your URLs and your payloads through different methods of handling the APIs, but that the API versioning subsystem that I've shown you doesn't support all of these out of the box maybe as easily as you'd like them to. I've shown you that you can choose either the attribute approach or the convention approach to do your versioning configuration, to figure out how to map from one version to another or how to detect what version you're actually looking for in each of these requests. This has been Shawn Wildermuth of Wilder Minds. Thanks for taking this course. Remember that you can use the Discussion tab to ask any questions about problems you had during the course. And of course, you can see my entire library of courses that may be related to this one by visiting Pluralsight.com. </p>
                </div>
              </div>
              <div><h2>Course Overview</h2>
                <div><h3>Course Overview</h3>
                  <p>Hi everyone. My name is Shawn Wildermuth, and welcome to my course, Building an API with ASP.NET Core. I'm a Microsoft MVP, instructor, and developer. The skill of building a web-facing API isn't optional anymore. Whether you're building a website, a mobile app, a SPA, or an enterprise tool, building a well-designed API is required. In this course, I'm going to introduce you to REST, we're going to design and build an API from start to finish, and show you how to version your API too. Some of the major topics we'll cover include use ASP.NET Core to build reliable APIs, understand REST and when to be pragmatic about it, how to use models and validation, and how to version your APIs. By the end of this course, you'll know how to implement an API that's easy to use and easy to maintain. Before beginning with this course, you should be familiar with ASP.NET Core and Entity Framework Core. I hope you'll join me on this journey to learn to create an API with ASP.NET Core with my Building an API with ASP.NET Core course here at Pluralsight. </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
</div>

</body>
</html>
