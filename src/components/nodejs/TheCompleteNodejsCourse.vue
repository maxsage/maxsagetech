<template>
  <div class="container">
    <div class="panel-group">
      <div class="panel panel-primary">
        <div class="panel-heading">
          <h3>The Complete Node JS Course</h3>
        </div>
        <div class="panel-body">
          <h3>Section 1 - Getting Started</h3>
          <ul class="contents">
            <li>01 - Welcome</li>
            <li>02 - What is Node</li>
            <li>03 - Node Architecture</li>
            <li>04 - How Node Works</li>
            <li>05 - Installing Node</li>
            <li>06 - Your First Node Program</li>
            <li>07 - Course Structure</li>
            <li>08 - Recap</li>
            <li>09 - Asking Questions</li>
          </ul>
          <h3>Section 2 - Node Module System</h3>
          <ul class="contents">
            <li>10 - Introduction</li>
            <li>11 - Global Object</li>
            <li>12 - Modules</li>
            <li>13 - Creating a Module</li>
            <li>14 - Loading a Module</li>
            <li>15 - Module Wrapper Function</li>
            <li>16 - Path Module</li>
            <li>17 - OS Module</li>
            <li>18 - File System Module</li>
            <li>19 - Events Module</li>
            <li>20 - Event Arguments</li>
            <li>21 - Extending Event Emitter</li>
            <li>22 - HTTP Module</li>
            <li>23 - Recap</li>
          </ul>
          <h3>Section 3 - Node Package Manager</h3>
          <ul class="contents">
            <li>24 - Introduction</li>
            <li>25 - Package.json</li>
            <li>26 - Installing a Node Package</li>
            <li>27 - Using a Package</li>
            <li>28 - Package Dependencies</li>
            <li>29 - NPM Packages and Source Control</li>
            <li>30 - Semantic Versioning</li>
            <li>31 - Listing the Installed Packages</li>
            <li>32 - Viewing Registry Info for a Package</li>
            <li>33 - Installing a Specific Version of a Package</li>
            <li>34 - Updating Local Packages</li>
            <li>35 - DevDependencies</li>
            <li>36 - Uninstalling a Package</li>
            <li>37 - Working with Global Packages</li>
            <li>38 - Publishing a Package</li>
            <li>39 - Updating a Published Package</li>
            <li>40 - Recap</li>
          </ul>
          <h3>Section 4 - Building RESTful API's Using Express</h3>
          <ul class="contents">
            <li>41 - Introduction</li>
            <li>42 - RESTful Services</li>
            <li>43 - Introducing Express</li>
            <li>44 - Building You First Web Server</li>
            <li>45 - Nodemon</li>
            <li>46 - Environment Variables</li>
            <li>47 - Route Parameters</li>
            <li>48 - Handling HTTP GET Requests</li>
            <li>49 - Handling HTTP POST Requests</li>
            <li>50 - Calling Endpoints Using Postman</li>
            <li>51 - Input Validation</li>
            <li>52 - Handling HTTP PUT Requests</li>
            <li>53 - Handling HTTP GET Requests</li>
            <li>54 - Project - Build the Genres API</li>
            <li>55 - Recap</li>
          </ul>
          <h3>Section 5 - Express - Advanced Topics</h3>
          <ul class="contents">
            <li>56 - Introduction</li>
            <li>57 - Middleware</li>
            <li>58 - Creating Custom Middleware</li>
            <li>59 - Built-in Middleware</li>
            <li>60 - Third-party Middleware</li>
            <li>61 - Environments</li>
            <li>62 - Configuration</li>
            <li>63 - Debugging</li>
            <li>64 - Templating Engines</li>
            <li>65 - Database Integration</li>
            <li>66 - Authentication</li>
            <li>67 - Structuring Express Applications</li>
            <li>68 - Project - Restructure the App</li>
            <li>69 - Recap</li>
          </ul>
          <h3>Section 6 - Asynchronous JavaScript</h3>
          <ul class="contents">
            <li>70 - Synchronous Vs. Asynchronous Code</li>
            <li>71 - Patterns For Dealing With Asynchronous Code</li>
            <li>72 - Callbacks</li>
            <li>73 - Callback Hell</li>
            <li>74 - Named Functions to Rescue</li>
            <li>75 - Promises</li>
            <li>76 - Replacing Callbacks with Promises</li>
            <li>77 - Consuming Promises</li>
            <li>78 - Creating Settled Promises</li>
            <li>79 - Running Parallel Promises</li>
            <li>80 - Async and Await</li>
            <li>81 - Exercise</li>
          </ul>
          <h3>Section 7 - CRUD Operations Using MongoDB</h3>
          <ul class="contents">
            <li>82 - Introducing MongoDB</li>
            <li>83 - Installing MongoDB on Mac</li>
            <li>84 - Installing MongoDB on Windows</li>
            <li>85 - Connecting to MongoDB</li>
            <li>86 - Schemas</li>
            <li>87 - Models</li>
            <li>88 - Saving a Document</li>
            <li>89 - Querying Documents</li>
            <li>90 - Comparison Query Operators</li>
            <li>91 - Logical Query Operators</li>
            <li>92 - Regular Expressios</li>
            <li>93 - Counting</li>
            <li>94 - Pagination</li>
            <li>95 - Exercise 1</li>
            <li>96 - Exercise 2</li>
            <li>97 - Exercise 3</li>
            <li>98 - Updating Documents - Query First</li>
            <li>99 - Updating Documents - Update First</li>
            <li>100 - Removing Documents</li>
            <li>101 - Recap</li>
          </ul>
          <h3>Section 8 - Mongoose - Data Validation</h3>
          <ul class="contents">
            <li>104 - Custom Validators</li>
            <li>105 - Async Validators</li>
            <li>106 - Validation Errors</li>
            <li>107 - SchemaType Options</li>
            <li>108 - Project - Add Persistence to Genres API</li>
            <li>109 - Project - Build the Customers API</li>
            <li>110 - Restructuring the Project</li>
            <li>111 - Recap</li>
          </ul>
          <h3>Section 9 - Mongoose - Modelling Relationships Between Connected Data</h3>
          <ul class="contents">
            <li>112 - Modelling Relationships</li>
            <li>113 - Referencing Documents</li>
            <li>114 - Population</li>
            <li>115 - Embedding Documents</li>
            <li>116 - Using an Array of Sub-documents</li>
            <li>117 - Project - Build the Movies API</li>
            <li>118 - Project - Build the Rentals API</li>
            <li>119 - Transactions</li>
            <li>120 - ObjectID</li>
            <li>121 - Validating Object ID's</li>
            <li>122 - A Better Implementation</li>
            <li>123 - Recap</li>
          </ul>
          <h3>Section 10 - Authentication and Authorization</h3>
          <ul class="contents">
            <li>124 - Introduction</li>
            <li>125 - Creating the User Model</li>
            <li>126 - Registering Users</li>
            <li>127 - Using Lodash</li>
            <li>128 - Hashing Passwords</li>
            <li>129 - Authenticating Users</li>
            <li>130 - Testing the Authentication</li>
            <li>131 - JSON Web Tokens</li>
            <li>132 - Generating Authentication Tokens</li>
            <li>133 - Storing Secrest in Environment Variables</li>
            <li>134 - Setting Response Headers</li>
            <li>135 - Encapsulating Logic in Mongoose Models</li>
            <li>136 - Authorization Middleware</li>
            <li>137 - Protecting Routes</li>
            <li>138 - Getting the Current User</li>
            <li>139 - Logging Out Users</li>
            <li>140 - Role Based Authorization</li>
            <li>141 - Testing the Authorization</li>
            <li>142 - Recap</li>
          </ul>
          <h3>Section 11 - Handling and Logging Errors</h3>
          <ul class="contents">
            <li>143 - Introduction</li>
            <li>144 - Handling Rejected Promises</li>
            <li>145 - Express Error Middleware</li>
            <li>146 - Removing Try_Catch Blocks</li>
            <li>147 - Express Async Errors</li>
            <li>148 - Logging Errors</li>
            <li>149 - Logging to MongoDB</li>
            <li>150 - Uncaught Exceptions</li>
            <li>151 - Unhandled Promise Rejections</li>
            <li>152 - Error Handling Recap</li>
            <li>153 - Refactoring index.js - Extracting Routes</li>
            <li>154 - Extracting the DB Logic</li>
            <li>155 - Logging</li>
            <li>156 - Extracting the Config Logic</li>
            <li>157 - Extracting the Validation Logic</li>
            <li>158 - Showing the Unhandled Exceptions on the Console</li>
            <li>159 - Recap</li>
          </ul>
          <h3>Section 12 - Unit Testings</h3>
          <ul class="contents">
            <li>160 - What is Automated Testing?</li>
            <li>161 - Benefits of Automated Testing</li>
            <li>162 - Types of Tests</li>
            <li>163 - Test Pyramid</li>
            <li>164 - Tooling</li>
            <li>165 - Writing Your First Unit Test</li>
            <li>166 - Testing Numbers</li>
            <li>167 - Grouping Tests</li>
            <li>168 - Refactoring with Confidence</li>
            <li>169 - Testing Strings</li>
            <li>170 - Testing Arrays</li>
            <li>171 - Testing Objects</li>
            <li>172 - Testing Exceptions</li>
            <li>173 - Continually Running Tests</li>
            <li>174 - Exercise - Testing the FizzBuzz</li>
            <li>175 - Creating Simple Mock Functions</li>
            <li>176 - Interaction Testing</li>
            <li>177 - Jest Mock Functions</li>
            <li>178 - What to Unit Test</li>
            <li>179 - Exercise</li>
            <li>180 - Recap</li>
          </ul>
          <h3>Section 13 - Integration Testing</h3>
          <ul class="contents">
            <li>181 - Introduction</li>
            <li>182 - Preparing the App</li>
            <li>183 - Setting Up the Test DB</li>
            <li>184 - Your First Inegration Test</li>
            <li>185 - Populating the Test DB</li>
            <li>186 - Testing Routes with Parameters</li>
            <li>187 - Validating Object ID's</li>
            <li>188 - Refactoring with Confidence</li>
            <li>189 - Testing the Authorization</li>
            <li>190 - Testing Invalid Inputs</li>
            <li>191 - Testing the Happy Paths</li>
            <li>192 - Writing Clean Tests</li>
            <li>193 - Testing the Auth Middleware</li>
            <li>194 - Unit Testing the Auth Middleware</li>
            <li>195 - Code Coverage</li>
            <li>196 - Exercise</li>
            <li>197 - Recap</li>
          </ul>
          <h3>Section 14 - Test-driven Development</h3>
          <ul class="contents">
            <li>198 - What is Test-driven Development?</li>
            <li>199 - Implementing the Returns</li>
            <li>200 - Test Cases</li>
            <li>201 - Populating the Database</li>
            <li>202 - Testing the Authorization</li>
            <li>203 - Testing the input</li>
            <li>204 - Refactoring Tests</li>
            <li>205 - Looking Up an Object</li>
            <li>206 - Testing is Rental Processed</li>
            <li>207 - Testing the Valid Request</li>
            <li>208 - Testing the Return Date</li>
            <li>209 - Testing the Rental Fee</li>
            <li>210 - Testing the Movie Stock</li>
            <li>211 - Testing the Response</li>
            <li>212 - Refactoring the Validation Logic</li>
            <li>213 - Mongoose Static Methods</li>
            <li>214 - Refactoring the Domain Logic</li>
          </ul>
          <h3>Section 15 - Deployment</h3>
          <ul class="contents">
            <li>215 - Introduction</li>
            <li>216 - Preparing the App for Production</li>
            <li>217 - Getting Started with Heroku</li>
            <li>218 - Preparing the App for Deployment</li>
            <li>219 - Adding the Code to a Git Repository</li>
            <li>220 - Deploying to Heroku</li>
            <li>221 - Viewing Logs</li>
            <li>222 - Setting Environment Variables</li>
            <li>223 - MongoDB in the Cloud</li>
            <li>224 - Coupon to My Other Courses</li>
          </ul>
          <h3>Section 1 - Getting Started</h3>
          <h4>01 Welcome</h4>

          <p>The Complete Node Course aims to make you a highly competent Node developer.</p>

          <h4>02 What is Node</h4>

          <p>Node is a runtime environment for executing Javascript outside of a browser. Often Node is used to build
            back-end services otherwise known as API's. Client applications like web or mobile apps are just the surface
            of the app. Often they need to speak to some services on a Server or in the Cloud to send emails, work with
            data, push notifications etc. </p>

          <p>Node is ideal for building highly-scalable, data-intensive, real-time back end services.</p>

          <p>Whilst they are some similar services out there such ASP.Net, Rails, Django Node has the following
            advantages: </p>

          <ul>
            <li>Easy to get started</li>
            <li>Good for prototyping and agile development</li>
            <li>Super fast and highly scalable</li>
            <li>Javascript everywhere</li>
            <li>Cleaner and more consistent codebase</li>
            <li>Largest ecosystem of open-source libs</li>
          </ul>

          <h4>03 Node Architecture</h4>
          <p>Node is a runtime environment for executing Javascript code. Prior to node Javascript was only used to
            write applications that ran on the browser. Every browser has a Javascript engine built-in which takes our
            Javascript code and converts it to machine code. </p>

          <ul>
            <li>Edge Chakra</li>
            <li>Firefox SpiderMonkey</li>
            <li>Chrome v8</li>
          </ul>
          <p>The variety of engines can result in Javacript behaving differently between browsers.</p>
          <p>A browser provides a run-time environment for Javascript. In browsers we have window and document objects
            which allow us to work in the browser environment. </p>

          <p>In 2009 Ryan Dahl took Google's V8 engine and embedded it inside a C++ program called Node - so similar to
            a browser Node is a run-time environment for Javascript code. It contains a Javascript engine that can
            execute our Javascript code. In addition if provides certain objects relevant to the environment in which
            the code is being executed. So instead of window and document objects we have objects like fs for working
            with the file system or os for interrogating the Operating System. </p>

          <p>Node is NOT a programming language like C# or Java. Node is also NOT a framework like ASP.NET or Rails.
            These are frameworks for building web applications. Node is not a framework - it is a run-time environment
            for executing Javascript code </p>

          <h4>04 How Node Works</h4>
          <p>Node applications are highly-scalable. This is because of the non-blocking or asynchronous nature of Node -
            a single thread is used to handle multiple requests. </p>

          <p>In contrast blocking or synchronous architecture (ASP.Net or Rails) means that a single thread is allocated
            to handle that request. If, for example, this involves querying a database the thread must wait until the
            database request is complete. We then require a new thread if we want to serve another client. If we have a
            large number of concurrent clients then at some point we are going to run out of threads - resulting in
            clients waiting for a thread to become available. </p>

          <p>Node applications are asynchronous by default making it ideal for I/O intensive apps (disk or network).
            Node should NOT be used for CPU intensive applications such as video encoding or image manipulation. These
            applications involve a lot of CPU calculations but few operations that touch the file or network
            systems. </p>

          <p>Because Node applications are single threaded when performing the calculations to serve one client other
            clients have to wait - which is what makes it unsuitable for CPU intensive applications. </p>

          <h4>05 Installing Node</h4>

          <p>To see if we already have Node installed:</p>
          <figure>
            <pre class="terminal">node --version</pre>
            <figcaption>Fig 01-001</figcaption>
          </figure>

          <p>Install the latest stable version of Node (by running the installer) from nodejs.org.</p>

          <h4>06 Your First Node Program</h4>
          <p>Create a new file called 06-your-first-node-program.js</p>

          <figure><pre><code class="language-javascript">function sayHello(name) {
  console.log('Hello ' + name);
}

sayHello('Mosh');
          </code></pre>
            <figcaption>Fig 01-002</figcaption>
          </figure>

          <p>Run the application by passing it to Node using the following terminal command:</p>

          <figure>
            <pre class="terminal">node 06-your-first-node-program.js</pre>
            <figcaption>Fig 01-002a</figcaption>
          </figure>

          <p>Node will give the file we specified to v8 for execution.</p>

          <h4>07 Course Structure</h4>

          <p>Section 2 covers the Node Module System which is one of the fundamental concepts in Node. You will learn
            how to create your own modules as well as use the modules built in to the core of Node such as operating
            system, file system http etc. </p>

          <p>Section 3 covers Node Package Manager</p>

          <p>Sections 4 and 5 cover Building RESTful APIs with Express. Throughout these sections we will use a simple
            Javascript array to store our data because before we look at storing data in MongoDb you need to clearly
            understand asynchronous Javascript. </p>

          <p>Section 6 covers Asynchronous Javascript. We will look at how synchronous code differs from asynchronous
            code. We will look at various patterns for working with asynchronous code such as callbacks, promises and
            async and await. </p>

          <p>Sections 7,8 and 9 cover storing data using MongoDb and Mongoose (a library to make working with MongoDb
            easier) </p>

          <p>Section 10 covers Authentication and Authorization including role management using JSON web tokens.</p>

          <p>Section 11 covers handling and logging errors which is a very important topic when building real world
            applications. </p>

          <p>Sections 12 and 13 cover Unit and Integration testing.</p>

          <p>Section 14 looks at Test-driven development which is a way of writing software by writing tests first.</p>

          <p>Section 15 Details how to deploy an application to Heroku.</p>

          <h4>08 Recap</h4>

          <p>Getting Started with Node</p>
          <p>So, in this section, you learned that:</p>
          <ul>
            <li>Node is a runtime environment for executing JS code.</li>
            <li>Essentially, Node is a C++ program that embeds Chrome’s v8 engine, the fastest JS engine in the world.
            </li>
            <li>We use Node to build fast and scalable networking applications. It’s a perfect choice for building
              RESTful services.
            </li>
            <li>Node applications are single-threaded. That means a single thread is used to serve all clients.</li>
            <li>Node applications are asynchronous or non-blocking by default. That means when the application involves
              I/O operations (eg accessing the file system or the network), the thread doesn’t wait (or block) for the
              result of the operation. It is released to serve other clients.
            </li>
            <li>This architecture makes Node ideal for building I/O-intensive applications.</li>
            <li>You should avoid using Node for CPU-intensive applications, such as a video encoding service. Because
              while executing these operations, other clients have to wait for the single thread to finish its job and
              be ready to serve them.
            </li>
            <li>In Node, we don’t have browser environment objects such as window or the document object. Instead, we
              have other objects that are not available in browsers, such as objects for working with the file system,
              network, operating system, etc.
            </li>
          </ul>
          <h4>09 Asking Questions</h4>
          <p>Asking Questions</p>
          <p>Section 1, Lecture 9</p>
          <p>You may have questions throughout your course. Follow these steps to make the most of your course and
            become the best coder you can be. </p>

          <ol>
            <li>Do your own research. You can usually find the answer to your question by googling the question or the
              error you’re experiencing.
            </li>
            <li>Try to solve the problem without “phoning a friend”. Coming to the resolution on your own will help you
              grow and become a stronger coder.
            </li>
            <li>Still stuck? Post your question on the discussion board for the course. My team is here to help!</li>
            <li>Help other students by answering their questions on the discussion board. The best way to learn
              something is to teach it.
            </li>
          </ol>
          <p>“Everyone should know how to code a computer, because it teaches you how to think!” – Steve Jobs</p>

          <p>Happy coding,</p>

          <p>Mosh</p>

          <h3>Section 2 - Node Module System</h3>
          <h4>10 -Introduction</h4>
          <p>Throughout this section we will investigate some of the built in modules in Node:</p>
          <ul>
            <li>os</li>
            <li>fs</li>
            <li>events</li>
            <li>http</li>
          </ul>
          <p>We will also cover how to create your own modules.</p>
          <h4>11 - Global Object</h4>
          <p>Previously we used the console.log command. The console object is known as a global object. It is part of
            the global scope which means we can access it from anywhere in our code. </p>

          <p>There are a bunch of other objects and functions that are globally available in Node. setTimeout() is used
            to call a function after a delay. This function is part of standard Javascript so it can be used on the
            client, in the browser or in Node. We also have: </p>

          <ul>
            <li>clearTimeout()</li>
            <li>setInterval() - call a function repeatedly at a specified interval.</li>
            <li>clearInterval() - stops the function from being called repeatedly.</li>
          </ul>

          <p>The above are all Javascript global objects.</p>

          <p>In browsers we have the window object that represents the global scope. So all the variables and functions
            that are defined globally we can access via the window object: </p>

          <figure>
            <pre><code class="language-javascript">window.console.log</code></pre>
            <figcaption>Fig 02-001</figcaption>
          </figure>
          <p>or</p>
          <figure>
            <pre><code class="language-javascript">console.log</code></pre>
            <figcaption>Fig 02-002</figcaption>
          </figure>

          <p>The Javascript engine will prefix this statement with window.console.log because that is where the object
            is defined. Similarly the setTimeout, clearTimeout, setInterval and clearInterval methods all belong to the
            window object so we can call </p>

          <figure>
            <pre><code class="language-javascript">window.setTimeout</code></pre>
            <figcaption>Fig 02-003</figcaption>
          </figure>

          <p>In Node instead of the window object we have an object called global so the functions discussed above
            through the global object. One thing to know about Node is that a variable declared like this: </p>

          <figure>
            <pre><code class="language-javascript">var message = '';</code></pre>
            <figcaption>Fig 02-004</figcaption>
          </figure>

          <p>is not added to the global object. So, in Node, if we wrote:</p>

          <figure>
            <pre><code class="language-javascript">console.log(global.message);</code></pre>
            <figcaption>Fig 02-005</figcaption>
          </figure>

          <p>we would see 'undefined' in the console. This is due to Node's modular system which we will learn about in
            the next section. </p>

          <h4>12 - Modules</h4>
          <p>In the last section we learned that in client side Javascript, which runs in the browser, when we declare a
            variable or a function it is added to the global scope: </p>

          <figure>
          <pre><code class="language-javascript">var sayHello = function() {

}
window.sayHello();</code></pre>
            <figcaption>Fig 02-005</figcaption>
          </figure>

          <p>The problem with this behaviour is that in a real world application we often split our Javascript code into
            multiple files. This means that it is possible to define the same sayHello function. Because the function is
            added to the global scope one definition will overwrite the other. </p>

          <p>In order to build reliable and maintainable applications we should avoid defining variables and functions
            in the global scope. Instead we need modularity where we create small building blocks or modules where we
            define our variables and functions. They are then encapsulated in that module. </p>

          <p>Every file in a node application is considered a module.</p>

          <p>Variables and functions defined within the module are private (in OOP terms). If we want to make a variable
            of function available outside of the module we need to explicitly export it. </p>

          <p>Every Node application has at least one file or module which we refer to as the main module.</p>

          <p>If we write out the module object to the console:</p>

          <figure>
            <pre><code class="language-javascript">console.log(module)</code></pre>
            <figcaption>Fig 02-006</figcaption>
          </figure>

          <p>We will see a JSON object containing various properties such as id, exports, parent, filename, loaded
            etc: </p>

          <figure>
          <pre><code class="language-json">Module {
  id: '.',
  exports: {},
  parent: null,
  filename: 'C:\\DevelopmentTutorials\\TheCompleteNodeJSCourse\\02-node-module-system\\12-modules.js',
  loaded: false,
  children: [],
  paths:
    [ 'C:\\DevelopmentTutorials\\TheCompleteNodeJSCourse\\02-node-module-system\\node_modules',
      'C:\\DevelopmentTutorials\\TheCompleteNodeJSCourse\\node_modules',
      'C:\\DevelopmentTutorials\\node_modules',
      'C:\\node_modules' ] }</code></pre>
            <figcaption>Fig 02-007</figcaption>
          </figure>

          <h4>13 - Creating a Module</h4>

          <p>Let's add a new module called logger.js for logging messages. The module will be re-used in this
            application and potentially other applications. In this module we will imagine that we are going to use a
            remote logging service for logging our messages. So there are third party websites out there that provide a
            url where we can send an http request to log a message: </p>

          <figure>
            <pre><code class="language-javascript">var url = 'http://mylogger.io/log';</code></pre>
            <figcaption>Fig 02-008</figcaption>
          </figure>

          <p>We also create a function called log that takes a message and sends an http request. For now, for
            simplicity, we will just write the message to the console: </p>

          <figure>
          <pre><code class="language-javascript">function log(message) {
  // Send an HTTP request
}</code></pre>
            <figcaption>Fig 02-009</figcaption>
          </figure>

          <p>The variable and the log function are both scoped to this module - they are private and not visible from
            the outside. </p>

          <p>However in app.js we want to be able to access the log function. So we need to make this public and visible
            from the outside. </p>

          <p>One of the properties of the module object is exports which by default is set to an empty object. Anything
            that we add to this object will be exported from the module: </p>

          <figure>
            <pre><code class="language-javascript">module.exports.log = log;</code></pre>
            <figcaption>Fig 02-010</figcaption>
          </figure>

          <p>Similarly if we wanted to export the url we defined in 13-logger.js we could write the following:</p>

          <figure>
            <pre><code class="language-javascript">module.exports.url = url;</code></pre>
            <figcaption>Fig 02-011</figcaption>
          </figure>

          <p>We can change the name that get's exported:</p>

          <figure>
            <pre><code class="language-javascript">module.exports.endPoint = url;</code></pre>
            <figcaption>Fig 02-012</figcaption>
          </figure>

          <p>We only export a subset of functions from modules - keeping other details private.</p>

          <h4>14 - Loading a Module</h4>

          <p>To load a module we use the require function:</p>

          <figure>
            <pre><code class="language-javascript">require('./13-logger');</code></pre>
            <figcaption>Fig 02-013</figcaption>
          </figure>

          <p>This is a node function it is not available in the browser. The js file extension is optional as Node
            assumes we will specify a Javascript file and therefore automatically adds the js extension. </p>

          <p>If the file was in a sub-folder we could specify:</p>

          <figure>
            <pre><code class="language-javascript">require('./subFolder/logger');</code></pre>
            <figcaption>Fig 02-014</figcaption>
          </figure>

          <p>or if the file was in a parent folder:</p>

          <figure>
            <pre><code class="language-javascript">require('../logger');</code></pre>
            <figcaption>Fig 02-015</figcaption>
          </figure>

          <p>The require function returns the object that is exported from the specified module.</p>

          <p>To demonstrate write the following:</p>

          <figure>
          <pre><code class="language-javascript">var logger = require('./logger');

console.log(logger);</code></pre>
            <figcaption>Fig 02-016</figcaption>
          </figure>

          <p>Then we run the application we get an object with a single method called log that is a function. We can now
            call this function in app.js: </p>

          <figure>
            <pre><code class="language-javascript">logger.log('message');</code></pre>
            <figcaption>Fig 02-017</figcaption>
          </figure>

          <p>In more recent versions of Javascript we have the ability to use a const. So, as a best practice, when
            loading a module using the require function it is better to store the result in constant: </p>

          <figure>
            <pre><code class="language-javascript">const logger = require('./13-logger');</code></pre>
            <figcaption>Fig 02-018</figcaption>
          </figure>

          <p>This prevents us from accidentally overwriting the value of logger:</p>
          a
          <figure>
            <pre><code class="language-javascript">logger = 1;</code></pre>
            <figcaption>Fig 02-019</figcaption>
          </figure>

          <p>When using a const this will result in a "Assignment to constant variable" error.</p>

          <p>One last thing to mention is that sometimes instead of exporting an object from a module you might want to
            export a single function. For example, in our logger module, we don't necessarily need an object because we
            have a single method. An object would be useful if we had multiple methods or properties but in this case we
            can export a single function: </p>

          <figure>
            <pre><code class="language-javascript">module.exports = log;</code></pre>
            <figcaption>Fig 02-020</figcaption>
          </figure>

          <p>then in app.js call the function directly:</p>

          <figure>
            <pre><code class="language-javascript">logger('message');</code></pre>
            <figcaption>Fig 02-021</figcaption>
          </figure>

          <h4>15 Module Wrapper Function</h4>

          <p>You now know that the variables and functions defined in a module are scoped to that module. How does Node
            do this? To illustrate let's introduce a syntax error to the first line of logger.js (this must be on the
            first line): </p>

          <figure>
            <pre><code class="language-javascript">var x=;</code></pre>
            <figcaption>Fig 02-022</figcaption>
          </figure>

          <p>If you run logger.js you will receive the following error:</p>

          <figure>
          <pre><code class="language-javascript">(function (exports, require, module, __filename, __dirname) { var x =;

            SyntaxError: Unexpected token ;</code></pre>
            <figcaption>Fig 02-023</figcaption>
          </figure>

          <p>If you look above the SyntaxError message you will see a function declaration which accepts the following
            parameters - exports, require, module, __filename, __dirname. </p>

          <p>Under the hood Node does not execute the code defined in our module directly. Instead it wraps it inside a
            function (the one we saw in the error message above). So, at runtime, our code will look similar to this (we
            will remove the syntax error): </p>

          <figure>
          <pre><code class="language-javascript">(function (exports, require, module, __filename, __dirname) {
  var url = 'http://mylogger.io/log';

  function log(message) {
    // Send an HTTP request
    console.log(message);
  }

  module.exports = log;
})</code></pre>
            <figcaption>Fig 02-024</figcaption>
          </figure>

          <p>The actual code is more complex than shown above but to avoid distracting from the topic we will keep the
            example simple. More advanced Javascript developers will recognise the code above as an Immediately Invoked
            Function Expression of IIFE. </p>

          <p>The takeaway is that Node never executes our code directly. Instead it wraps each module in a function.
            Looking at the parameters that the module accepts we have require (which we have seen before). The require
            function appears to be global but actually it is local to each module - in every module require is one of
            the parameter passed into the function. </p>

          <p>The function is known as the Module Wrapper Function. We have also used the module function previously. The
            exports parameter is a shortcut to module.exports so we could write: </p>

          <figure>
            <pre><code class="language-javascript">module.exports.log = log;</code></pre>
            <figcaption>Fig 02-025</figcaption>
          </figure>

          <p>or</p>

          <figure>
            <pre><code class="language-javascript">exports.log = log;</code></pre>
            <figcaption>Fig 02-026</figcaption>
          </figure>

          <p>However you can't reset exports like this:</p>

          <figure>
            <pre><code class="language-javascript">exports = log; // module.exports</code></pre>
            <figcaption>Fig 02-027</figcaption>
          </figure>

          <p>In addition we also have __filename and __dirname parameters which represent the name of the file and the
            path. Let's take a look: </p>

          <figure>
          <pre><code class="language-javascript">console.log(__filename);
console.log(__dirname);

__dirname returns a path to the directory that contains that module.</code></pre>
            <figcaption>Fig 02-028</figcaption>
          </figure>

          <h4>16 Path Module</h4>
          <p>In the last section we mentioned that there are a few useful modules that are built into the core of Node.
            These modules allow you to work with files, the network, operating system etc. and include the
            following: </p>

          <ul>
            <li>File System - work with files.</li>
            <li>HTTP - create web servers that listen for HTTP requests.</li>
            <li>OS - work with the Operating System.</li>
            <li>Path - provides utilities for working with paths.</li>
            <li>Process - information about the current process.</li>
            <li>Query Strings - useful when building HTTP services.</li>
            <li>Stream - for working with streams of data.</li>
          </ul>

          <p>In this section we will investigate the Path module. If you run
            <span class="filename">16-path-module.js</span> you will get the following information: </p>

          <figure>
          <pre><code class="language-javascript">{ root: 'C:\\',
    dir: 'C:\\DevelopmentTutorials\\TheCompleteNodeJSCourse\\02-node-module-system',
    base: '16-path-module.js',
    ext: '.js',
name: '16-path-module' }</code></pre>
            <figcaption>Fig 02-029</figcaption>
          </figure>

          <h4>17 OS Module</h4>
          <p>This section describes how to get information about the current operating system. Some of the available
            methods include: </p>
          <ul>
            <li>freemem</li>
            <li>totalmem</li>
            <li>userInfo([options])</li>
            <li>uptime</li>
          </ul>

          <p>If you run 17-os-module.js you will get the following information:</p>

          <figure>
          <pre class="terminal">Total Memory: 17081073664
Free Memory: 10441883648</pre>
            <figcaption>Fig 02-030</figcaption>
          </figure>

          <p>Before node it was not possible to get information about the operating system using Javascript. Javascript
            only ran inside a browser and we could only work with the Window or Document objects. </p>

          <h4>18 File System Module</h4>
          <p>Almost all of the functions in the fs module come in two forms - synchronous (blocking) or asynchronous
            (non-blocking). Where possible you should avoid using the synchronous methods. As we mentioned in the
            previous section a Node process has a single thread. If you are u using Node to build the backend for your
            application you may have hundreds or thousands of clients connecting to that back-end. </p>

          <p>If you keep that client busy you wont be able serve many clients.</p>

          <p>All the asynchronous methods take a function as their last argument. This function is known as a
            callback. </p>

          <h4>19 Events Module</h4>
          <p>One of the core concepts in Node is events. An event is basically a signal that indicates that something
            has happened in our application. </p>

          <p>In the Events module we have a class called EventEmitter. When we call require events the require function
            returns an EventEmitter class (hence the casing): </p>

          <figure>
            <pre><code class="language-javascript">const EventEmitter = require('events');</code></pre>
            <figcaption>Fig 02-031</figcaption>
          </figure>

          <p>We then create an instance of the EventEmitter class:</p>

          <figure>
            <pre><code class="language-javascript">const emitter = new EventEmitter();</code></pre>
            <figcaption>Fig 02-032</figcaption>
          </figure>

          <p>The emit method raises an event:</p>

          <figure>
            <pre><code class="language-javascript">emitter.emit('messageLogged');</code></pre>
            <figcaption>Fig 02-033</figcaption>
          </figure>

          <p>In order to respond to the event being raised we need to register a listener:</p>

          <figure>
          <pre><code class="language-javascript">emitter.on('messageLogged', function() {
  console.log('Listener called');
});</code></pre>
            <figcaption>Fig 02-034</figcaption>
          </figure>

          <p>the on method takes two arguments - the name of the event to listen for and a callback function.</p>

          <p>The order in which you define the emitter and the listener is important. If you register the listener after
            calling the emit method it will not pick up the event. This is because when we call the emit method it
            iterates over all the registered listeners and calls them synchronously. </p>

          <h4>20 Event Arguments</h4>

          <p>Often when you raise an event you also want to send some information about that event. As an example, let's
            assume that when we log a message our remote login service might generate an id for that message. Perhaps we
            want to return that id to the client or it may give us a Url to access that log message directly. When
            raising an event, we can add additional arguments, referred to as event arguments: </p>

          <figure>
            <pre><code class="language-javascript">emitter.emit('messageLogged', 1, 'url');</code></pre>
            <figcaption>Fig 02-035</figcaption>
          </figure>

          <p>The magic values that we supply above are a bit confusing. A better practice is to encapsulate the values
            inside an object: </p>

          <figure>
            <pre><code class="language-javascript">emitter.emit('messageLogged', {id: 1, url: 'http://' });</code></pre>
            <figcaption>Fig 02-036</figcaption>
          </figure>

          <p>When registering the listener the callback function can also recieve the event argument:</p>

          <figure>
          <pre><code class="language-javascript">emitter.on('messageLogged', function(arg) {
  console.log('Listener called');
});</code></pre>
            <figcaption>Fig 02-037</figcaption>
          </figure>

          <p>One last way to simplify the code is to use the ECMAScript 6 arrow function. An arrow functon allows you to
            remove the function keyword and add an arrow =&gt;: </p>

          <h4>21 Extending Event Emitter</h4>

          <p>In the real world it is quite rare that you would work with the EventEmitter directly. Instead you normally
            create a class that has all the abilities of the EventEmitter and then you would use that class in your
            code. </p>

          <p>To explain open the 21-logger.js module where we are exporting a simple logger function called log which
            writes the message to the console. After this we want to raise an event. Later in the app module we will
            respond to that event. </p>

          <p>We create a class in 21-logger.js called Logger that extends the EventEmitter class:</p>

          <figure>
            <pre><code class="language-javascript">class Logger extends EventEmitter {</code></pre>
            <figcaption>Fig 02-038</figcaption>
          </figure>

          <p>This gives the Logger class all the functionality that is defined in EventEmitter but we can also add
            additional functionality. When a function is defined in a class it is known as a method. Also, the function
            keyword is not required. </p>

          <p>Instead of using the EventEmitter class in 21-logger.js we use an instance of the logger class</p>

          <h4>22 HTTP Module</h4>
          <p>One of the powerful building blocks of Node is the Http module that we use for creating networking
            applications. For example, we can create a web server that listens for Http requests on a given port. With
            this we can easily create a backend service for our client applications - like a web application that we
            build with React or Angular or a mobile application running on a mobile device. </p>

          <p>In the real world we are not going to use the Http module to build a backend service for our application.
            The reason is that as we add more routes our code becomes complicated. Instead we use a framework called
            express which gives our application a clean structure to handle various routes. Internally the express
            framework is built on top of the Http module in Node. </p>

          <h4>23 Recap</h4>

          <h4>Node Core</h4>
          <p>So, in this section, you learned that:</p>
          <ul>
            <li>We don’t have the window object in Node.</li>
            <li>The global object in Node is “global”.</li>
            <li>Unlike browser applications, variables we define are not added to the “global” object.</li>
            <li>Every file in a Node application is a module. Node automatically wraps the code in each file with an
              IIFE (Immediately-invoked Function Expression) to create scope. So, variables and functions defined in one
              file are only scoped to that file and not visible to other files unless explicitly exported.
            </li>
            <li>To export a variable or function from a module, you need to add them to module.exports:
              <code class="language-">module.exports.sayHello = sayHello;</code></li>
            <li>To load a module, use the require function. This function returns the module.exports object exported
              from the target module: <code class="language-">const logger = require(‘./logger’);</code></li>
            <li>Node has a few built-in modules that enable us to work with the file system, path objects, network,
              operating system, etc.
            </li>
            <li>EventEmitter is one of the core classes in Node that allows us to raise (emit) and handle events.
              Several built-in classes in Node derive from EventEmitter.
            </li>
            <li>To create a class with the ability to raise events, we should extend EventEmitter:
              <code class="language-">class Logger extends EventEmitter { }</code></li>
          </ul>
          <h3>Section 3 - Node Package Manager</h3>
          <h4>24 Introduction</h4>
          <p>NPM or Node Package Manager is command line tool as well as a registry of third party libraries that we can
            add to our Node applications. So for pretty much any kind of functionality that you want to add to your
            application there is most likely a free open source library/package or node module on npmjs.com.</p>

          <p>npm gets installed when you install node.</p>

          <p>To display the version of npm you have installed</p>
          <figure>
            <pre class="terminal">npm -v</pre>
            <figcaption>Fig 03-001</figcaption>
          </figure>

          <p>To display the version of node you have installed</p>
          <figure>
            <pre class="terminal">node -v</pre>
            <figcaption>Fig 03-002</figcaption>
          </figure>
          <p>To install a specific version of npm globally:</p>
          <figure>
            <pre class="terminal">npm i -g npm@5.5.1</pre>
            <figcaption>Fig 03-003</figcaption>
          </figure>
          <h4>25 package.json</h4>
          <p>package.json is a Json file that contains some basic information about the application or the project such
            as: </p>
          <ul>
            <li>name</li>
            <li>version</li>
            <li>authors</li>
            <li>address of git repo</li>
          </ul>
          <p>All node applications have a package.json file by default.</p>
          <p>To create a package.json file we run</p>
          <figure>
            <pre class="terminal">npm init</pre>
            <figcaption>Fig 03-004</figcaption>
          </figure>
          <p>To create a package.json file without specifying any options:</p>
          <figure>
            <pre class="terminal">npm init --yes</pre>
            <figcaption>Fig 03-005</figcaption>
          </figure>

          <h4>26 Installing a Node Package</h4>
          <p>The underscore library is a Javascript utility menu:</p>
          <figure>
            <pre class="terminal">npm i underscore</pre>
            <figcaption>Fig 03-006</figcaption>
          </figure>
          <p>This will do two things:</p>
          <ul>
            <li>Adds a dependencies section to <span class="filename">pacakage.json</span></li>
            <li>Downloads underscore into the node_modules folder</li>
          </ul>
          <p>In the underscore folder there will be another <span class="filename">package.json</span> file. Every node
            module has a package.json file just like our node application. </p>
          <p>As an aside, there is no longer a need to supply the --save flag when running npm install because the
            dependency is written to the package.json file by default.</p>
          <h4>27 Using a Package</h4>
          <figure>
              <pre>
<code class="language-javascript">var _ = require('underscore');</code></pre>
            <figcaption>Fig 03-007-</figcaption>
          </figure>
          <p>The require function first assumes that the module name supplied is a core module. In node we don't have a
            core module called underscore so the require function thinks maybe underscore is a file or folder in this
            project. Earlier in the course we learnt that in order to reference a file or folder we use ./ but our node
            application does not contain a file or folder called underscore so the require function then moves onto the
            third step. It assumes that the module exists inside the node_modules folder. </p>
          <h4>28 Package Dependencies</h4>
          <p>Install mongoose:</p>
          <figure>
            <pre class="terminal">npm i mongoose</pre>
            <figcaption>Fig 03-008</figcaption>
          </figure>
          <p>This should update our package.json file. The node_modules folder will contain a number of new folders -
            these are other node packages that mongoose is dependent upon.</p>
          <p>In the previous version of npm we had a different behaviour. All the dependencies of a given package were
            stored inside that package folder. However this created a mess because we ended up with the same package
            being installed multiple times. Also, in Windows, there is a limitation with the number of characters in a
            path.</p>
          <p>With current version of npm all dependencies as well as their dependencies are stored under the main
            node_modules folder. The exception is that if one of the packages uses a different version of a dependency
            then that version will be stored locally with that package.</p>
          <h4>29 NPM Packages and SCM</h4>
          <p>In a real world application we will have a large number of child folders in the node_modules folder. The
            size of the node_modules folder will be several megabytes. When checking in your source code you want to
            exclude this folder. This prevents people from having to wait around to download this large folder. </p>
          <p>So what about all our dependencies. Well these are all stored in the package.json file. We can restore all
            our dependencies by running: </p>
          <figure>
            <pre class="terminal">npm i</pre>
            <figcaption>Fig 03-009</figcaption>
          </figure>
          <p>This will download the relevant dependencies from npm registry.</p>
          <p>We will describe the steps required to exclude the node_modules folder from git.</p>
          <p>If you run:</p>
          <figure>
            <pre class="terminal">git status</pre>
            <figcaption>Fig 03-010</figcaption>
          </figure>
          <p>you should see that the <span class="filename">node_modules</span> folder is listed as one of the files or
            folders to be uploaded to git. </p>
          <p>If we add a file called <span class="filename">.gitignore</span> to the root folder with the following
            contents:</p>
          <figure>
              <pre>
<code class="language-json">node_modules/</code></pre>
            <figcaption>Fig 03-011</figcaption>
          </figure>
          <p>and then run:</p>
          <figure>
            <pre class="terminal">git status</pre>
            <figcaption>Fig 03-012</figcaption>
          </figure>
          <p>again you should see the node_modules folder is now excluded from the list of files or folders to be
            uploaded to git. </p>
          <p>Finally we can run</p>
          <figure>
<pre class="terminal">git add .
git commit -m "Our first commit"</pre>
            <figcaption>Fig 03-013</figcaption>
          </figure>
          <h4>30 Semantic Versioning</h4>
          <p>Earlier we mentioned the caret character:</p>
          <figure>
              <pre>
<code class="language-json">"mongoose": "^4.13.6"</code></pre>
            <figcaption>Fig 03-014</figcaption>
          </figure>
          <p>In order to understand it's purpose we first need to understand Semantic Versioning or SemVer. In Semantic
            Versioning the version of a node package has three components. The first number is the major version, the
            second is the minor version, the third is the patch version. </p>
          <p>Consider the above mongoose dependency. If the developers of mongoose discover a bug in this version they
            will fix the bug and release a new version 4.13.7. </p>
          <p>The minor version is used for adding new features that don't break the existing API: 4.14.0. The patch
            version is 0 here because the developers have not yet found a bug. </p>
          <p>Finally if they add a new features that could potentially break the existing applications that depend upon
            this version of mongoose then they will increase the major version: 5.0.0</p>
          <p>The caret character in the following dependency declaration:</p>
          <figure>
              <pre>
<code class="language-json">&quot;mongoose&quot;: &quot;^4.13.6&quot;</code></pre>
            <figcaption>Fig 03-015</figcaption>
          </figure>
          <p>tells npm that we are interested in any version of mongoose as long as the major version is 4. So any newer
            minor or patch versions will be downloaded and installed when you run: </p>
          <figure>
            <pre class="terminal">npm i</pre>
            <figcaption>Fig 03-016</figcaption>
          </figure>
          <p>An alternative to using the caret character is to specify the following:</p>
          <figure>
            <pre><code class="language-json">&quot;mongoose&quot;: &quot;4.x&quot;</code></pre>
            <figcaption>Fig 03-017</figcaption>
          </figure>
          <p>The other character used by npm is ~:</p>
          <figure>
            <pre><code class="language-json">&quot;underscore&quot;: &quot;~1.8.3&quot;</code></pre>
            <figcaption>Fig 03-018</figcaption>
          </figure>
          <p>This example means that you are interested in any version as long as the major version is 1 and the minor
            version is 8. This can also be written: </p>
          <figure>
            <pre><code class="language-json">&quot;underscore&quot;: &quot;~1.8.x&quot;</code></pre>
            <figcaption>Fig 03-019</figcaption>
          </figure>
          <p>If you want to ensure that an exact version of a node package is used then use:</p>
          <figure>
            <pre><code class="language-json">&quot;underscore&quot;: &quot;1.8.3&quot;</code></pre>
            <figcaption>Fig 03-020</figcaption>
          </figure>
          <h4>31 Listing the Installed Packages</h4>
          <p>To show all the npm packages and their dependencies:</p>
          <figure>
            <pre class="terminal">npm list</pre>
            <figcaption>Fig 03-021</figcaption>
          </figure>
          <p>The resulting tree displays the dependencies of your application and their dependencies.</p>
          <p>To list just the dependencies of your application:</p>
          <figure>
            <pre class="terminal">npm list --depth=0</pre>
            <figcaption>Fig 03-022</figcaption>
          </figure>
          <h4>32 Viewing Registry Info for a Package</h4>
          <p>To show metadata about a package (license details, dependencies etc.)</p>
          <figure>
            <pre class="terminal">npm view mongoose</pre>
            <figcaption>Fig 03-023</figcaption>
          </figure>
          <p>To view a specific property:</p>
          <figure>
              <pre class="terminal">npm view mongoose versions
npm view mongoose dependencies</pre>
            <figcaption>Fig 03-024</figcaption>
          </figure>
          <p>This will display a subset of the information you get from npm view.</p>
          <h4>33 Installing a Specific Version of a Package</h4>
          <p>To install a specific version of a package us the @</p>
          <figure>
            <pre class="terminal">npm i mongoose@2.4.2</pre>
            <figcaption>Fig 03-025</figcaption>
          </figure>
          <h4>34 Update Local Packages</h4>
          <p>To show dependencies that are out of date:</p>
          <figure>
            <pre class="terminal">npm outdated</pre>
            <figcaption>Fig 03-026</figcaption>
          </figure>
          <p>To update minor and patch releases:</p>
          <figure>
            <pre class="terminal">npm update</pre>
            <figcaption>Fig 03-027</figcaption>
          </figure>
          <p>To update dependencies to the very latest versions we need to install:</p>
          <figure>
            <pre class="terminal">npm i -g npm-check-updates</pre>
            <figcaption>Fig 03-028</figcaption>
          </figure>
          <p>Now to update the package.json file</p>
          <figure>
            <pre class="terminal">ncu -u</pre>
            <figcaption>Fig 03-029</figcaption>
          </figure>
          <p>This just updates package.json. Then to install the dependency run:</p>
          <figure>
            <pre class="terminal">npm i</pre>
            <figcaption>Fig 03-030</figcaption>
          </figure>
          <h4>35 DevDependencies</h4>
          <p>So far all the dependencies we have installed are application dependencies such as mongoose and underscore
            - our application needs these dependencies in order to function properly. </p>
          <p>Sometimes we use dependencies that are only required during development.</p>
          <p>For example:</p>
          <ul>
            <li>tools for running unit tests</li>
            <li>
              tools for performing static analysis on our code
            </li>
            <li>tools for bundling Javascript</li>
          </ul>
          <p>These dependencies should not go into the production environment where we deploy our application.</p>
          <p>To install dev dependencies</p>
          <figure>
            <pre class="terminal">npm i jshint --save-dev</pre>
            <figcaption>Fig 03-031</figcaption>
          </figure>
          <p>You should see jshint has been added to a devDependencies section in
            <span class="filename">package.json</span>.</p>
          <h4>36 Uninstalling a Package</h4>
          <p>To uninstall a package:</p>
          <figure>
            <pre class="terminal">npm un mongoose</pre>
            <figcaption>Fig 03-032</figcaption>
          </figure>
          <h4>37 Working with Global Packages</h4>
          <p>To install a global package:</p>
          <figure>
            <pre class="terminal">npm i -g npm</pre>
            <figcaption>Fig 03-033</figcaption>
          </figure>
          <p>All the commands listed so far work with the global flag:</p>
          <figure>
            <pre code class="terminal">npm -g outdated</pre>
            <figcaption>Fig 03-034</figcaption>
          </figure>
          <p>To uninstall a global package:</p>
          <figure>
            <pre class="terminal">npm un -g npm</pre>
            <figcaption>Fig 03-035</figcaption>
          </figure>
          <h4>38 Publishing a Package</h4>
          <p>To publish a npm package:</p>
          <p>create a new directory (e.g. lion-lib) and add a package.json. Add a new file: index.js with required
            code:</p>
          <figure>
            <pre><code class="language-javascript">module.exports.add = function(a, b) { return a + b }</code></pre>
            <figcaption>Fig 03-036</figcaption>
          </figure>
          <p>If you don't have an account on npmjs.com you will need to run</p>
          <figure>
            <pre class="terminal">npm add user </pre>
            <figcaption>Fig 03-037</figcaption>
          </figure>
          <p>or if you have already got an account:</p>
          <figure>
            <pre class="terminal">npm login</pre>
            <figcaption>Fig 03-038</figcaption>
          </figure>
          <p>When logged in issue the following command:</p>
          <figure>
            <pre class="terminal">npm publish</pre>
            <figcaption>Fig 03-039</figcaption>
          </figure>
          <p>You will need to update the package name in package.json.</p>
          <p>We should now be able to use this package in another node application:</p>
          <figure>
            <pre><code class="language-javascript">var lion = require('lion-lib');</code></pre>
            <figcaption>Fig 03-040</figcaption>
          </figure>
          <h4>39 Updating a Published Package</h4>
          <p>If we run:</p>
          <figure>
            <pre class="terminal">npm publish</pre>
            <figcaption>Fig 03-041</figcaption>
          </figure>
          <p>from the lion-lib folder we receive an error:</p>
          <figure>
            <pre class="terminal">"You cannot publish over the previously published version 1.0.0: lion-lib"</pre>
            <figcaption>Fig 03-042</figcaption>
          </figure>
          <p>Depending on the kind of change we have made the we need to update the version number. In this instance we
            will just update the minor version: </p>
          <figure>
            <pre class="terminal">npm version minor</pre>
            <figcaption>Fig 03-043</figcaption>
          </figure>
          <p>then publish to npm:</p>
          <figure>
            <pre class="terminal">npm publish</pre>
            <figcaption>Fig 03-044</figcaption>
          </figure>
          <h4>40 Recap</h4>
          <h4>NPM</h4>
          <p>So, in this section, you learned that:</p>
          <p>Every Node application has a package.json file that includes metadata about the application. This includes
            the name of the application, its version, dependencies, etc. </p>
          <p>We use NPM to download and install 3rd-party packages from NPM registry. All the installed packages and
            their dependencies are stored under <span class="filename">node_modules</span> folders. This folder should
            be excluded from the source control.
          <p>Node packages follow semantic versioning: major.minor.patch</p>
          <p>Useful NPM commands are:</p>
          <p>Install a package</p>
          <figure>
            <pre class="terminal">npm i &lt;packageName&gt;</pre>
            <figcaption>Fig 03-045</figcaption>
          </figure>
          <p>Install a specific version of a package</p>
          <figure>
            <pre class="terminal">npm i &lt;packageName&gt;@&lt;version&gt;</pre>
            <figcaption>Fig 03-046</figcaption>
          </figure>
          <p>Install a package as a development dependency</p>
          <figure>
            <pre class="terminal">npm i &lt;packageName&gt; &mdash;save-dev</pre>
            <figcaption>Fig 03-047</figcaption>
          </figure>
          <p>Uninstall a package</p>
          <figure>
            <pre class="terminal">npm un &lt;packageName&gt;</pre>
            <figcaption>Fig 03-048</figcaption>
          </figure>
          <p>List installed packages</p>
          <figure>
            <pre class="terminal">npm list —depth=0</pre>
            <figcaption>Fig 03-049</figcaption>
          </figure>
          <p>View outdated packages</p>
          <figure>
            <pre class="terminal">npm outdated</pre>
            <figcaption>Fig 03-050</figcaption>
          </figure>
          <p>Update packages</p>
          <figure>
            <pre class="terminal">npm update</pre>
            <figcaption>Fig 03-051</figcaption>
          </figure>
          <p>To install/uninstall packages globally, use -g flag</p>
          <h3>Section 4 - Building RESTful API's Using Express</h3>
          <h4>41 Introduction</h4>
          <p>Earlier in the course we covered the HTTP module. We used this to create a web server that listens on port
            3000 and responds to requests made on the /api/courses endpoint. While this approach is fine, it is not
            suitable for building a large complex application because you will more than likely end up adding a lot of
            endpoints. So in this section we will look at express which is a fast and lightweight framework for building
            web applications.</p>
          <h4>42 RESTful Services</h4>
          <p>Most applications follow the Client/Server architecture Communication between the Client and Server occurs
            over HTTP We expose services on the Server that are available to the client via HTTP requests This process
            uses REST (REpresentational State Transfer) - REST is basically a principle for building these HTTP
            services</p>
          <p>We use simple HTTP protocol principles to provide support to Create, Read, Update and Delete data -
            referred to as CRUD</p>
          <p>We expose endpoints like this:</p>
          <figure>
            <pre class="terminal">http://vidly.com/api/customers</pre>
            <figcaption>Fig 04-001</figcaption>
          </figure>
          <p>The client can send http requests to this endpoint to talk to our service.
          The type of the http request determines the operation. Every http request has a verb or method that determines
          it's intention: </p>

          <table>
            <tr>
              <td>GET</td>
              <td>Get</td>
              <td>/api/customers, /api/customers/1</td>
              <td></td>
            </tr>
            <tr>
              <td>POST</td>
              <td>Create</td>
              <td>/api/customers/</td>
              <td>Include customer object in the body of the request</td>
            </tr>
            <tr>
              <td>PUT</td>
              <td>Update</td>
              <td>/api/customers/1</td>
              <td>Include customer object in the body of the request</td>
            </tr>
            <tr>
              <td>DELETE</td>
              <td>Delete</td>
              <td>/api/customers/1</td>
              <td></td>
            </tr>
          </table>
          <h4>43 Introducing Express</h4>
          <p>As we define more routes for our application it will become necessary to use a framework to give our
            application a proper structure. This means we can easily add more routes whilst keeping our application code
            maintainable. express is one of the most popular frameworks for this purpose. It can be installed using
            npm:</p>
          <figure>
            <pre class="terminal">npm i express</pre>
            <figcaption>Fig 04-002</figcaption>
          </figure>

          <h4>44 Building Your First Web Server</h4>
          <p>We will add a new file called index.js (it could also be called app.js). First we load the express
            module:</p>
          <figure>
          <pre><code class="language-javascript">const express = require('express'); 
const app = express();</code></pre>
            <figcaption>Fig 04-003</figcaption>
          </figure>

          <p>The <code class="language-">app</code> object exposes several useful methods:</p>
          <figure>
          <pre><code class="language-javascript">app.get(); 
app.post();
app.put();
app.delete();</code></pre>
            <figcaption>Fig 04-004</figcaption>
          </figure>
          <p>All these methods correspond to the http verbs discussed earlier. So we could do the following:</p>
          <figure>
          <pre><code class="language-javascript">app.get('/', (req, res) =&gt; { res.send('Hello World'); });
app.listen(3000, () =&gt; console.log('Listening on port 3000...'));</code></pre>
            <figcaption>Fig 04-005</figcaption>
          </figure>
          <p>In the terminal issue the following command:</p>
          <figure>
            <pre class="terminal">node index.js</pre>
            <figcaption>Fig 04-006</figcaption>
          </figure>
          <p>Now in chrome browse to localhost:3000 and you should see the "Hello World" message.</p>
          <p>Now let's define another route:</p>
          <figure>
            <pre><code class="language-javascript">app.get('/api/courses', (req, res) =&gt; { res.send([1, 2, 3]); });</code></pre>
            <figcaption>Fig 04-007</figcaption>
          </figure>
          <p>Now we have to restart the process in the terminal using Ctrl+C</p>
          <p>So in this implementation we don't have the if blocks we used earlier in the HTTP module code. Instead we
            define new routes by calling app.get. As our application grows we are free to move routes to other files
            (e.g. courses.js for routes related to courses).</p>
          <h4>45 Nodemon</h4>
          <p>Up to this point, each time the code is changed we have been required to restart the node process in the
            terminal. We can use the nodemon node package to watch for changes and restart our process
            automatically:</p>
          <figure>
            <pre class="terminal">npm i -g nodemon</pre>
            <figcaption>Fig 04-008</figcaption>
          </figure> 
          <p>now instead of using node to run our application we use nodemon:</p>

          <figure>
            <pre class="terminal">nodemon index.js</pre>
            <figcaption>Fig 04-009</figcaption>
          </figure>
          <p>If you make a change to one of the routes and refresh the browser you should see the change takes effect
            immediately - there is no need to restart the process manually. nodemon also writes "[nodemon] restarting
            due to changes....." to the terminal</p>
          <h4>46 Environment Variables</h4>
          <p>One thing we could improve on in the code is switching the hard coded port value of 3000:</p>
          <figure>
            <pre><code class="language-javascript">app.listen(3000, () =&gt; console.log('Listening on port 3000...'));</code></pre>
            <figcaption>Fig 04-010</figcaption>
          </figure>
          <p>For an environment variable. 3000 is an arbitrary number. While this should work on your development
            machine it is unlikely to work in a development environment. In a hosting environment the port will be
            dynamically assigned.</p>
          <p>We can read the value of environment variable using the process object:</p>
          <figure>
          <pre><code class="language-javascript">const port = process.env.PORT || 3000; 
app.listen(port, () =&gt; console.log(`Listening on port ${port}...`));</code></pre>
            <figcaption>Fig 04-011</figcaption>
          </figure>
          <p>To set an environment variable on Mac use:</p>
          <figure>
            <pre class="terminal">export PORT=5000</pre>
            <figcaption>Fig 04-012</figcaption>
          </figure>
          <p>On Windows use:</p>
          <figure>
            <pre class="terminal">setx PORT "5000"</pre>
            <figcaption>Fig 04-013</figcaption>
          </figure>
          <p>You should receive the following message:</p>
          <figure>
            <pre class="terminal">SUCCESS: Specified value was saved.</pre>
            <figcaption>Fig 04-014</figcaption>
          </figure>
          <p>You will also need to restart Webstorm to pickup the changes. Now if we run the application using 
            nodemon:</p>
          <figure>
            <pre class="terminal">nodemon index.js</pre>
            <figcaption>Fig 04-015</figcaption>
          </figure>
          <p>You should see something similar to this:</p>

          <figure>
          <pre class="terminal">[nodemon] 1.17.1 [nodemon] to restart at any time, enter `rs` [nodemon] watching:
*.* [nodemon] starting `node
  index.js`
  Listening on port 5000...</pre>
            <figcaption>Fig 04-016</figcaption>
          </figure>
          <h4>47 Route Parameters</h4>
          <p>Currently we have a route for getting the list of courses:</p>
          <figure>
            <pre><code class="language-javascript">app.get('/api/courses', (req, res) =&gt; { res.send([1, 2, 3]); });</code></pre>
            <figcaption>Fig 04-017</figcaption>
          </figure>
          <p>In this section we will demonstrate how to create a route that gets a single course. In the discussion
            earlier on RESTful services we said that in order to retrieve a single course we include the id of the
            course in the url:</p>
          <figure>
            <pre class="terminal">// /api/courses/1</pre>
            <figcaption>Fig 04-018</figcaption>
          </figure>
          <p>To implement a route like this use the following:</p>
          <figure>
            <pre><code class="language-javascript">app.get('/api/courses/:id', (req, res) =&gt; { res.send(req.params.id); });</code></pre>
            <figcaption>Fig 04-019</figcaption>
          </figure>
          <p>Now in chrome if you browse to <code class="terminal">localhost:3000/api/courses/1</code> you should see the course id of "1"
            displayed.</p>
          <p>It is possible to have multiple parameters in a route. Imagine a route for managing blog posts:</p>
          <figure>
            <pre><code class="language-javascript">app.get('/api/posts/:year/:month', (req, res) =&gt; { res.send(req.params); });</code></pre>
            <figcaption>Fig 04-020</figcaption>
          </figure>
          <p>If you browse to localhost:5000/api/posts/2018/1 you should see the following:</p>
          <figure>
          <pre><code class="language-json">// 20181004180450 // http://localhost:5000/api/posts/2018/1

{ &quot;year&quot;: &quot;2018&quot;, &quot;month&quot;: &quot;1&quot; }</code></pre>
            <figcaption>Fig 04-021</figcaption>
          </figure>
          <p>This is the req.params object. With express we can retrieve querystring parameters as well as route
            parameters. These are parameters that appear in the Url after a question mark. For example we can get all
            the posts for January 2018 and sort by name using the following:</p>
          <figure>
            <pre class="terminal">http://localhost:5000/api/posts/2018/1?sortBy=name</pre>
            <figcaption>Fig 04-022</figcaption>
          </figure>
          <p>By convention, route parameters are used for mandatory values whereas query parameters are used for
            optional values. We can read a url parameter like so:</p>
          <figure>
            <pre><code class="language-javascript">req.query;</code></pre>
            <figcaption>Fig 04-023</figcaption>
          </figure>
          <p>Query parameters are stored in an object with key value pairs.</p>
          <h4>48 Handling HTTP GET Requests</h4>
          <p>Now let's implement a new endpoint to get a single course from the server. Define an array called
            courses:</p>
          <figure>
            <pre><code class="language-javascript">const courses = [ { id: 1, name: 'course1' }, { id: 2, name: 'course2' }, { id: 3, name: 'course3' }, ];</code></pre>
            <figcaption>Fig 04-024</figcaption>
          </figure>
          <p>So now we have two endpoints - one to get all the courses and the other to get a single course. In the
            endpoint to get all the courses we will return our courses array:</p>
          <figure>
            <pre><code class="language-javascript">app.get('/api/courses', (req, res) =&gt; { res.send(courses); })</code></pre>
            <figcaption>Fig 04-025</figcaption>
          </figure>
          <p>In the second one we will write some logic to look for the course with the given id:</p>
          <figure>
            <pre><code class="language-javascript">const course = courses.find(c =&gt; c.id === parseInt(req.params.id));</code></pre>
            <figcaption>Fig 04-026</figcaption>
          </figure>
          <p>find is a method on every array in Javascript. As an argument we pass the method a function using the arrow
            function syntax. We write some logic that returns a boolean value that determines if this course is the one
            we are looking for or not. We store the result in a const called course. You might ask why I didn't use var
            here. var is perfectly fine but going forward best practice states to either use the let or const keywords.
            We use let to define a variable that we can reset later. We use const when defining a constant. This
            prevents the variable from being overwritten elsewhere in the code.</p>
          <p>If we don't find a course with the given id the convention (with RESTful apis) is to return a status code
            of 404:</p>
          <figure>
            <pre><code class="language-javascript">if (!course) res.status(404).send('The course with the given id was not found');</code></pre>
            <figcaption>Fig 04-027</figcaption>
          </figure>
          <p>In the code above we also send the optional message. If we do find a course with that id then we will just
            return it to the client:</p>
          <figure>
            <pre><code class="language-javascript">res.send(course);</code></pre>
            <figcaption>Fig 04-028</figcaption>
          </figure>
          <p>If we browse to a course that does exist:</p>

          <figure>
            <pre class="terminal">localhost:5000/api/courses/10</pre>
            <figcaption>Fig 04-029</figcaption>
          </figure>
          <p>then just that course is returned. If we browse to a course that doesn't exist:</p>
          <figure>
            <pre class="terminal">localhost:5000/api/courses/10</pre>
            <figcaption>Fig 04-030</figcaption>
          </figure>
          <p>We will receive the message saying the course was not found. If you open chrome developer tools and click
            on the Network tab refresh the page and you will see the status 404.</p>
          <h4>49 Handling HTTP POST Requests</h4>
          <p>So far the routes we have created all response to HTTP GET requests. In this lecture we will learn how to
            respond to HTTP POST requests. We use an HTTP POST request to create a new course:</p>
          <figure>
          <pre><code class="language-javascript">app.post('/api/courses', (req, res) =&gt; {
});</code></pre>
            <figcaption>Fig 04-031</figcaption>
          </figure>
          <p>Similar to the get method we need to specify a path: /api/courses because we are going to POST to the
            collection of courses. That's why we use the plural name. Next we add our route handler using the arrow
            function.</p>
          <p>In this route handler we need to read the course object which should be in the body of the request and use
            it's properties to create a new course object and then add that object to our courses array:</p>
          <figure>
            <pre><code class="language-javascript">const course = { id: courses.length + 1, name: req.body.name };</code></pre>
            <figcaption>Fig 04-032</figcaption>
          </figure>
          <p>Again, we use a const here because we are not going to reset this course object later. In this demo, to
            keep things simple, we are not working with a database so we just add one to the length of our courses
            array. Next we need to read the name property from the body of the request. We assume that in the request
            body we have an object and that object has a name property. In order for this line to work we need to enable
            parsing of JSON objects in the body of the request because by default this feature is not enabled in
            express. So at the top of the file after we get the app object:</p>
          <figure>
            <pre><code class="language-javascript">app.use(express.json());</code></pre>
            <figcaption>Fig 04-033</figcaption>
          </figure>
          <p>This may look a bit strange at this point in time but we will cover this in detail later in the course.
            Basically, here, we are adding a piece of middleware. When we call express.json() this method returns a
            piece of middleware and then we call app.use to use that middleware in the request processing pipeline.</p>
          <p>Back in the route handler we push the course into our courses array:</p>
          <figure>
            <pre><code class="language-javascript">courses.push(course);</code></pre>
            <figcaption>Fig 04-044</figcaption>
          </figure>
          <p>Finally, by convention, when we post an object to the server and the server creates a new object or
            resource we should return that object in the body of the response:</p>
          <figure>
            <pre><code class="language-javascript">res.send(course);</code></pre>
            <figcaption>Fig 04-045</figcaption>
          </figure>
          <p>We do this because we are assigning this id on the server and we need to return this course object to the
            client because chances are the client needs to know the id of this new object.</p>
          <h4>50 - Calling Endpoints Using Postman</h4>
          <p>To call HTTP services we use an application called Postman.</p>
          <p>CREATE SEPARATE DOCUMENTATION FOR POSTMAN</p>
          <h4>51 - Input Validation</h4>
          <p>In this lecture we will look at input validation. Best practice dictates that we should never trust
            information sent by the client. It should always be validated.</p>
          <p>In this example:</p>
          <figure>
          <pre><code class="language-javascript">app.post('/api/courses', (req, res) =&gt; { const course = { id: courses.length + 1, name: req.body.name };
courses.push(course); res.send(course); });</code></pre>
            <figcaption>Fig 04-046</figcaption>
          </figure>
          <p>We are dealing with a simple object with only one property: name we can write some validation logic like
            this:</p>
          <figure>
          <pre><code class="language-javascript">if(!req.body.name || req.body.name.length &lt; 3)  { 
  // 400 Bad Request
  res.status(400).send('Name is required and should be minimum 3 characters');
  return; }</code></pre>
            <figcaption>Fig 04-047</figcaption>
          </figure>
          <p>So if the name property doesn't exist or is less than 3 characters in length we set the response status to
            400 Bad Request. We then send a rather generic error message along with setting the status. Finally we
            return to prevent the rest of the function from being executed.</p>
          <p>In a real world application we are likely to be working with more complex objects than the one we are using
            here. We don't want to add too many validation rules in if statements at the top of the route handler. We
            will look at a node package that makes it easier to validate input: joi.</p>
          <figure>
            <pre class="terminal">npm i joi@13.1.0</pre>
            <figcaption>Fig 04-048</figcaption>
          </figure>
          <p>Now, back in the code, at the top of the file we need to load the module:</p>
          <figure>
            <pre><code class="language-javascript">const Joi = require('joi');</code></pre>
            <figcaption>Fig 04-049</figcaption>
          </figure>
          <p>We use a capital for the Joi variable because this module returns a class. As we said before we use Pascal
            naming conventions when we name our classes - so the first letter of every word should be uppercase.</p>
          <p>Also as a best practice put all your require calls at the top of the file. This way you can easily see what
            are the dependencies of this module. So our current module is dependent on joi and express.</p>
          <p>Go back the route handler. With joi we need to define a schema. A schema defines the shape of our objects -
            what properties do we have in our object, what is the type of each property in the object, do we have an
            email, do we have a string, what are the minimum or maximum number of characters, do we have a number, what
            range should that number be in.</p>
          <p>First we define a schema:</p>
          <figure>
            <pre><code class="language-javascript">const schema = { name: Joi.string().min(3).required() };</code></pre>
            <figcaption>Fig 04-050</figcaption>
          </figure>
          <p>So we set schema to an object with a name property. We tell joi to expect a string with a minimum of three
            characters that is required.</p>
          <p>Next we call the validate method passing in the req.body and schema:</p>
          <figure>
            <pre><code class="language-javascript">const result = Joi.validate(req.body, schema); console.log(result);</code></pre>
            <figcaption>Fig 04-051</figcaption>
          </figure>
          <p>We store the object returned by the validate method in a const called result. For this demo I'm going to
            log this result on the console.</p>
          <p>Now if we use Postman to create another course object (POST to http://localhost:3000/api/courses with the
            course specified in the body and the object sent to JSON(application/json)) in the terminal we should see a
            result object with two properties - error and value. Only one of these can have a value. In this case
            because we sent a valid course object we have this course object here as the value of the value property and
            you can see error is null:</p>
          <figure>
            <pre class="terminal">{ error: null, value: { name: 'new course' }, then: [Function: then], catch:
              [Function: catch] }</pre>
            <figcaption>Fig 04-052</figcaption>
          </figure>
          <p>If we send an invalid object, for example by removing the name property, then value will be null and error
            will be set:</p>
          <figure>
            <pre class="terminal">{ ValidationError: child "name" fails because ["name" is required]</pre>
            <figcaption>Fig 04-053</figcaption>
          </figure>
          <p>Back in the route handler instead of using the manual validation logic we can check the value of the
            result.error property:</p>
          <figure>
            <pre><code class="language-javascript">if(result.error) { res.status(400).send(result.error); return; }</code></pre>
            <figcaption>Fig 04-054</figcaption>
          </figure>
          <p>We also don't need the console.log statement any longer so we can remove that.</p>
          <p>If we use Postman to submit another invalid request and look at the response we get an object with
            properties such as isJoi, name, details etc. details is an array of error messages. The first one should be
            "name is required". This object is too complex to send to the client. If you want to simplify this go back
            to the code and instead of returning the whole result.error object you can drill down to the detail arrays
            first elements message property:</p>
          <figure>
            <pre><code class="language-javascript">result.error.details[0].message</code></pre>
            <figcaption>Fig 04-055</figcaption>
          </figure>
          <h4>52 - Handling HTTP PUT Requests</h4>
          <p>Now let's see how we can update a course. Add a new route handler with the PUT method:</p>
          <figure>
          <pre><code class="language-javascript">app.put('/api/courses/:id', (req, res) =&gt; {
  // Look up the course
  // If not existing, return 404
  const course = courses.find(c =&gt; c.id === parseInt(req.params.id)); if (!course)
  res.status(404).send('The course with the given id was not found');

  // Validate
  // If invalid, return 400 - Bad request
  const schema = { name: Joi.string().min(3).required() };

  const result = Joi.validate(req.body, schema); if(result.error) {
  res.status(400).send(result.error.details[0].message); return; }

  // Update course course.name = req.body.name;

  // Return the updated course res.send(course);

});</code></pre>
            <figcaption>Fig 04-056</figcaption>
          </figure>
          <p>The route handler contains a lot of logic, a good proportion of which we have already covered and can pull
            in from different methods. The code to look up the course and return a 404 if it doesn't exist can be found
            in the route handler to get a single course We can get the validation from the post endpoint. The problem
            with this approach is that , although in this example we are dealing with a simple schema, real world
            applications may have much more complex schemas. This would mean our validation code was duplicated in two
            route handlers. We'll resolve this shortly. Next we update the course.name property. If we had more
            properties we would update them here also. Finally we need to return the updated course to the client.</p>
          <p>Now we will extract the validation logic into it's own function which can be used in both route
            handlers:</p>
          <figure>
          <pre><code class="language-javascript">function validateCourse(course) { const schema = { name: Joi.string().min(3).required() };
  return Joi.validate(course, schema); };</code></pre>
            <figcaption>Fig 04-057</figcaption>
          </figure>
          <p>In the code above, instead of validating the req.body we validate the course object. Also we return the
            result to the caller - there is no need to define a const.</p>
          <p>New we can reuse this in our PUT endpoint:</p>
          <figure>
            <pre><code class="language-javascript">const result = validateCourse(req.body);</code></pre>
            <figcaption>Fig 04-058</figcaption>
          </figure>
          <p>This code can be made a bit cleaner by using the object destructuring features of modern Javascript.
            Currently we get the result object and then we are accessing result.error in two different places. Since all
            we are interested in is the error property we can get this using object destructuring. With object
            destructuring when declaring a variable or object we add curly braces and inside we add the property of the
            target object (in this instance error):</p>
          <figure>
          <pre><code class="language-javascript">const { error } = validateCourse(req.body);
if(error) { res.status(400).send(error.details[0].message);
  return; }</code></pre>
            <figcaption>Fig 04-059</figcaption>
          </figure>
          <p>With the above code we don't need to repeat result.error in two seperate places we can simply use
            error.</p>
          <p>We now need to add this new way of validating a course to the HTTP POST request.</p>
          <p>Back in POSTMAN test the PUT and POST endpoints with valid and invalid values in the data.</p>
          <h4>Handling HTTP Delete Requests</h4>
          <p>Out of all the CRUD operations we have now implemented Read, Update and Delete. In this lecture we will
            look at how to respond to HTTP DELETE requests:</p>
          <figure>
          <pre><code class="language-javascript">app.delete('/api/courses/:id', (req, res) => {
  // Look up the course
  // If not existing, return 404 const
  course = courses.find(c => c.id === parseInt(req.params.id));
  if (!course)
    res.status(404).send('The course with the given id was not found');

  // Delete const index = courses.indexOf(course); courses.splice(index, 1);

  // Return the same course res.send(course);

});</code></pre>
            <figcaption>Fig 04-060</figcaption>
          </figure>
          <p>Test this in Postman using valid and invalid course ids.</p>
          <p>There are currently three bugs in this code. Currently in the PUT endpoint if we don't have a course with a
            given id we return a 404 to the client. However at this point we should exit the route handler otherwise the
            rest of the code will be executed:</p>
          <figure>
          <pre><code class="language-javascript">if (!course)
  return res.status(404).send('The course with the given id was not found');</code></pre>
            <figcaption>Fig 04-061</figcaption>
          </figure>
          <p>To make this code cleaner we can use the same technique to deal with an invalid request:</p>
          <figure>
          <pre><code class="language-javascript">if(error)
  return res.status(400).send(error.details[0].message);</code></pre>
            <figcaption>Fig 04-062</figcaption>
          </figure>
          <p>The same issue exists in the DELETE route handler so let's fix that:</p>
          <figure>
          <pre><code class="language-javascript">if (!course)
  return res.status(404).send('The course with the given id was not found');</code></pre>
            <figcaption>Fig 04-063</figcaption>
          </figure>
          <p>and also when GETting a single course:</p>
          <figure>
          <pre><code class="language-javascript">if (!course)
  return res.status(404).send('The course with the given id was not found');</code></pre>
            <figcaption>Fig 04-064</figcaption>
          </figure>
          <p>We can also clean up the code in the POST route handler:</p>
          <figure>
          <pre><code class="language-javascript">if(error)
  return res.status(400).send(error.details[0].message);</code></pre>
            <figcaption>Fig 04-065</figcaption>
          </figure>
          <h4>54 - Project - Build the Genres API</h4>
          <p>From this lecture we are going to start building the backend services for our vidly application. vidly is
            an imaginary service for renting out movies. Throughout the course we will build the backend of vidly bit by
            bit. Your first task is to create a service for managing the list of genres. Each movie has a genre like
            action, horror etc. We should have an endpoint for getting all the genres. We should also have endpoints for
            creating, updating and deleting genres.</p>
          <h4>55 - Recap Building RESTful APIs with Express </h4>
          <p>So, in this section, you learned that: - REST defines a set of conventions for creating HTTP services:</p>
          <ul>
            <li>POST: to create a resource</li>
            <li>PUT: to update it</li>
            <li>GET: to read it</li>
            <li>DELETE: to delete it</li>
          </ul>
          <p>Express is a simple, minimalistic and lightweight framework for building web servers.</p>
          <p>Build a web
          server</p>
          <figure>
          <pre><code class="language-javascript">const express = require(&lsquo;express&rsquo;);

const app = express();

// Creating a course
app.post(&lsquo;/api/courses&rsquo;, (req, res) =&gt; {
  // Create the course and return the course object
  res.send(course);
});

// Getting all the courses
app.get(&lsquo;/api/courses&rsquo;, (req, res) =&gt; {
  // To read query string parameters (?sortBy=name)
  const sortBy = req.query.sortBy;
  // Return the courses
  res.send(courses); });

// Getting a single course
app.get(&lsquo;/api/courses/:id&rsquo;, (req, res) =&gt; {
  const courseId = req.params.id;
  // Lookup the course

  // If not found, return 404
  res.status(404).send(&lsquo;Course not found.&rsquo;);

  // Else, return  the course object
  res.send(course);
});

// Updating a course
app.put(&lsquo;/api/courses/:id&rsquo;, (req, res) =&gt; {
  // If course not found, return 404, otherwise update it // and return the updated object.
});

// Deleting a course
app.delete(&lsquo;/api/courses/:id&rsquo;, (req, res) =&gt; {
  // If course not found, return 404, otherwise delete it
  // and return the deleted object.
});

// Listen on port 3000 app.listen(3000, () =&gt;
console.log(&lsquo;Listening&hellip;&rsquo;));</code></pre>
            <figcaption>Fig 04-066</figcaption>
          </figure>

          <p>We use Nodemon to watch for changes in files and automatically restart the node process. We can use
            environment variables to store various settings for an application. To read an environment variable, we use
            process.env.</p>
          <figure>
          <pre><code class="language-javascript">// Reading the port from an environment variable
          const port = process.env.PORT || 3000; app.listen(port);</code></pre>
            <figcaption>Fig 04-067</figcaption>
          </figure>
          <p>You should never trust data sent by the client.
          Always validate! Use Joi package to perform input validation.</p>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
  export default {
    name: 'TheCompleteNodejsCourse'
  }</script>

<style scoped>
  img {
    max-width: 100%;
  }

  ul.contents {
    list-style-type: none;
  }

</style>

