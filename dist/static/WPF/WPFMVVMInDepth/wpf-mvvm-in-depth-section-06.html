<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>maxsagetech - Vue JS Fundamentals</title>
  <script src="https://unpkg.com/vue"></script>
  <!--<link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"-->
  <!--integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" rel="stylesheet">-->
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>

    img {
      max-width: 100%;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="panel-group">
      <div class="panel panel-primary">
        <div class="panel-heading">
          <h3>Applied MVVM Part 2 – Validation and Dependency Injection</h3>
        </div>
        <div class="panel-body">
          <h2>Overview</h2>
          <p>
            In this final module we continue to build out use cases surrounding Customers in our Pizza Order Management
            Application. This will include fleshing out some data entry for adding and editing Customers by leveraging
            the Scaffolding of data-centric Views that is available in Visual Studio. Also anytime your accepting input
            from a user you should also be validating that input. So we'll look at a clean way to do validation with
            what WPF bindings already support but tying it in to your MVVM components.
          </p>
          <p>
            When ViewModels take dependencies on client services you will want to make sure those dependencies are
            loosely coupled. We will cover dependency injection.
          </p>
          <p>Finally, we will cover some of the toolkits and frameworks that can assist when writing applications that
            adhere to the MVVM pattern.
          </p>
          <h3>Visual Studio Designer and Data Sources</h3>
          <p>
            Now we will implement add and edit Customer use cases. We will use the Visual Studio Data Sources and
            Designer Windows. These Visual Studio features make it very quick and easy to scaffold out data bound forms
            whether your just presenting data in a DataGrid or you need to have to individual input fields for data
            entry.
          </p>
          <p>The bad news is what it generates is not particularly MVVM friendly. It generates some code that makes
            assumptions that your gonna be hooking things up in the XAML's code behind file which we talked about in
            module one kind of goes against the MVVM pattern. .
          </p>
          <p>The good news is we can easily morph the code into clean MVVM st ructure with just a few minor changes.
          </p>
          <h3>Demo: Scaffolding an Edit View in Visual Studio</h3>
          <div class="example">
            <div class="input-group">
              <input id="Ex06-001" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 6\ZzaDesktop-Start\ZzaDesktop.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex06-001"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <div class="example">
            <div class="input-group">
              <input id="Ex06-002" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 6\ZzaDesktop-End\ZzaDesktop.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex06-002"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <p>
            Previously we created the AddEditCustomerView.xaml and the navigation to it from the CustomerListView.xaml.
            We will now continue to flesh out the AddEditCustomerView.xaml and put the data entry form together by
            leveraging the Data Sources window in Visual Studio which allows you to drag and drop into the designer to
            scaffold out your data views.
          </p>
          <p>First up, get rid of the TextBlock from the previous module's example and then in Visual Studio switch to
            the Designer tab and select View>Other Windows>Data Sources:
          </p>
          <figure>
            <img src="./images/Fig06-001.png"/>
            <figcaption>Fig06-001</figcaption>
          </figure>
          <p>
            Click Add New Datasource either with the hyperlink or the icon at the top left of the Data Sources window.
            From the next dialog select the Object Data Source Type. Drill down to the Customers model object definition
            under Zza.Data> Zza.Data >Customer. From the Datasources window click on the Dropdown list next to the
            Customer Datasource you just generated.
          </p>
          <figure>
            <img src="./images/Fig06-002.png"/>
            <figcaption>Fig06-002</figcaption>
          </figure>
          <p>This dropdown allows you to select the output generated:</p>
          <ul>
            <li>DataGrid to contain Customers</li>
            <li>ListView for Customers</li>
            <li>Details – in effect a data entry form</li>
          </ul>
          <p>Select the Details option and expand the result. You'll see it has mappings for each of the properties
            based on it's type. Now we're not going to use all these properties for this data entry so I can go and set
            some of them to none:
          </p>
          <figure>
            <img src="./images/Fig06-002A.png"/>
            <figcaption>Fig06-002A</figcaption>
          </figure>
          <p>Trimming it down to just the fields that I want to generate input fields for.
          </p>

          <p>
            Once you have done this, drag out the Customer object onto the Designer onto my UserControl. And when I
            release it's going to do a bunch of code generation for me. You can see it generated a Label and a TextBox
            for each one of those fields and if I really wanted to change what's generated you can see I can choose what
            kind of control to scaffold:
          </p>
          <figure>
            <img src="./images/Fig06-002B.png"/>
            <figcaption>Fig06-002B</figcaption>
          </figure>
          <p>Now if we go into the XAML we can see that it wired up a number of things that we don't really want to be
            here in an MVVM application. First off, it wired up a Loaded event handler and expects you to do the wiring
            from the code behind of your XAML.
          </p>
          <figure>
            <pre class="prettyprint">Loaded=&quot;UserControl_Loaded&quot;</pre>
            <figcaption>Fig 06-003</figcaption>
          </figure>
          <p>
            Remove the Loaded event handler and the associated method in the Code Behind. Also, remove the
            CollectionViewSource that was auto generated in UserControl.Resources. Modify the DataContext of the Grid so
            it Binds to a Customer property that we will expose from our ViewModel (that sets the DataContext just for
            the fields within this grid which are the Labels and Textboxes to a Customer so it can bind directly to the
            individual properties on that Customer:
          </p>
          <figure>
                <pre class="prettyprint">&lt;Grid x:Name=&quot;grid1&quot;
    HorizontalAlignment=&quot;Left&quot;
    DataContext=&quot;{Binding Customer}&quot;
    Margin=&quot;20,24,0,0&quot;
    VerticalAlignment=&quot;Top&quot;
                </pre>
            <figcaption>Fig 06-005</figcaption>
          </figure>
          <p>
            When Visual Studio auto-generates the code it will put the properties in alphabetical order by Property
            Name. Re-arrange the property order by editing the XAML to the following order (don’t forget to change the
            Grid numbers):
          </p>
          <ul>
            <li>First Name</li>
            <li>Last Name</li>
            <li>Email</li>
            <li>Phone</li>
          </ul>
          <p>Now when you run the application and Add or Edit a Customer you will see a data entry form.</p>
          <p>Now we just have to focus on the ViewModel and the interactions within that View which we'll start into in
            the next demo.
          </p>
          <h3>Demo: Wrapping Model Objects</h3>
          <div class="example">
            <div class="input-group">
              <input id="Ex06-003" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 6\ZzaDesktop-Start\ZzaDesktop.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex06-003"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <div class="example">
            <div class="input-group">
              <input id="Ex06-004" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 6\ZzaDesktop-End\ZzaDesktop.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex06-004"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <p>
            So, now we have to expose a Customer as a property to satisfy the binding for our input fields. We won't
            expose the Customer Model object directly. You can't guarantee that your model objects will be in the right
            shape to handle data-binding from your View and ViewModel. For example, at a minimum you need an object that
            implements INotifyPropertyChanged fully (we can now do this by inheriting from BindableBase). But depending
            on way those entities come from and where else their used you may not be able to change out the base class
            for your model objects.
          </p>
          <p>Additionally, as we'll get to in this module we may need to implement certain things on the Model object to
            support validation and again that may not be permissible to do that and have that code affect every other
            piece of code that uses that model object.
          </p>
          <p>
            One way round this dilemma is to create a Wrapped Model Object or a ViewModel Helper. Add a new class to the
            Customers folder called SimpleEditableCustomer.cs that inherits from BindableBase and add the Id, FirstName,
            LastName, Email and Phone properties ensuring they adhere to the pattern specified in BindableBase for
            setting the property:
          </p>
          <figure>
                <pre class="prettyprint">public class SimpleEditableCustomer : BindableBase
{
    private Guid _id;
    public Guid Id
    {
        get { return _id; }
        set { SetProperty(ref _id, value); }
    }

    private string _firstName;

    public string FirstName
    {
        get { return _firstName; }
        set { SetProperty(ref _firstName, value); }
    }</pre>
            <figcaption>Fig 06-006</figcaption>
          </figure>
          <p>Back in AddEditCustomerViewModel we can now add a property of type SimpleEditableCustomer:</p>
          <figure>
                <pre class="prettyprint">private SimpleEditableCustomer _Customer;
public SimpleEditableCustomer Customer
{
    get { return _Customer; }
    set { SetProperty(ref _Customer, value); }
}</pre>
            <figcaption>Fig 06-007</figcaption>
          </figure>
          <p>We must populate this property when the Customer object is being passed in from the Parent ViewModel.
          </p>
          <figure>
                <pre class="prettyprint">public void SetCustomer(Customer cust)
{
    _editingCustomer = cust;
}</pre>
            <figcaption>Fig 06-008</figcaption>
          </figure>
          <p>The two methods shown below achieve the following:</p>
          <ul>
            <li>We take the customer and hold onto it so that when we save we do so to the right Customer</li>
            <li>Create a new SimpleEditableCustomer object</li>
            <li>Use the CopyCustomer helper method to copy the relevant values to the Customer.</li>
          </ul>
          <figure>
                <pre class="prettyprint">public void SetCustomer(Customer cust)
{
    _editingCustomer = cust;
    Customer = new SimpleEditableCustomer();
    CopyCustomer(cust, Customer);
}

private void CopyCustomer(Customer source, SimpleEditableCustomer target)
{
    target.Id = source.Id;
    if (EditMode)
    {
        target.FirstName = source.FirstName;
        target.LastName = source.LastName;
        target.Phone = source.Phone;
        target.Email = source.Email;
    }
}</pre>
            <figcaption>Fig 06-009</figcaption>
          </figure>
          <p>
            Not all the properties are set unless we are in EditMode (as you will see later this is to avoid triggering
            validation). We do need to at least set the Id so that we have an Id for the Customer when we start editing.
            That Id, if you remember, was being set in CustomerListViewModel when it was first firing the event that
            says it is time to add a new Customer.
          </p>
          <p>Now if you run the application, click on Customers, click on Edit for a Customer and you will see the data
            for our Customer in our data entry form:
          </p>
          <figure>
            <img src="./images/Fig06-010.png"/>
            <figcaption>Fig06-010</figcaption>
          </figure>
          <p>If we navigate to add Customer we will be presented with a blank data entry from to start adding to:
          </p>
          <figure>
            <img src="./images/Fig06-011.png"/>
            <figcaption>Fig06-011</figcaption>
          </figure>
          <p>So next up we need to add some Command handling to actually complete the process of adding or editing a
            Customer and to Cancel and be able to back out of that operation if desired.
          </p>
          <h3>Demo: Command Handling and Converters</h3>
          <div class="example">
            <div class="input-group">
              <input id="Ex06-005" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 6\ZzaDesktop-Start\ZzaDesktop.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex06-005"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <div class="example">
            <div class="input-group">
              <input id="Ex06-006" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 6\ZzaDesktop-End\ZzaDesktop.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex06-006"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <p>Now we need to wire up the actual command handling to Add or Save an edited Customer as well as cancelling.
          </p>
          <p>
            Modify the Grid so that it has two rows – one for the data entry fields, the other for the command buttons.
            The second row will host another Grid which contains three buttons:
          </p>
          <figure>
                <pre class="prettyprint">&lt;Grid Grid.Row=&quot;1&quot;&gt;
    &lt;Button Content=&quot;Save&quot;
            Command=&quot;{Binding SaveCommand}&quot;
            HorizontalAlignment=&quot;Left&quot;
            Margin=&quot;25,5,0,0&quot;
            VerticalAlignment=&quot;Top&quot;
            Width=&quot;75&quot; /&gt;
    &lt;Button Content=&quot;Add&quot;
            Command=&quot;{Binding SaveCommand}&quot;
            HorizontalAlignment=&quot;Left&quot;
            Margin=&quot;25,5,0,0&quot;
            VerticalAlignment=&quot;Top&quot;
            Width=&quot;75&quot; /&gt;
    &lt;Button Content=&quot;Cancel&quot;
            Command=&quot;{Binding CancelCommand}&quot;
            HorizontalAlignment=&quot;Left&quot;
            Margin=&quot;150,5,0,0&quot;
            VerticalAlignment=&quot;Top&quot;
            Width=&quot;75&quot; /&gt;
&lt;/Grid&gt;</pre>
            <figcaption>Fig 06-012</figcaption>
          </figure>

          <p>
            Obviously if we have this add/edit mode only one of the buttons really applies depending on which mode you
            are in (Edit/Add). So we need to hide or show one of these Buttons.
          </p>
          <p>One thing that may immediately occur to you is why don’t we just have one Button and dynamically populate
            what the Button says from the ViewModel based on our edit mode. While this may seem like a perfectly viable
            thing to do it brings up an important concept about MVVM and the appropriate roles. If you remember from
            module one we said it was the Views job to dictate what the User sees on the screen and the ViewModel just
            provides the interaction logic and the data manipulation to support that. If your ViewModel is trying to
            push text to drive the content of a Button that violates those principles. What if, down the line, you bring
            a designer into the mix and he decides to use icons instead of text – should you then be pushing Icons to
            the View from the ViewModel? No that’s pure presentation which is the Views job. So to protect against that
            we will go ahead and put the two Buttons in there and we will drive their visibility from a property exposed
            on our ViewModel.
          </p>
          <p>
            Then you may say - we can just expose a property of type Visibility (note Visibility) from our ViewModel and
            we can set the Visibility with a Binding like this:
          </p>
          <figure>
                <pre class="prettyprint">&lt;Button Content=&quot;Save&quot;
    Command=&quot;{Binding SaveCommand}&quot;
    Visibility=&quot;{Binding SaveVisibility}"&quot;
    HorizontalAlignment=&quot;Left&quot;
    Margin=&quot;25,5,0,0&quot;
    VerticalAlignment=&quot;Top&quot;
    Width=&quot;75&quot; /&gt;</pre>
            <figcaption>Fig 06-013</figcaption>
          </figure>
          <p>
            Once again, if you look at it from a separation of concerns perspective, Visibility is a pure presentation
            aspect which is a responsibility of the View. You really shouldn’t be exposing Visibility properties from
            your ViewModel either.
          </p>
          <p>
            So what's a poor MVVM developer to do? You can easily expose flags or booleans from your ViewModel that are
            decoupled from how that flag drives the presentation. So we still want to bind the Visibility property but
            we want it to be driven by a boolean flag.
          </p>
          <p>
            There is a built in boolean to visibility converter that we could use but unfortunately that one doesn't let
            you negate what that flag means and it also is hard coded to always use collapsed as the false state. As a
            result, we will create a CustomConverter to deal with these kinds of situations.
          </p>
          <p>
            We will drive the visibility of the buttons from a property exposed on the ViewModel. We will use a flag or
            Boolean that is decoupled from how the flag drives the presentation by implementing a Custom Converter.
          </p>
          <p>
            Add a new Folder called Converters and a class called NegatableBooleanToVisibilityConverter.cs. The class
            should inherit from IValueConverter. The class exposes two additional properties that can be set when you
            create an instance of this class from your XAML resource dictionary – one to set whether or not the Boolean
            flag is negated and the other to drive what the FalseVisibility is. Usually this will be set to either
            Collapsed or Hidden – we will default to Collapsed:
          </p>
          <figure>
                <pre class="prettyprint">public class NegatableBooleanToVisibilityConverter : IValueConverter
{
    public NegatableBooleanToVisibilityConverter()
    {
        FalseVisibility = Visibility.Collapsed;
    }
    public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
    {
        bool bVal;
        bool result = bool.TryParse(value.ToString(), out bVal);
        if (!result) return value;
        if (bVal &amp;&amp; !Negate) return Visibility.Visible;
        if (bVal &amp;&amp; Negate) return FalseVisibility;
        if (!bVal &amp;&amp; Negate) return Visibility.Visible;
        if (!bVal &amp;&amp; !Negate) return FalseVisibility;
        else return Visibility.Visible;
    }

    public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
    {
        throw new NotImplementedException();
    }

    public bool Negate { get; set; }
    public Visibility FalseVisibility { get; set; }

}</pre>
            <figcaption>Fig 06-014</figcaption>
          </figure>
          <p>
            In the Convert method there is a chunk of logic that combines the boolean flag that comes in from the
            binding and the negate flag to say whether we should be Visible or whatever the Visibility of our false
            Visibility property is.
          </p>
          <p>Next in the AddEditCustomerView add a XAML namespace for the Converters child namespace:</p>
          <figure>
            <pre class="prettyprint">xmlns:conv=&quot;clr-namespace:ZzaDesktop.Converters&quot;</pre>
            <figcaption>Fig 06-015</figcaption>
          </figure>
          <p>Define two instances of the VisibilityConverter (one where we set negate to true and one where we don’t):
          </p>
          <figure>
                <pre class="prettyprint">&lt;UserControl.Resources&gt;
        &lt;conv:NegatableBooleanToVisibilityConverter x:Key=&quot;VisConverter&quot; /&gt;
        &lt;conv:NegatableBooleanToVisibilityConverter x:Key=&quot;NegVisConverter&quot;
                                                    Negate=&quot;True&quot; /&gt;

    &lt;/UserControl.Resources&gt;</pre>
            <figcaption>Fig 06-016</figcaption>
          </figure>
          <p>
            Now set the Visibility of the Buttons using our existing EditMode flag on our ViewModel and the appropriate
            instance of our VisibilityConverter (VisConverter or NegVisConverter).
          </p>
          <figure>
                <pre class="prettyprint">&lt;Button Content=&quot;Save&quot;
        Command=&quot;{Binding SaveCommand}&quot;
        Visibility=&quot;{Binding EditMode, Converter={StaticResource VisConverter}}&quot;
        HorizontalAlignment=&quot;Left&quot;
        Margin=&quot;25,5,0,0&quot;
        VerticalAlignment=&quot;Top&quot;
        Width=&quot;75&quot; /&gt;
&lt;Button Content=&quot;Add&quot;
        Command=&quot;{Binding SaveCommand}&quot;
        Visibility=&quot;{Binding EditMode, Converter={StaticResource NegVisConverter}}&quot;
        HorizontalAlignment=&quot;Left&quot;
        Margin=&quot;25,5,0,0&quot;
        VerticalAlignment=&quot;Top&quot;
        Width=&quot;75&quot; /&gt;</pre>
            <figcaption>Fig 06-017</figcaption>
          </figure>
          <p>
            When in Edit mode the Save Button should be Visible. With the Add Button we negate the meaning of that Edit
            Mode in order to hide the Add Button when we are in EditMode.
          </p>
          <p>Now let's hook up Command Handling for our SaveCommand and our CancelCommand. In the ViewModel declare the
            Commands as properties you can bind to:
          </p>
          <figure>
                <pre class="prettyprint">public RelayCommand CancelCommand { get; private set; }
public RelayCommand SaveCommand { get; private set; }</pre>
            <figcaption>Fig 06-018</figcaption>
          </figure>

          <p>Construct our Commands in the ViewModel's Constructor pointing to the handling methods.</p>
          <figure>
                <pre class="prettyprint">public AddEditCustomerViewModel(ICustomersRepository repo)
{
    _repo = repo;
    CancelCommand = new RelayCommand(OnCancel);
    SaveCommand = new RelayCommand(OnSave, CanSave);
}</pre>
            <figcaption>Fig 06-019</figcaption>
          </figure>
          <p>In the case of the SaveCommand we will be implementing validation so we had a CanSave or CanExecute handler
            .
          </p>
          <p>Stub out the OnCancel(), OnSave and CanSave() methods:</p>
          <figure>
                <pre class="prettyprint">private void OnCancel()
{
}

private async void OnSave()
{
}

private bool CanSave()
{
    return true;
}</pre>
            <figcaption>Fig 06-020</figcaption>
          </figure>
          <p>
            Similar to the CustomerListView we need to be able to signal our Parent ViewModel when we are done adding,
            editing or if we cancel. We do this by adding an Event called Done which we can raise from the ViewModel and
            the Parent can handle to drive navigation:
          </p>
          <figure>
            <pre class="prettyprint">public event Action Done = delegate { };</pre>
            <figcaption>Fig 06-021</figcaption>
          </figure>
          <p>In the handling methods, for the moment, just call Done() in each method:</p>
          <figure>
                <pre class="prettyprint">private void OnCancel()
{
    Done();
}</pre>
            <figcaption>Fig 06-022</figcaption>
          </figure>
          <p>Now in the Parent ViewModel (MainWindowViewModel in this case) add an event handler for the Done event:
          </p>
          <figure>
            <pre class="prettyprint">_addEditViewModel.Done += NavToCustomerList;</pre>
            <figcaption>Fig 06-023</figcaption>
          </figure>
          <p>
            Now add the handler method (NavToCustomerList()) that sets the current ViewModel back to the desired
            ViewModel when we are finished editing (_customerListViewModel in this case):
          </p>
          <figure>
                <pre class="prettyprint">private void NavToCustomerList()
{
    CurrentViewModel = _customerListViewModel;
}</pre>
            <figcaption>Fig 06-024</figcaption>
          </figure>
          <p>
            No if we run the application, click Customers, edit a selected Customer, make a change, click Save and the
            changes do not show up! This is because we have not yet wired up any save handling. This will be covered in
            a later module.
          </p>
          <p>Before we try to Save the added or edited customer we need to validate that data first. So let's talk about
            validation.
          </p>
          <h3>Validation in MVVM</h3>
          <p>As soon as you start accepting data input from end users you need to consider validation. WPF has some
            great built in features in the binding system for validating input and you can still leverage all those
            features when doing MVVM.
          <p>The only thing to keep in mind is that the logic that supports your validation and defines what rules exist
            for what properties should be part of the Model or the ViewModel, not the View.
          </p>
          <p>You can still use all of the ways of expressing validation that are supported by WPF databinding including:
          </p>
          <ul>
            <li>Throwing Exceptions when a property is set</li>
            <li>Implementing the IDataErrorInfo interface</li>
            <li>Implementing INotifyDataErrorInfo</li>
            <li>Using WPF Validation Rules</li>
          </ul>
          <p>
            In general, the recommendation is to use INotifyDataErrorInfo. This was introduced to WPF in .Net 4.5 and it
            supports querying the object for errors associated with properties. It fixes a couple of deficiencies that
            exist in all the other options:
          </p>
          <ul>
            <li>It allows asynchronous validation</li>
            <li>It allows properties to have more than one error associated with them</li>
          </ul>
          <p>So let's dive into implementing validation for our data entry scenario</p>
          <h3>Demo: Adding Validation to an Input View</h3>
          <div class="example">
            <div class="input-group">
              <input id="Ex06-007" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 6\ZzaDesktop-Start\ZzaDesktop.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex06-007"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <div class="example">
            <div class="input-group">
              <input id="Ex06-008" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 6\ZzaDesktop-End\ZzaDesktop.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex06-008"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <p>
            Now we want to add validation support to our data entry form. Validation can be useful in a number of places
            in your application (Views, ViewModels, Helper Objects). This makes it a good candidate for a common base
            class that we can inherit from in those scenarios. We want the base class to support INotifyDataErrorInfo
            and we want it to integrate nicely so that the validation gets triggered when properties change. Since we
            already have a base class for Property change handling (BindableBase) it’s a natural step to derive from
            that class.
          </p>
          <p>Create a new class called ValidateableBindableBase which inherits from BindableBase and implements
            INotifyDataErrorInfo:
          </p>
          <figure>
                <pre class="prettyprint">public class ValidatableBindableBase : BindableBase, INotifyDataErrorInfo
{
    public event EventHandler&lt;DataErrorsChangedEventArgs&gt; ErrorsChanged = delegate { };

    public System.Collections.IEnumerable GetErrors(string propertyName)
    {
        throw new NotImplementedException();
    }

    public bool HasErrors
    {
        get { throw new NotImplementedException(); }
    }
}</pre>
            <figcaption>Fig 06-025</figcaption>
          </figure>
          <p>
            After we stub the INotifyDataErrorInfo interface out you can see we have a GetErrors method that gets
            queried with the propertyName and is expected to return a collection of errors for that property. We need to
            raise the ErrorsChanged event whenever new errors are added for a property so that the binding can re-query
            and call this again. Then we have to have a boolean flag (HasErrors) that indicates whether there are any
            errors on the class. It has to stay in sync with the state of the errors for all the properties on the
            object.
          </p>
          <p>
            We can support this interface pretty simply by having a Dictionary as our underlying data store that has a
            key of string which is the property name and a list of string per property which are the errors associated
            with that property:
          </p>
          <figure><pre class="prettyprint">private Dictionary&lt;string, List&lt;string&gt;&gt; _errors = new Dictionary&lt;string, List&lt;string&gt;&gt;();</pre><figcaption>Fig 06-026</figcaption>
          </figure>
          <p>Now we just need to integrate the use of that Dictionary with the members down below:</p>
          <figure>
                <pre class="prettyprint">public System.Collections.IEnumerable GetErrors(string propertyName)
{
    if (_errors.ContainsKey(propertyName))
        return _errors[propertyName];
    else
        return null;
}

public bool HasErrors
{
    get { return _errors.Count &gt; 0; }
}</pre>
            <figcaption>Fig 06-027</figcaption>
          </figure>
          <p>
            We look into the Dictionary when we are queried for a property. If there are any errors in there return them
            as a list of strings. If not return null. We drive the HasErrors flag by checking if there is anything in
            the Dictionary or not.
          </p>
          <p>Next we need to add a trigger to say when does this thing evaluate errors:</p>
          <figure>
                <pre class="prettyprint">protected override void SetProperty&lt;T&gt;(ref T member, T val, [CallerMemberName] string propertyName = null)
{
    base.SetProperty&lt;T&gt;(ref member, val, propertyName);
    ValidateProperty(propertyName, val);
}</pre>
            <figcaption>Fig 06-028</figcaption>
          </figure>
          <p>
            Since we are inhereting from BindableBase we can override the SetProperty method. We will still want to call
            the base so that the INotifyPropertyChange handling occurs but then we can call a method (which we are about
            to implement) to trigger the validation because a property has been set.
          </p>
          <p>
            No we could wire into this ValidateProperty method any number of approaches to validation but the most
            prominent approach nowadays is to use Data Annotations:
          </p>
          <figure>
                <pre class="prettyprint">private void ValidateProperty&lt;T&gt;(string propertyName, T value)
{
    var results = new List&lt;ValidationResult&gt;();
    ValidationContext context = new ValidationContext(this);
    context.MemberName = propertyName;
    Validator.TryValidateProperty(value, context, results);

    if (results.Any())
    {

        _errors[propertyName] = results.Select(c =&gt; c.ErrorMessage).ToList();
    }
    else
    {
        _errors.Remove(propertyName);
    }
    ErrorsChanged(this, new DataErrorsChangedEventArgs(propertyName));
}</pre>
            <figcaption>Fig 06-029</figcaption>
          </figure>
          <p>
            Data Annotations contain the concept of a data validation context. You can point at a given object, say what
            member or property on that object is being validated and then call a method (TryValidateProperty) to
            evaluate that object. When this method is called it will go to that property on that object and see if there
            is any Data Annotation attributes for validation. If so it will execute them and get their results and
            return them in the results collection.
          </p>
          <p>
            If there are any results we set those results as the errors for that property name. If there are not any
            errors then we can remove that property from our Dictionary because there are no longer any errors
            associated with that property.
          </p>
          <p>Next we raise the ErrorsChanged event so that the binding can go and requery for errors.</p>
          <p>Back in our AddEditCustomerView we can look at the bindings that were generated from our earlier drag and
            drop operations:
          </p>
          <figure>
                <pre class="prettyprint">&lt;TextBox x:Name=&quot;firstNameTextBox&quot;
     Grid.Column=&quot;1&quot;
     HorizontalAlignment=&quot;Left&quot;
     Height=&quot;23&quot;
     Margin=&quot;3&quot;
     Grid.Row=&quot;0&quot;
     Text=&quot;{Binding FirstName, Mode="TwoWay, NotifyOnValidationError=true, ValidatesOnExceptions=True}&quot;
     VerticalAlignment=&quot;Center&quot;
     Width=&quot;120&quot; /&gt;</pre>
            <figcaption>Fig 06-030</figcaption>
          </figure>
          <p>
            We can see they already have Validation and Mode flags on them already. We will replace those flags with the
            minimum we need to support NotifyDataErrorInfo:
          </p>
          <figure>
                <pre class="prettyprint">&lt;TextBox x:Name=&quot;firstNameTextBox&quot;
     Grid.Column=&quot;1&quot;
     HorizontalAlignment=&quot;Left&quot;
     Height=&quot;23&quot;
     Margin=&quot;3&quot;
     Grid.Row=&quot;0&quot;
     Text=&quot;{Binding FirstName, ValidatesOnNotifyDataErrors=True}&quot;
     VerticalAlignment=&quot;Center&quot;
     Width=&quot;120&quot; /&gt;</pre>
            <figcaption>Fig 06-031</figcaption>
          </figure>

          <p>
            On each one of the bindings we have added ValidatesOnNotifyDataErrors=True. That causes that binding to look
            when it first hooks up to its data bound object, see if it implements INotifyDataErrorInfo and if so start
            querying it whenever it gets PropertyChanged notifications for that property.
          </p>
          <p>If there are errors returned, then it will set certain Attached Properties on the associated Control such
            as:
          </p>
          <ul>
            <li>Validation has errors</li>
            <li>Validation errors collection</li>
            <li>Raising Validation events</li>
          </ul>
          <p>Now we need to add some Data Annotation attributes to SimpleEditableCustomer we will make the FirstName and
            LastName required:
          </p>
          <figure>
                <pre class="prettyprint">private string _firstName;
[Required]
public string FirstName
{
    get { return _firstName; }
    set { SetProperty(ref _firstName, value); }
}

private string _lastName;
[Required]
public string LastName
{
    get { return _lastName; }
    set { SetProperty(ref _lastName, value); }
}</pre>
            <figcaption>Fig 06-032</figcaption>
          </figure>
          <p>Then we will use the built in Email and Phone annotations:</p>
          <figure>
                <pre class="prettyprint">private string _email;
[EmailAddress]
public string Email
{
    get { return _email; }
    set { SetProperty(ref _email, value); }
}

private string _phone;
[Phone]
public string Phone
{
    get { return _phone; }
    set { SetProperty(ref _phone, value); }
}</pre>
            <figcaption>Fig 06-033</figcaption>
          </figure>
          <p>Now we just need to make the base class ValidatableBindableBase instead of BindableBase:</p>
          <figure>
            <pre class="prettyprint">public class SimpleEditableCustomer : ValidatableBindableBase</pre>
            <figcaption>Fig 06-034</figcaption>
          </figure>
          <p>Now if we run the application, edit a Customer, try to Edit by clearing the FirstName field and we will see
            it gets red boxed:
          </p>
          <figure>
            <img src="./images/Fig06-035.png"/>
            <figcaption>Fig06-035</figcaption>
          </figure>
          <p>Unfortunately, WPF does'nt have much in the way of validation indications so we will add two enhancements:
          </p>
          <ul>
            <li>The Save Button should disable when a validation error occurs</li>
            <li>We will add a ToolTip on the Control that will display the validation error</li>
          </ul>
          <p>To support disabling the SaveCommand we need to go to the AddEditCustomerViewModel and modify the
            SetCustomer method:
          </p>
          <figure>
                <pre class="prettyprint">public void SetCustomer(Customer cust)
{
    _editingCustomer = cust;
    if (Customer != null) Customer.ErrorsChanged -= RaiseCanExecuteChanged;
    Customer = new SimpleEditableCustomer();
    Customer.ErrorsChanged += RaiseCanExecuteChanged;
    CopyCustomer(cust, Customer);
}

private void RaiseCanExecuteChanged(object sender, EventArgs e)
{
    SaveCommand.RaiseCanExecuteChanged();
}</pre>
            <figcaption>Fig 06-036</figcaption>
          </figure>

          <p>
            Now when the Customer is set we subscribe to the ErrorsChanged event and trigger the RaiseCanExecuteChanged.
            We will also put a check in to unsubscribe an existing Customer to avoid memory leaks.
          </p>
          <p>Next we change our CanSave method to check the HasErrors flag of the Customer object:</p>
          <figure>
                <pre class="prettyprint">private bool CanSave()
{
    return !Customer.HasErrors;
}</pre>
            <figcaption>Fig 06-037</figcaption>
          </figure>
          <p>
            Now run the application and edit a Customer. When you remove the FirstName text you will see the field is
            red boxed again and the Save Button is disabled.
          </p>
          <p>Adding a ToolTip for the validation error is as simple as defining a style for it to the
            AddEditCustomerView:
          </p>
          <figure>
                <pre class="prettyprint">&lt;Style TargetType=&quot;TextBox&quot;&gt;
    &lt;Style.Triggers&gt;
        &lt;Trigger Property=&quot;Validation.HasError&quot;
                 Value=&quot;true&quot;&gt;
            &lt;Setter Property=&quot;ToolTip&quot;
                    Value=&quot;{Binding RelativeSource={x:Static RelativeSource.Self},
                            Path=(Validation.Errors).CurrentItem.ErrorContent}&quot; /&gt;
        &lt;/Trigger&gt;
    &lt;/Style.Triggers&gt;
&lt;/Style&gt;</pre>
            <figcaption>Fig 06-038</figcaption>
          </figure>
          <p>
            In the style we will implicitly target the TextBox within this scope, we will setup a Style Trigger that
            watches the Attached Property Validation.HasError. When that is set to true then we will set the ToolTip
            property of the TextBox. The Value Binding is a little complex but you can see that it is basically going to
            the Validation.Errors Attached Property which is a Collection for this Control, moves to the CurrentItem and
            gets the ErrorContent which is the string. It then uses that value to set the ToolTip.
          </p>
          <p>Now if we run the application, edit a Customer, cause a validation error, tab off the field, we can see
            that the button still disables but then when we hover over the field we and an error indication of what is
            going on there:
          </p>
          <figure>
            <img src="./images/Fig06-039.png"/>
            <figcaption>Fig06-039</figcaption>
          </figure>
          <p>
            Check out the WPF Data Binding in Depth Pluralsight course by Brian Noyes for examples of adding Icons to
            indicate validation errors and other techniques.
          </p>
          <p>Now we need to wire up the Save handling. For that we need to discuss Dependency Injection.</p>
          <h3>Dependency Injection</h3>
          <p>
            Now let’s talk a little bit about Dependency Injection. We have already seen that data binding decouples
            Views and ViewModels from each other and allows them to communicate without knowing explicitly what is on
            the other end of the communication pipeline.
          </p>
          <p>
            Now we need something similar to decouple or ViewModels from our Client Services. So far in the demos you
            have seen that we have hard coded the construction of a Client Service or Customers repository and newing it
            up explicitly within the ViewModel and holding onto a reference to it.
          </p>
          <p>
            That isn’t a bad thing if you are not worried about Unit Testing and if that is the only ViewModel that is
            going to use that Client Service. As soon as you want to start having some shared state in your Client
            Services that multiple ViewModels see and as soon as you want to write Unit Tests against your ViewModel
            logic that uses that Client Service you will have problems with how we have been structuring things. The
            solution is to use Dependency Injection and Interfaces on our Services. Those will provide the decoupling we
            need and you will see that we can easily wire things together using that.
          </p>
          <p>
            When you start talking Dependency Injection the subject of containers usually comes up pretty quickly. You
            can do manual Dependency Injection but that only gets you so far. Typically, you are going to want to use a
            container to help you out here.
          </p>
          <p>
            Inversion of Control (IoC) and Dependency Injection (DI) are two design patterns that are closely related. A
            “Container” is a chunk of infrastructure code that does both of those patterns for you. The IoC pattern is
            about delegating responsibility for construction and the Dependency Injection pattern is about providing
            dependencies to an object that has already been constructed.
          </p>
          <p>They can both be treated as a two phase approach to constructing. When you use a container the container
            takes several responsibilities:
          </p>
          <ul>
            <li>It constructs an object when asked. Instead of newing up objects yourself you will go to the container
              and ask it to produce an object for you.
            </li>
            <li>As part of the process the container will determine what that object depends on. Depending on the
              container used it can do that based on parametrized constructors, properties or methods.
            </li>
            <li>To provide those dependencies the container will then construct those dependencies and will inject them
              into the object being constructed
            </li>
            <li>The dependencies being constructed may have dependencies of their own and so on. So the process is
              recursively repeated until an entire object graph is built up from the object you asked for down through
              all of its dependencies.
            </li>
          </ul>
          <p>
            A container can also handle different instancing patterns and produce singleton objects where it constructs
            them on the first try and then just hands out a reference to them each other time some object takes a
            dependency on them.
          </p>
          <p>There are many Containers to choose from:</p>
          <ul>
            <li>Unity</li>
            <li>AutoFac</li>
            <li>Ninject</li>
            <li>StructureMap</li>
          </ul>
          <p>
            Let’s take a look at how we can use Dependency Injection to break the coupling that we have between the
            ViewModels and the Client Services at this point in our code.
          </p>
          <h3>Demo: Adding Dependency Injection for Client Services</h3>
          <div class="example">
            <div class="input-group">
              <input id="Ex06-009" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 6\ZzaDesktop-Start\ZzaDesktop.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex06-009"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <div class="example">
            <div class="input-group">
              <input id="Ex06-010" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 6\ZzaDesktop-End\ZzaDesktop.sln">
              <span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex06-010"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <p>
            So in this demo we want to wire up the Save handling from our Add/Edit form and see how we can use
            Dependency Injection related to that. The initial straightforward way to do the Save handling would be to
            drop into the AddEditCustomerViewModel and new up an instance of our CustomersRepository.:
          </p>
          <figure>
            <pre class="prettyprint">private ICustomersRepository _repo = new CustomersRepository();</pre>
            <figcaption>Fig 06-040</figcaption>
          </figure>
          <p>
            Then drop down to the OnSave handling method and call UpdateCustomer or AddCustomer methods of that
            repository. There are a couple of issues with this approach:
          </p>
          <ul>
            <li>Testability – this is a hard coded, not exposed, dependency that the AddEditCustomerViewModel now has.
              Any method that touches this object is going to be really hard to Unit Test because it is going to
              actually try and go out to the database. We don’t want that in a Unit Test environment. We want to be able
              to substitute a mock object.
            </li>
            <li>Another problem is that this ViewModel is newing up its own instance of the CustomersRepository and if
              you remember over in the CustomerListViewModel it is newing up a different instance of the
              CustomersRepository. So the objects that get read in by those two can be completely separate objects that
              really represent the same rows under the covers. When you are doing that kind of thing you really want a
              Singleton model for that repository so that you are exposing shared state to the multiple ViewModels that
              are going to use it. That is where Dependency Injection comes in.
            </li>
          </ul>
          <p>The first thing we want to do is change the code in our ViewModel to take in a reference to an
            ICustomersRepository:
          </p>
          <figure>
            <pre class="prettyprint">public AddEditCustomerViewModel(ICustomersRepository repo)</pre>
            <figcaption>Fig 06-041</figcaption>
          </figure>
          <p>
            Now you can see this type is not coupled to the concrete type at all just the interface and provides a path
            for passing in a mock object in a Unit Test environment. We can go and make a similar change to our
            CustomerListViewModel and now likewise our CustomerListViewModel just takes in the interface reference and
            is no longer coupled to the concrete type.
          </p>
          <p>
            For the above code to work we would need to move up to the parent ViewModel and pass that in. So we go to
            the MainWindowViewModel and new up the instance of the CustomersRepository here:
          </p>
          <figure>
            <pre class="prettyprint">private ICustomersRepository _repo = new CustomersRepository();</pre>
            <figcaption>Fig 06-042</figcaption>
          </figure>
          <p>Then change the construction of those child ViewModels to pass it in through the constructor:</p>
          <figure>
                <pre class="prettyprint">_customerListViewModel = new CustomerListviewModel(_repo);
_addEditViewModel = new AddEditCustomerViewModel(_repo);</pre>
            <figcaption>Fig 06-043</figcaption>
          </figure>

          <p>
            So this fixes the problem for our child ViewModels in that they get passed in the appropriate thing at
            runtime but can have an alternate thing passed in when in a Unit Test environment and they are only coupled
            to the interface now.
          </p>
          <p>
            However, now our parent type has been somewhat corrupted because it now depends on a concrete type that it
            doesn’t even use directly itself. How do we fix that? That leads us to using a Container to do the
            resolution of all dependencies. We are going to use the Unity container.
          </p>
          <p>Firstly, get Unity from NuGet:</p>
          <figure>
            <img src="./images/Fig06-044.png"/>
            <figcaption>Fig06-044</figcaption>
          </figure>
          <p>
            Now when using a container, you generally have a singleton model for the container itself so we will wire up
            a simple helper for the singleton pattern here that we will call ContainerHelper. The ContainerHelper class
            exposes a singleton instance of an IUnityContainer container through a static property:
          </p>
          <figure>
                <pre class="prettyprint">public static IUnityContainer Container
{
    get { return _container; }
}</pre>
            <figcaption>Fig 06-044A</figcaption>
          </figure>
          <p>
            It can also be the place where you do your centralized registration of any types that you want the container
            to be responsible for creating:
          </p>
          <figure>
                <pre class="prettyprint">_container = new UnityContainer();
_container.RegisterType&lt;ICustomersRepository, CustomersRepository&gt;(
    new ContainerControlledLifetimeManager());</pre>
            <figcaption>Fig 06-045</figcaption>
          </figure>
          <p>
            In the API of Unity what we do here is basically say whenever someone asks for an ICustomersRepository give
            them the CustomersRepository as the concrete type. The ContainerControlledLifetimeManager indicates to Unity
            to make the type a singleton. So when someone tries to get an ICustomersRepository from the Container it
            will new up a CustomersRepository and satisfy any dependencies it has. Any subsequent time it will just
            return the reference to the singleton.
          </p>
          <p>To use this, we go back to the parent ViewModel (MainWindowViewModel) and add a namespace for the Unity
            namespace:
          </p>
          <figure>
            <pre class="prettyprint">using Microsoft.Practices.Unity;</pre>
            <figcaption>Fig 06-046</figcaption>
          </figure>
          <p>Next we will change the way the child ViewModels are created so that they use the Container:</p>
          <figure>
                <pre class="prettyprint"> _customerListViewModel = ContainerHelper.Container.Resolve&lt;CustomerListViewModel&gt;();
_addEditViewModel = ContainerHelper.Container.Resolve&lt;AddEditCustomerViewModel&gt;();</pre>
            <figcaption>Fig 06-047</figcaption>
          </figure>
          <p>
            We use a Resolve method in Unity specifying the type that we want to create. When it goes to construct that
            object it will satisfy its dependencies based on its parametrized constructor. So it will be able to
            construct and inject a singleton instance of ICustomersRepository. Now this parent ViewModel does'nt even
            have to know about this dependency so we can delete the line:
          </p>
          <figure>
            <pre class="prettyprint">private ICustomersRepository _repo = new CustomersRepository();</pre>
            <figcaption>Fig 06-048</figcaption>
          </figure>
          <p>
            Now finally we can wire up the Save handling in our AddEditCustomerViewModel. So now when we call Save we
            will first copy the contents of our editing Customer back into the original object that we held a reference
            to with another helper method called UpdateCustomer that pushes and pulls the relevant properties:
          </p>
          <figure>
                <pre class="prettyprint">private void UpdateCustomer(SimpleEditableCustomer source, Customer target)
{
    target.FirstName = source.FirstName;
    target.LastName = source.LastName;
    target.Phone = source.Phone;
    target.Email = source.Email;
}</pre>
            <figcaption>Fig 06-049</figcaption>
          </figure>
          <p>
            You could use a tool like AutoMapper for doing this kind of thing. Then depending on our mode we either call
            UpdateCustomerAsync or AddCustomerAsync on our repository:
          </p>
          <figure>
                <pre class="prettyprint">private async void OnSave()
{
    UpdateCustomer(Customer, _editingCustomer);
    if (EditMode)
        await _repo.UpdateCustomerAsync(_editingCustomer);
    else
        await _repo.AddCustomerAsync(_editingCustomer);
    Done();
}</pre>
            <figcaption>Fig 06-049A</figcaption>
          </figure>
          <p>
            Finally, we signal that we are done. In a production environment we would add error handling in case those
            methods threw exceptions.
          </p>
          <p>
            Now if we run the application, select a customer and click Edit, change their name and click Save. You will
            see the change has been made successfully. If you stop and restart the application, you will see the change
            persists.
          </p>
          <p>Now we have Dependency Injection and Validation wrapped up we will cover one more use case scenario –
            searching and filtering the Customer list.
          </p>
          <h3>Demo: Searching and Filtering Data</h3>
          <div class="example">
            <div class="input-group">
              <input id="Ex06-011" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 6\ZzaDesktop-Start\ZzaDesktop.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex06-011"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <div class="example">
            <div class="input-group">
              <input id="Ex06-012" type="text"
                     value="C:\DevelopmentTutorials\Pluralsight-Courses\WPF MVVM In Depth\Module 6\ZzaDesktop-End\ZzaDesktop.sln">
<span class="input-group-btn"><button class="btn" data-clipboard-target="#Ex06-012"><img src="/./src/assets/clippy.svg" width="13" alt="Copy to clipboard"></button></span>
            </div>
          </div>
          <p>
            The one last use case that we will look at is searching the Customers list and filtering the list based on
            your search. Go to the CustomerListView and take the Grid that we had at the top which contains the
            AddCustomer button and I will add a
          </p>
          <ul>
            <li>A StackPanel that contains</li>
            <ul>
              <li>A Search Label</li>
              <li>A TextBox to accept search criteria</li>
              <li>An X Button to clear out the search criteria</li>
            </ul>
          </ul>
          <figure>
                <pre class="prettyprint">&lt;Button Content=&quot;Add Customer&quot;
            Command=&quot;{Binding AddCustomerCommand}&quot;
            Grid.Column=&quot;0&quot;
            HorizontalAlignment=&quot;Left&quot; /&gt;
    &lt;StackPanel Orientation=&quot;Horizontal&quot;
                HorizontalAlignment=&quot;Right&quot;
                Grid.Column=&quot;1&quot;&gt;
        &lt;Label Content=&quot;Search:&quot; /&gt;
        &lt;TextBox Text=&quot;{Binding SearchInput, UpdateSourceTrigger=PropertyChanged}&quot;
                 Width=&quot;150&quot; /&gt;
        &lt;Button Content=&quot;X&quot;
                Command=&quot;{Binding ClearSearchCommand}&quot; /&gt;
    &lt;/StackPanel&gt;
&lt;/Grid&gt;</pre>
            <figcaption>Fig 06-050</figcaption>
          </figure>
          <p>That means our ViewModel needs to support two new things:</p>
          <ul>
            <li>A property called SearchInput that we want to be set every time a keystroke happens so we use the
              UpdateSourceTrigger on the binding and set that to PropertyChanged
            </li>
            <li>We also need a ClearSearchCommand to clear out the search term</li>
          </ul>
          <figure>
                <pre class="prettyprint">private string _SearchInput;

public string SearchInput
{
    get { return _SearchInput; }
    set
    {
        SetProperty(ref _SearchInput, value);
        FilterCustomers(_SearchInput);
    }
}

private void FilterCustomers(string searchInput)
{
    if (string.IsNullOrWhiteSpace(searchInput))
    {
        Customers = new ObservableCollection&lt;Customer&gt;(_allCustomers);
        return;
    }
    else
    {
        Customers = new ObservableCollection&lt;Customer&gt;(_allCustomers.Where(c =&gt; c.FullName.ToLower().Contains(searchInput.ToLower())));
    }
}</pre>
            <figcaption>Fig 06-051</figcaption>
          </figure>
          <p>
            In our CustomerListViewModel we define that SearchInput property so when the property gets set we need to
            trigger filtering of the Customers that are being presented. That means we are going to need another
            Customer collection. One that contains all Customers and then the exposed one that is data bound to that
            contains just the Customers that are to be presented at the current time.
          </p>
          <p>
            Once we have that and the FilterCustomers gets called we are going to check and see if there is anything as
            a search term and if there is we will apply a Where clause to check to see if the FullName property of the
            Customer contains our search term. We will use the results of that LINQ query to populate our Customers
            property with the filtered list triggering a property change and therefore the screen will update.
          </p>
          <p>So we just need to add the _allCustomers collection and we need to populate that when we load our
            Customers:
          </p>
          <figure>
                <pre class="prettyprint">private List&lt;Customer&gt; _allCustomers;

public async void LoadCustomers()
{
    _allCustomers = await _repo.GetCustomersAsync();
    Customers = new ObservableCollection&lt;Customer&gt;(_allCustomers);
}</pre>
            <figcaption>Fig 06-052</figcaption>
          </figure>
          <p>
            We declare the list of _allCustomers, we can await and hold onto that and then we can do our initial
            population of the Customers property with _allCustomers. Then we just need to support the ClearSearchCommand
            using the standard three steps for Command handling:
          </p>
          <p>Expose a property for the Command:</p>
          <figure>
            <pre class="prettyprint">public RelayCommand ClearSearchCommand { get; private set; }</pre>
            <figcaption>Fig 06-053</figcaption>
          </figure>

          <p>Construct the Command and point it to its handling method:</p>
          <figure>
            <pre class="prettyprint">ClearSearchCommand = new RelayCommand(OnClearSearch);</pre>
            <figcaption>Fig 06-054</figcaption>
          </figure>
          <p>And define that handling method in this case nulling out the SearchInput:</p>
          <figure>
                <pre class="prettyprint">private void OnClearSearch()
{
    SearchInput = null;
}</pre>
            <figcaption>Fig 06-055</figcaption>
          </figure>
          <p>
            Now if we run the application, go to the Customers view, put in a search term and you can see the list
            tailoring to your search criteria. Clicking the clear Button will take you back to the full list of
            Customers.
          </p>
          <h3>MVVM Toolkits</h3>
          <p>
            So before we wrap up this module and course let’s talk about some toolkits and frameworks that are out there
            that you can leverage so that you don’t have to write a bunch of repetitive code to implement the MVVM
            pattern yourself.
          </p>
          <h3>Prism</h3>
          <p>
            This was first developed by Microsoft Patterns and Practices. Currently this is an open source project of
            which Brian Noyes is one of the authors.
          </p>
          <h3>MVVM Light</h3>
          <p>MVVM Light is developed by Laurent Bugnion and there is a Pluralsight course on MVVM Light.</p>
          <h3>Caliburn Micro</h3>
          <p>Another a small open source framework that helps you implement the MVVM pattern and also supports a number
            of things out of the box.
          </p>
          <h3>Prism</h3>
          <p>
            Now we will go back to Prism and look at it in more depth. Prism has a number of things out of the box. It
            has a BindableBase class similar to the one we implemented earlier in the course.
          </p>
          <p>
            It has a flexible ViewModelLocator that has conventions to it but also lets you override those conventions
            and declaratively hook up your Views and ViewModels in a loosely coupled way.
          </p>
          <p>
            Modularity – the ability to break up your code into totally loosely coupled class libraries and parts and
            bring them together at runtime into a cohesive whole for the end user while the code remains decoupled.
          </p>
          <p>
            Prism also supports the notion of UI Composition and Regions. The ability to plug Views into Containers
            without the View that is doing the plugging needing to have an explicit reference to the UI Container
            itself.
          </p>
          <p>
            Prism has navigation features that layer on top of regions that give you things like forward and back
            navigation and the navigation stack and allowing your ViewModels to participate in the navigation process
            directly.
          </p>
          <p>
            Prism has Commands. So they have a Delegate Command that is very similar to the RelayCommand that we have
            been using throughout the course except it’s got some extra robustness to protect you from memory leaks if
            you're Views and ViewModels have different lifetimes. There is also a separate Command implementation called
            CompositeCommand that lets you do Commanding in a more loosely coupled way across components.
          </p>
          <p>
            Finally, Prism has support for Pub/Sub Events. These are loosely coupled events where the publisher and
            subscriber can have different lifetimes and do not have to have specific references to each other to
            communicate through events.
          </p>
          <p>Brian Lagunas, one of the co-authors of the Prism framework has written a number of Pluralsight courses on
            the subject.
          </p>
          <h3>Summary</h3>
          <p>
            We have completed our journey through MVVM as a pattern. In this module we saw the Visual Studio Data
            Designer can quickly scaffold out your data-centric Views but you can still wire them up easily in an MVVM
            fashion.
          </p>
          <p>
            You saw the validation logic belongs on the Model or ViewModel properties but the good news is that in MVVM
            we are always binding to those properties so it is very easy to setup the infrastructure for validation and
            reuse that across your ViewModel and Model objects.
          </p>
          <p>
            We looked at Dependency Injection and saw that it makes it so that your ViewModels are only coupled to your
            Client Services via the Interfaces that they implement and that you can use a Container to Dependency Inject
            those references at runtime for you.
          </p>
          <p>Finally, we talked about MVVM frameworks and Toolkits out there and you should look into these and use one
            to help you implement MVVM.
          </p>
          <p>This course has hopefully helped you understand the MVVM pattern in depth and you could go build your own
            MVVM infrastructure based on what you saw here in this course. But leveraging one of those existing
            frameworks that each have a large user base and good support from the project owners will just save you time
            and help you avoid repetitive code.
          </p>
        </div>
      </div>
    </div>
  </div>
</body>
</html>