<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

<head>
  <meta charset="UTF-8">
  <title>maxsagetech - Developing Faster with the Vue CLI</title>
  <script src="https://unpkg.com/vue"></script>
  <!--<link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"-->
  <!--integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" rel="stylesheet">-->
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
    integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
  </style>
</head>

<body>
  <div class="container" id="app">
    <div class="panel-group">
      <div class="panel panel-primary">
        <div class="panel-heading">
          <h2>Developing Faster with the Vue CLI</h2>
        </div>
        <div class="panel-body">
          <div>
            <h2>Building and Serving Vue</h2>
            <div>
              <h3>Overview of the Building and Serving</h3>
              <p>I'm a developer, and writing code is where it's at. But when we're done writing code, it's super
                important to make sure you've got a good build process to make sure that you can build the applications
                to deploy them effectively to your web servers. In this module, we're going to look closely at how we
                can build and serve Vue applications using the Vue CLI.</p>
              <p>We'll kick things off by going through the Vue CLI service and understanding its role in building and
                serving. We'll explore serving first and look at the different options in how to serve our code,
                especially for that dev development lifecycle. Then we'll look at building apps a little bit closer, and
                we can build applications, we can build libraries, and we can build web components with the Vue CLI. By
                the end of this module, you'll have a good understanding of the differences between apps, libraries, and
                web components, and how to do them yourselves. </p>
            </div>
            <div>
              <h3>Exploring the Vue CLI Service</h3>
              <p> The heart and soul that makes building and serving work in the Vue CLI is the Vue CLI Service:</p>
              <figure> <img src="images/Fig05-001.png" />
                <figcaption>Fig 05-001</figcaption>
              </figure>
              <p>When we install the Vue CLI, we get this, and it's the vue-cli-service. It's the main tool for building
                and serving. It uses webpack to do the builds and serves for us. And out of the box when we create a new
                application, it creates npm scripts in the package.json file, so we can make running and building super
                easy.</p>
              <p>The way we use the binary for our Vue CLI Service is to run the npm scripts, like npm run serve:</p>
              <figure> <img src="images/Fig05-002.png" />
                <figcaption>Fig 05-002</figcaption>
              </figure>
              <p>That'll build it up with webpack and then serve it in the browser. Another option is we could access
                the binary directly in the node_modules folder, like this. It does the same thing, but I don't know
                about you, but I'd rather run npm run serve. Another option is run npx vue-cli-service serve. What this
                does right from the command line is you can run anything that's in the binary folder of node_modules.
                Effectively in this case, npx is a shortcut to. /node_modules/. bin, but 99 times out of 100, you're
                just going to type npm run serve.</p>
              <p>If you want to use npx, you just require npm version 5. 2 or greater. Let's take a look inside of a
                project to see where all this comes into play. Here we have the HEROES-VUE application that we pulled
                down from GitHub earlier in the course:</p>
              <figure> <img src="images/Fig05-003.png" />
                <figcaption>Fig 05-003</figcaption>
              </figure>
              <p>If you need that URL, here it is. Once we pull it down, we can open up the package.json, and notice
                that in here we've got lines 6, 7, and 8:</p>
              <figure> <img src="images/Fig05-004.png" />
                <figcaption>Fig 05-004</figcaption>
              </figure>
              <p>npm run serve, build, and lint. All three of those are using the Vue CLI Service directly. And then
                I've extended my scripts with a couple commands to help run my specific application. To fake a back end,
                I'm running a JSON server in the back end here:</p>
              <figure> <img src="images/Fig05-005.png" />
                <figcaption>Fig 05-005</figcaption>
              </figure>
              <p>I've created npm run quick:</p>
              <figure> <img src="images/Fig05-006.png" />
                <figcaption>Fig 05-006</figcaption>
              </figure>
              <p>which concurrently runs npm run backend for the JSON server, and then also npm run serve. So I can run
                this by going into my terminal here and typing:</p>
              <figure>
                <pre><code class="language-command-line">npm run quick</code></pre>
                <figcaption>Fig 05-007</figcaption>
              </figure>
              <p>which is going to run line 9, which also runs line 12 and line 6 simultaneously here. So the CLI
                service is building the application, and once it's ready, to launch it in the browser. Now we can click
                on the link:</p>
              <figure> <img src="images/Fig05-008.png" />
                <figcaption>Fig 05-008</figcaption>
              </figure>
              <p>and we can see the application running. And that's all we need to serve our application. </p>
            </div>
            <div>
              <h3>Learning How to Serve Vue</h3>
              <p>It's time to learn how to use npm run serve. So we'll open up the HEROES-VUE application, we could use
                any app really, but inside of here we're going to type in:</p>
              <figure>
                <pre><code class="language-command-line">npm run serve</code></pre>
                <figcaption>Fig 05-009</figcaption>
              </figure>
              <p>Now if we do that, if we go back into package.json, we're going to see that npm run serve will run this
                Vue CLI Service for us:</p>
              <figure> <img src="images/Fig05-010.png" />
                <figcaption>Fig 05-010</figcaption>
              </figure>
              <p>And while it's building here, let's take a look at what else is needed in this project. This project
                happens to need a back-end server, and I've got this backend command:</p>
              <figure> <img src="images/Fig05-011.png" />
                <figcaption>Fig 05-011</figcaption>
              </figure>
              <p>which will run a fake back end for us. Now if I run the app by clicking here:</p>
              <figure> <img src="images/Fig05-012.png" />
                <figcaption>Fig 05-012</figcaption>
              </figure>
              <p>you'll notice that the proxy error comes up:</p>
              <figure> <img src="images/Fig05-013.png" />
                <figcaption>Fig 05-013</figcaption>
              </figure>
              <p>because it can't proxy from 9626 to port 9627 for my APIs. And this is what the app will look like
                because it can't find the back-end database:</p>
              <figure> <img src="images/Fig05-014.png" />
                <figcaption>Fig 05-014</figcaption>
              </figure>
              <p>because it's on a different port. So what I'm going to do is open up a split terminal here:</p>
              <figure> <img src="images/Fig05-015.png" />
                <figcaption>Fig 05-015</figcaption>
              </figure>
              <p>and I'm also going to run:</p>
              <figure>
                <pre><code class="language-command-line">npm run backend</code></pre>
                <figcaption>Fig 05-016</figcaption>
              </figure>
              <p>Now if you're not running this specific app, you won't need that here. But now if I go back to the
                application, and let's refresh, the application works just fine:</p>
              <figure> <img src="images/Fig05-017.png" />
                <figcaption>Fig 05-017</figcaption>
              </figure>
              <p>That's because the back end is on a different port, and this is pretty common out there. So there's a
                couple things to dissect here. First, we ran npm run serve to build our application in memory and then
                serve it up in the browser. And for those times we need to hit a back end that has a separate API,
                there's a setting you can do inside of vue by creating this vue. config.js file down here.:</p>
              <figure> <img src="images/Fig05-018.png" />
                <figcaption>Fig 05-018</figcaption>
              </figure>
              <p>Notice inside the dev server we have this thing called proxy on line 6:</p>
              <figure> <img src="images/Fig05-019.png" />
                <figcaption>Fig 05-019</figcaption>
              </figure>
              <p>The proxy is saying that whenever you see traffic trying to get to /api, which is what my client Vue
                application is looking for, instead switch the port over to localhost 9627, which is where my back-end
                server is running. Remember when we ran npm run serve, the application opened on 9626, and then we got
                an error down here that said I can't find 9627. That's because the proxy was looking for it down there.
                This is to avoid the CORS issue, or cross-origin issues, when you're running applications that hit
                multiple ports. Long story short here, if you're running a Vue app and you have no back end, no worries,
                or if it's being served from the same back end as you're serving your Vue app. But quite often, you'll
                have a back end that runs on a different port. So this proxy API will help you do that.</p>
              <p>Now there's other modes we could be running in. Let's go ahead and leave the back end running, but over
                here we're going to stop the server from running:</p>
              <figure> <img src="images/Fig05-020.png" />
                <figcaption>Fig 05-020</figcaption>
              </figure>
              <p>Instead, we can take a look at some other options that we could have. If we do:</p>
              <figure>
                <pre><code class="language-command-line">npx vue-cli-service --help</code></pre>
                <figcaption>Fig 05-021</figcaption>
              </figure>
              <p>Remember npx is going to let me run this vue-cli-service without typing in . node_modules/. bin, etc.
                Now we can do --help. We're going to see all the commands that we get running with serve:</p>
              <figure> <img src="images/Fig05-022.png" />
                <figcaption>Fig 05-022</figcaption>
              </figure>
              <p>Now we could say this:</p>
              <figure>
                <pre><code class="language-command-line">npx vue-cli-service serve --help</code></pre>
                <figcaption>Fig 05-023</figcaption>
              </figure>
              <p>and type serve right up there. We can open the browser on server start:</p>
              <figure> <img src="images/Fig05-024.png" />
                <figcaption>Fig 05-024</figcaption>
              </figure>
              <p>which means we just type something in like this with --open:</p>
              <figure>
                <pre><code class="language-command-line">npx vue-cli-service serve --open</code></pre>
                <figcaption>Fig 05-025</figcaption>
              </figure>
              <p>and that'll run it and open it right in the browser. So let's try that real quick. And there's the app:
              </p>
              <figure> <img src="images/Fig05-026.png" />
                <figcaption>Fig 05-026</figcaption>
              </figure>
              <p> We'll cancel it again, we'll go back to running help. Copy is nice too because we can run it and serve
                it, but maybe we don't want to open it in the browser, maybe that's distracting:</p>
              <figure>
                <pre><code class="language-command-line">npx vue-cli-service serve --copy</code></pre>
                <figcaption>Fig 05-027</figcaption>
              </figure>
              <p>We can copy the URL of the browser to the clipboard by doing this, we can change the mode by using
                mode, we can change the host and the port by using those settings, and of course we can change to use
                HTTPS if we can get that running locally.</p>
              <p>So we've got a lot of options here when we run our serve applications. Now my recommendation is, if
                you're going to change those options up, like if you always want it to open, go open your package.json,
                go into serve:</p>
              <figure> <img src="images/Fig05-028.png" />
                <figcaption>Fig 05-028</figcaption>
              </figure>
              <p>or create a new script, and do something like this here:</p>
              <figure>
                <pre><code class="language-command-line">"serve": "vue-cli-service serve --open",</code></pre>
                <figcaption>Fig 05-029</figcaption>
              </figure>
              <p>That way you don't have to type all that in, and then you can just type:</p>
              <figure>
                <pre><code class="language-command-line">npm run serve</code></pre>
                <figcaption>Fig 05-030</figcaption>
              </figure>
              <p>And that's how easy it is to serve your applications. </p>
            </div>
            <div>
              <h3>Serving with the Vue UI</h3>
              <p>One last thing to look at. Now let's cancel and close out both of our processes down here. And we'll
                kill them, and we'll reopen the terminal. Just make sure we had nothing running there. Now I'm going to
                run vue ui. So nothing is running, and we're going to run the vue ui:</p>
              <figure> <img src="images/Fig05-031.png" />
                <figcaption>Fig 05-031</figcaption>
              </figure>
              <p>Now for that Vue UI, it happened to be open on the Heroes project right now. If I wasn't, I could go
                down here to the bottom left, hit the home key:</p>
              <figure> <img src="images/Fig05-032.png" />
                <figcaption>Fig 05-032</figcaption>
              </figure>
              <p>and then I could import the project right in that folder. So I'm going to open that one up. Now if I go
                down to the Tasks here on the left:</p>
              <figure> <img src="images/Fig05-033.png" />
                <figcaption>Fig 05-033</figcaption>
              </figure>
              <p>notice I can click on serve:</p>
              <figure> <img src="images/Fig05-034.png" />
                <figcaption>Fig 05-034</figcaption>
              </figure>
              <p>right here on the left under Project tasks, and then I could run this task:</p>
              <figure> <img src="images/Fig05-035.png" />
                <figcaption>Fig 05-035</figcaption>
              </figure>
              <p>Now before I do, notice there's parameters:</p>
              <figure> <img src="images/Fig05-036.png" />
                <figcaption>Fig 05-036</figcaption>
              </figure>
              <p>By default, serve is going to run in development mode. I could also serve it in production mode if I
                want to. For now, let's keep it on development, and then I can run this task. Now notice when I run this
                task, you're going to see a little animation on the right-hand side:</p>
              <figure> <img src="images/Fig05-037.png" />
                <figcaption>Fig 05-037</figcaption>
              </figure>
              <p>as it's building the project for us. There is also Output right here:</p>
              <figure> <img src="images/Fig05-038.png" />
                <figcaption>Fig 05-038</figcaption>
              </figure>
              <p>next to the Dashboard. If we click on that, we can see the process as it outputs all of the things that
                it's doing while it's building the project.</p>
              <figure> <img src="images/Fig05-039.png" />
                <figcaption>Fig 05-039</figcaption>
              </figure>
              <p>Then it launched the project. Again, I'm not running the back-end server here:</p>
              <figure> <img src="images/Fig05-040.png" />
                <figcaption>Fig 05-040</figcaption>
              </figure>
              <p>so that's not working. When we click back to the dashboard, we can see some data about what happened
                here:</p>
              <figure> <img src="images/Fig05-041.png" />
                <figcaption>Fig 05-041</figcaption>
              </figure>
              <p>We have a rather large application because we have made it for development and not for production. We
                can scroll back up and look at the analyzer:</p>
              <figure> <img src="images/Fig05-042.png" />
                <figcaption>Fig 05-042</figcaption>
              </figure>
              <p>which will show us what's inside of our bundle, so we can examine what files are in there and what's
                being big. Now let's say we want to see this thing running. Remember, it wasn't running up here. I can
                also scroll down, and you'll notice I've got my npm scripts here:</p>
              <figure> <img src="images/Fig05-043.png" />
                <figcaption>Fig 05-043</figcaption>
              </figure>
              <p>I can run npm run backend simply by cloning this task right here. Now if I go back to my app and I
                refresh it, I have my data:</p>
              <figure> <img src="images/Fig05-044.png" />
                <figcaption>Fig 05-044</figcaption>
              </figure>
              <p>We'll learn a whole lot more about the Vue UI in a later chapter, but this gives you a taste of how you
                can use it to do the same commands that we ran right from the command line. </p>
            </div>
            <div>
              <h3>Understanding the Serving Options</h3>
              <p>Let's take a closer look at some of the commands that we ran when we were serving Vue with the Vue CLI.
                First, we were serving with npm by simply doing npm run serve, we ran an npm script to run our commands,
                but we can also use Yarn to do the same thing:</p>
              <figure> <img src="images/Fig05-045.png" />
                <figcaption>Fig 05-045</figcaption>
              </figure>
              <p>So we could use yarn serve if Yarn is our preference. So no worries, either way you roll, you're
                supported in the Vue CLI. We also saw a bunch of the options that the Vue CLI service holds for us, like
                open, copy, mode, and host, and the port and HTTPS:</p>
              <table class="table">
                <thead>
                  <tr>
                    <th>Options</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>--open</td>
                    <td>Open the browser on server start</td>
                  </tr>
                  <tr>
                    <td>--copy</td>
                    <td>Copy the url to the clipboard on server start</td>
                  </tr>
                  <tr>
                    <td>--mode</td>
                    <td>Specify the environment mode (default is development)</td>
                  </tr>
                  <tr>
                    <td>--host</td>
                    <td>The (default is 0.0.0.0)</td>
                  </tr>
                  <tr>
                    <td>--port</td>
                    <td>The (default is 8080)</td>
                  </tr>
                  <tr>
                    <td>--https</td>
                    <td>Use https (default is false)</td>
                  </tr>
                </tbody>
              </table>
              <p>These are options that you can customize based upon what you're trying to accomplish in the project. I
                recommend, again, that you put these in your npm scripts.</p>
              <p>We also took a look at how we could proxy requests using the vue. config.js file. So, let's say we had
                a host server that's serving our Vue application:</p>
              <figure> <img src="images/Fig05-046.png" />
                <figcaption>Fig 05-046</figcaption>
              </figure>
              <p>Now it's going to send our JavaScript and CSS, and HTML up to our Vue client. That's great, we've got
                our server, in this case maybe your laptop or desktop, running your application and serving it. But then
                when you make a request from a Vue client to some kind of an API back end, that's where the proxy comes
                into play and says, okay, you're asking to go to another back end to get JSON, and that JSON is coming
                from, let's say, another server. In this case, we're running it on a different port, which serves the
                same purpose. And we can do that by setting up that proxy inside of the vue. congif. js file. Now you
                have everything you need to go try serving your applications. So I recommend you take a timeout here and
                pause the video and go try serving your own Vue application, and then come right back and we'll move on
                to building. </p>
            </div>
            <div>
              <h3>Build Targets and Options</h3>
              <p>When we run npm run serve, we're building in memory and then showing the app in our browser, but when
                we want to write our files out to the hard drive, like to a dist folder, that's when we need to build
                with Vue. The Vue CLI Service does this for us.</p>
              <p>Some of the options you should be familiar with are:</p>
              <table class="table">
                <thead>
                  <tr>
                    <th>Options</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>--mode</td>
                    <td>Environment mode (default is production)</td>
                  </tr>
                  <tr>
                    <td>--dest</td>
                    <td>Output directory (default is dist)</td>
                  </tr>
                  <tr>
                    <td>--modern</td>
                    <td>Target modern browsers, with automatic fallback</td>
                  </tr>
                  <tr>
                    <td>--target</td>
                    <td>Type of app to build such as app, lib, wc (default is app)</td>
                  </tr>
                  <tr>
                    <td>--name</td>
                    <td>Name of the build</td>
                  </tr>
                  <tr>
                    <td>--no-clean</td>
                    <td>Do not remove the dist directory before building</td>
                  </tr>
                  <tr>
                    <td>--report</td>
                    <td>Generate a report analyze bundle</td>
                  </tr>
                  <tr>
                    <td>--report-json</td>
                    <td>Generate report (in JSON) to analyze bundle</td>
                  </tr>
                  <tr>
                    <td>--watch</td>
                    <td>Watch for changes</td>
                  </tr>
                </tbody>
              </table>
              <p>The mode, which by default is production, because when you're building and running the files to dist,
                you're probably doing it for production, which is going to give you a more optimized build. You can also
                set that to development.</p>
              <p>We can change the destination output directory, by default it is dist.</p>
              <p>We can also set the modern flag, and this is going to target modern browsers with automatic fallback to
                support browsers that don't support this. In effect, it's going to make your apps load faster on the
                modern browsers.</p>
              <p>You can also change the target. By default, we're going to build an application, or app, but you can
                change that to lib, or wc for library or web component. We're going to take a closer look at all three
                of these so we can see the differences of them.</p>
              <p>And there's some other options like no-clean where you don't remove the dist directory before you
                build, and there's report and report-json for generating reports about the analysis of the bundles that
                you're creating.</p>
              <p>And finally, if you want to build and then rebuild every time changes are made, you can set the watch
                option. So how does this work? Well, we simply run:</p>
              <figure>
                <pre><code class="language-command-line">npm run build</code></pre>
                <figcaption>Fig 05-047</figcaption>
              </figure>
              <p>and out of the box we run the npm script to do this:</p>
              <figure> <img src="images/Fig05-048.png" />
                <figcaption>Fig 05-048</figcaption>
              </figure>
              <p>and it's going to do a production build for an application, of course. We can also run vue-cli-service
                build with our target to be a library, if we want to build a component library, for example, or
                something that has a bunch of Vue features in it that we want to pull into other projects. We can then
                set the name of it and what the entry file is for that library. </p>
              <p>And maybe we want to create a web component, so we can change the target to be a web component and then
                set the entry component for that.</p>
              <p>Now the top command is shorter because we have an npm script to do that. Otherwise it would be:</p>
              <figure>
                <pre><code class="language-command-line">vue-cli-service build --target app</code></pre>
                <figcaption>Fig 05-049</figcaption>
              </figure>
              <p>Of course the npm script makes it so much easier, so I recommend if you're building a library or a web
                component that you also create npm scripts to run those.</p>
              <p>The really important parts here about the build targets are:</p>
              <figure> <img src="images/Fig05-050.png" />
                <figcaption>Fig 05-050</figcaption>
              </figure>
              <p>If you're building an application, by default that's just what you're doing with the build, and that's
                --target app. If you're building a library you want to --target lib. And of course, you can build a web
                component with --target wc. Now let's walk through some demos where we build an application, a library,
                and a web component. </p>
            </div>
            <div>
              <h3>Building an App</h3>
              <p>Let's walk through building an application. We'll go into VS Code into the terminal, and in our vue
                folder where we're creating some projects, we're going to create a new project that we will then build
                and explore what that build does. Let's call this one vue-build:</p>
              <figure>
                <pre><code class="language-command-line">vue create vue-build -d</code></pre>
                <figcaption>Fig 05-051</figcaption>
              </figure>
              <p>just to take a look at what actually gets created, and we're going to use the default flags. Once it's
                done, we will go into the folder called vue build. If you look at it in the File Explorer over here, we
                see there's nothing there:</p>
              <figure> <img src="images/Fig05-052.png" />
                <figcaption>Fig 05-052</figcaption>
              </figure>
              <p>So inside of VS Code, we can write:</p>
              <figure>
                <pre><code class="language-command-line">code-insiders . -r</code></pre>
                <figcaption>Fig 05-053</figcaption>
              </figure>
              <p> That's just going to reopen it. Or you can just open it up in your favorite editor, either way. Now we
                can see that there is our project:</p>
              <figure> <img src="images/Fig05-054.png" />
                <figcaption>Fig 05-054</figcaption>
              </figure>
              <p>there is our components. We've got App.vue, and it's using HelloWorld, you see it on line 14 there:</p>
              <figure> <img src="images/Fig05-055.png" />
                <figcaption>Fig 05-055</figcaption>
              </figure>
              <p>and line 4. There is our HelloWorld with all the links and the basic stuff that you get in a Vue
                application:</p>
              <figure> <img src="images/Fig05-056.png" />
                <figcaption>Fig 05-056</figcaption>
              </figure>
              <p>So let's try to build this now. We'll go back into the terminal and we're going to type:</p>
              <figure>
                <pre><code class="language-command-line">npm run build</code></pre>
                <figcaption>Fig 05-057</figcaption>
              </figure>
              <p>Now let's take a look at the package.json while that's happening here. Because what I typed was what's
                on line 7:</p>
              <figure> <img src="images/Fig05-058.png" />
                <figcaption>Fig 05-058</figcaption>
              </figure>
              <p>Effectively, that's just a script over the vue-cli-service build command. And by default, it's doing a
                production build. Now this won't take very long because it was a small project. It's the HelloWorld
                default project that comes out of the box. Here in the output you can see that when we ran it:</p>
              <figure> <img src="images/Fig05-059.png" />
                <figcaption>Fig 05-059</figcaption>
              </figure>
              <p>it's telling us it's building for production. That means it's going to be optimized. You can see in the
                file names here:</p>
              <figure> <img src="images/Fig05-060.png" />
                <figcaption>Fig 05-060</figcaption>
              </figure>
              <p>we've got these numbers at the end of the files. That will change if any of the files or contents of
                those files change later when we do a rebuild. That's for cache busting. You can see that the sizes,
                they've gotten smaller here:</p>
              <figure> <img src="images/Fig05-061.png" />
                <figcaption>Fig 05-061</figcaption>
              </figure>
              <p>When you get gzip'd, and what this build created was a bunch of files in the dist folder. We can see
                that here in the output. So let's go look at the dist folder in the upper left now:</p>
              <figure> <img src="images/Fig05-062.png" />
                <figcaption>Fig 05-062</figcaption>
              </figure>
              <p>And we can see that we've got CSS, our images, and any JavaScript we might have:</p>
              <figure> <img src="images/Fig05-063.png" />
                <figcaption>Fig 05-063</figcaption>
              </figure>
              <p>And inside the HTML, we can see that's all scrunched up on one line:</p>
              <figure> <img src="images/Fig05-064.png" />
                <figcaption>Fig 05-064</figcaption>
              </figure>
              <p>and we can see our script tags are up here for the JavaScript:</p>
              <figure> <img src="images/Fig05-065.png" />
                <figcaption>Fig 05-065</figcaption>
              </figure>
              <p>If we wanted to, we could go in and do a development build. That would give us less optimized code.
                That is not the default. We're most often going to want to get a production build with the
                optimizations.</p>
              <p>Now how do we serve this code? Well if you have your own web server, you can run it, or you can use a
                tool like http-server. I don't have it installed, so I'm going to run:</p>
              <figure>
                <pre><code class="language-command-line">npx http-server ./dist</code></pre>
                <figcaption>Fig 05-066</figcaption>
              </figure>
              <p>and I tell it run inside the dist folder. Now this is going to run out to npm and pull down
                http-server, and then it's going to run that, even though we haven't installed it here, that's the cool
                thing about npx, and it's going to host it in the default port of 8080.</p>
              <figure> <img src="images/Fig05-067.png" />
                <figcaption>Fig 05-067</figcaption>
              </figure>
              <p>You can then click on that, and then there is the application running:</p>
              <figure> <img src="images/Fig05-068.png" />
                <figcaption>Fig 05-068</figcaption>
              </figure>
              <p>Now if you go look at the Network tab, and then we refresh, we'll see there are those application files
                for the JavaScript:</p>
              <figure> <img src="images/Fig05-069.png" />
                <figcaption>Fig 05-069</figcaption>
              </figure>
              <p>If I click on All, we can see all the files that came across:</p>
              <figure> <img src="images/Fig05-070.png" />
                <figcaption>Fig 05-070</figcaption>
              </figure>
              <p>Then I'll close this browser, and then we can kill the process down there. What about some of the other
                options we had? Well, let's go back to the package.json for a moment. Now let's create a new script up
                here. We're going to call this one build fun:</p>
              <figure> <img src="images/Fig05-071.png" />
                <figcaption>Fig 05-071</figcaption>
              </figure>
              <p>We're going to explore some of the different things we can do with a build. And here, first, we're
                going to save vue-cli-service build, and then we're going to do modern:</p>
              <figure>
                <pre><code class="language-command-line">"build-fun": "vue-cli-service build --modern"</code></pre>
                <figcaption>Fig 05-072</figcaption>
              </figure>
              <p>Just like that. So let's go ahead and run this:</p>
              <figure>
                <pre><code class="language-command-line">npm run build-fun</code></pre>
                <figcaption>Fig 05-073</figcaption>
              </figure>
              <p>Now it's going to run the same kind of build, but now it's actually going to take advantage of modern
                bundles for us. So let's take a look at the output here:</p>
              <figure> <img src="images/Fig05-074.png" />
                <figcaption>Fig 05-074</figcaption>
              </figure>
              <p>Still building for production, but now it says a modern bundle for production. This modern bundle is a
                feature of the Vue CLI that uses something called modern mode. Effectively what this means is that in
                the more modern browsers, the more recent ones, there's better ways to send bundles that are smaller and
                more optimized to the browsers. Now this only works in the latest browsers, that's why it's called
                modern.</p>
              <p>Well, the best of both worlds here is if we're using the latest browsers, we want modern mode to be on
                because then we get less JavaScript being transported to the browser, and it's faster to parse inside
                the browser. But we also don't want to leave other users behind. Well, modern mode is good about this
                because it'll create the modern bundles and it'll create the bundles that the older browsers support
                with a fallback. Don't worry, both aren't being sent. Effectively it writes the code to make sure that
                if can support modern mode, that's what's sent. If not, it goes and gets the other ones.</p>
              <p>So we benefit with faster bundles and faster apps. Let's take a look what that means. Here's the output
                right there:</p>
              <figure> <img src="images/Fig05-075.png" />
                <figcaption>Fig 05-075</figcaption>
              </figure>
              <p>Now if we go back up into the dist folder, we look inside JavaScript, you can see we have some files
                called legacy:</p>
              <figure> <img src="images/Fig05-076.png" />
                <figcaption>Fig 05-076</figcaption>
              </figure>
              <p>Legacy are the older ones, not the modern mode, and then for example here, chunks-vendor, the bottom
                one:</p>
              <figure> <img src="images/Fig05-077.png" />
                <figcaption>Fig 05-077</figcaption>
              </figure>
              <p>That is the one that's been developed for modern mode. So that's why we have four JavaScript files in
                this case.</p>
              <p>So to wrap up, the Vue CLI is going to produce two versions of your app. One with the modern bundle
                here, that's going to target modern browsers that support ES modules, and then another set of files that
                supports the legacy bundling that targets older browsers. </p>
            </div>
            <p>
              <h3>Building a Library</h3>
              <p>One thing you're likely to want to do is create a component library at some point. So how can you do
                that with Vue? Let's create a new project here that shows how to do it. We're going to do:</p>
              <figure>
                <pre><code class="language-command-line">vue create vue-hello-lib -d</code></pre>
                <figcaption>Fig 05-078</figcaption>
              </figure>
              <p>We call these libraries. Now I'm going to set -d there just to get us the defaults. Now let's go into
                the folder, and let's open up the editor right where we are. If we look at the folder, we have a project
                here where we've got App.vue:</p>
              <figure> <img src="images/Fig05-079.png" />
                <figcaption>Fig 05-079</figcaption>
              </figure>
              <p>and it's loading HelloWorld:</p>
              <figure> <img src="images/Fig05-080.png" />
                <figcaption>Fig 05-080</figcaption>
              </figure>
              <p>which is another component inside of here:</p>
              <figure> <img src="images/Fig05-081.png" />
                <figcaption>Fig 05-081</figcaption>
              </figure>
              <p>Nothing so far about this project has anything to do with a library, but we're going to make it one.
                Effectively, we want the HelloWorld component, and we could add others as well, to be something we could
                reuse. Let's make this component a little simpler. We're just going to keep that h1 up there:</p>
              <figure> <img src="images/Fig05-082.png" />
                <figcaption>Fig 05-082</figcaption>
              </figure>
              <p>There we go. So this is going to be our HelloWorld, and it's going to say hello world as part of the
                message that gets passed in. And just to make it super simple, we're just going to add hello in the h1:
              </p>
              <figure> <img src="images/Fig05-083.png" />
                <figcaption>Fig 05-083</figcaption>
              </figure>
              <p> Once we have a component that we want to export, one thing we could do here is create a file, and
                we're going to call it index.js, which effectively is going to be a way to barrel all of our components
                together and export them. We'll start off by importing Vue from vue, and then we're going to import our
                component:</p>
              <figure> <img src="images/Fig05-084.png" />
                <figcaption>Fig 05-084</figcaption>
              </figure>
              <p>And then we need to tell Vue that these exist. So we're going to do vue.component, and then give them
                names. We need to repeat this for every component that you have.</p>
              <p>Then finally, we're going to export this as a default object. And in case we have series of them, we
                could export them in series here. So if I have HelloWorld and I had another one, maybe like ModalWindow,
                and I had another one that was Foo, I could put them like this:</p>
              <figure> <img src="images/Fig05-085.png" />
                <figcaption>Fig 05-085</figcaption>
              </figure>
              <p>How you export them is really up to you. This becomes our main file, our entry point, for building our
                library. So when somebody consumes our library, this is the file they're going to look at for, hey, what
                does that library have inside of it?</p>
              <p>Next, we're going to create a vue.config file, and we're doing this because we want Vue to know that
                we're going to have a library export that uses defaults:</p>
              <figure> <img src="images/Fig05-086.png" />
                <figcaption>Fig 05-086</figcaption>
              </figure>
              <p>So we're going to say module.exports. If you've already got a vue. congif file, just use the existing
                one. Now we can say configureWebpack, and then we're going to use output, and then libraryExport. The
                next set of steps all involves package.json. In the package.json, we want to set a few things up.
                There's the name of our project:</p>
              <figure> <img src="images/Fig05-087.png" />
                <figcaption>Fig 05-087</figcaption>
              </figure>
              <p>the version, whether it's private or not. We're going to create what you call a main file, that's going
                to be the entry point, which is going to be the index file we created. We'll tell it which files to
                include on npm when we publish these to npm, and then we'll create a build script in here so you don't
                have to type the whole build script out.</p>
              <p>So taking a step back, remember what we're going here is we're taking a project, and we're really using
                those components so we can publish them in a library form, possibly on public npm, or in an internal npm
                server, or company, so we can then consume them from another project and reuse them, effectively
                creating reusable components. So the name's important.</p>
              <p>Now, let's say I was going to put this publicly. I might have a scoped project, and here I could just
                say we can call it our, we'll just call it the same name:</p>
              <figure> <img src="images/Fig05-088.png" />
                <figcaption>Fig 05-088</figcaption>
              </figure>
              <p>Yours wouldn't be called @johnpapa, and if you don't have scope projects, you'll probably just want to
                call it something straight up like vue-hello-lib. You'll give it a version number. You may want it to be
                private. In this case, I don't, because I'm going to publish it. Next let's create our main file:</p>
              <figure> <img src="images/Fig05-089.png" />
                <figcaption>Fig 05-089</figcaption>
              </figure>
              <p>Now the main file's going to be what is that entry point to this application? It's going to be in the
                dist folder, and this is going to be called what? Vue-hello-lib, and then it's going to be common. js:
              </p>
              <figure> <img src="images/Fig05-090.png" />
                <figcaption>Fig 05-090</figcaption>
              </figure>
              <p>This is going to be the built version of our project, and that's going to be the file that runs right
                out of the gate. We'll take a look at this when we do the build, we should have a file that's named
                this. This naming convention is basically dist, that's the output folder when we do a build,
                vue-hello-lib, name of our project,. common. js. We'll come back to that and verify it's right.</p>
              <p>Next, we want to include our files. We'll be pretty explicit here. I want to say that I want to publish
                all of my distribution files:</p>
              <figure> <img src="images/Fig05-091.png" />
                <figcaption>Fig 05-091</figcaption>
              </figure>
              <p>that's your source code that's compiled and optimized. Next, we'll put our source code out there,
                because in this case I happen to want to publish it:</p>
              <figure> <img src="images/Fig05-092.png" />
                <figcaption>Fig 05-092</figcaption>
              </figure>
              <p>I'm also going to publish the public folder and any JSON or JavaScript files:</p>
              <figure> <img src="images/Fig05-093.png" />
                <figcaption>Fig 05-093</figcaption>
              </figure>
              <p>Finally, we don't want to be typing a long build script in, so I'm going to create a new one here
                called build-lib:</p>
              <figure> <img src="images/Fig05-094.png" />
                <figcaption>Fig 05-094</figcaption>
              </figure>
              <p>just to show the differences. We're going to get rid of the left-hand pane for the Explorer so we can
                see it as I type in, we're going to use a vue-cli-service to build. This time we're going to do a
                target, though, of lib. Remember the default target is app. We don't want app, we want a library. We
                want to name our project, so we're going to use --name.</p>
              <figure> <img src="images/Fig05-095.png" />
                <figcaption>Fig 05-095</figcaption>
              </figure>
              <p>This is going to be vue-hello-lib. Now this is any name you want. I happened to pick the same name as
                our project. This will then match what's up on main, right here, in vue-hello-lib:</p>
              <figure> <img src="images/Fig05-096.png" />
                <figcaption>Fig 05-096</figcaption>
              </figure>
              <p>And finally, remember that index file we had, and I'll peek back over at it, over here in the
                components:</p>
              <figure> <img src="images/Fig05-097.png" />
                <figcaption>Fig 05-097</figcaption>
              </figure>
              <p>We want to point to where do you start, what are we actually exposing here? So it's going to be
                building something that's in src/components, and then index. js:</p>
              <figure> <img src="images/Fig05-098.png" />
                <figcaption>Fig 05-098</figcaption>
              </figure>
              <p>Now you can see why we're putting this in npm scripts because I don't want to be typing that. So let's
                scroll up so we can see that command and let's open up our integrated terminal. And let's give it a
                shot. We'll run:</p>
              <figure>
                <pre><code class="language-command-line">npm run build-lib</code></pre>
                <figcaption>Fig 05-099</figcaption>
              </figure>
              <p>It should be building our library. And there we go, it compiled super fast. Now you may think, wow,
                that was really fast, like almost too fast because it's faster than an application in a lot of cases,
                and you'd be right. One of the things about building a library is Vue is externalized from the bundles.
                That's a really important point, because when you're building components and you're going to pull it
                into other projects, if those are Vue components, then Vue should already be in the other project. You
                don't want to be constantly building and bundling Vue in every project.</p>
              <p>Now let's go look at the output in the dist folder right here. We have our different bundles:</p>
              <figure> <img src="images/Fig05-100.png" />
                <figcaption>Fig 05-100</figcaption>
              </figure>
              <p>and we have a demo.html:</p>
              <figure> <img src="images/Fig05-101.png" />
                <figcaption>Fig 05-101</figcaption>
              </figure>
              <p>Let's take a look at that for a moment. The demo.html is going to pull in our script file and our CSS,
                and it's just going to call this library name:</p>
              <figure> <img src="images/Fig05-102.png" />
                <figcaption>Fig 05-102</figcaption>
              </figure>
              <p>Now that's not so useful in our case. What we really want to do at this point is, if you have an npm
                account or an internal npm server, or are using other tools like Artifact running locally on your
                machine in your network that you want to publish them to, you can then publish this library. And the
                command you'd use to do that is:</p>
              <figure>
                <pre><code class="language-command-line">npm publish</code></pre>
                <figcaption>Fig 05-103</figcaption>
              </figure>
              <p>if you're going to npm. We're not going to publish this publicly on npm, because, well, this one
                doesn't do a whole lot. But if all we'd have to do to pull this in after we publish it is then install
                this library, which would be called what? The name is in package.json:</p>
              <figure> <img src="images/Fig05-104.png" />
                <figcaption>Fig 05-104</figcaption>
              </figure>
              <p>So all we'd have to do in another project is type in:</p>
              <figure>
                <pre><code class="language-command-line">npm install @johnpapa vue-hello-lib</code></pre>
                <figcaption>Fig 05-105</figcaption>
              </figure>
              <p>like that. We could do --save-dev or just save, or whatever we want to do. That's once we publish it
                out to an npm server. And then inside of our project, to use that component we would just simply import
                HelloWorld, or whatever we called our components, from @johnpapa/vue-hello-lib. That's really all there
                is to building a library with Vue. </p>
          </div>
          <div>
            <h3>Building a Web Component</h3>
            <p> There will be times where you might want to create a web component with your Vue components. Let's take
              this same application, vue-hello-lib, where we have our HelloWorld component:</p>
            <figure> <img src="images/Fig05-106.png" />
              <figcaption>Fig 05-106</figcaption>
            </figure>
            <p>and instead of building a library, let's build it as a web component. So down here, instead of getting
              rid of or changing our lib on line 16 for build-lib:</p>
            <figure> <img src="images/Fig05-107.png" />
              <figcaption>Fig 05-107</figcaption>
            </figure>
            <p>we're going to make one called build-wc. Now the target is not going to be lib, it's going to be wc. You
              have to change a few other things at this point. We're going to change the name slightly to wc here:</p>
            <figure> <img src="images/Fig05-108.png" />
              <figcaption>Fig 05-108</figcaption>
            </figure>
            <p>just because we want to show the difference, but you don't have to do that. What's more important is you
              have to tell the entry file. Instead of getting a list of components in this case, now we're listing out
              the web component we want to use. And here we're going to list out the name of the web component that we
              want to compile:</p>
            <figure> <img src="images/Fig05-109.png" />
              <figcaption>Fig 05-109</figcaption>
            </figure>
            <p>And this will build our web component. So now we can go back into our terminal, and I'll open up the file
              over here on the left for the Explorer:</p>
            <figure> <img src="images/Fig05-110.png" />
              <figcaption>Fig 05-110</figcaption>
            </figure>
            <p>Let's run:</p>
            <figure>
              <pre><code class="language-command-line">npm run build-wc</code></pre>
              <figcaption>Fig 05-111</figcaption>
            </figure>
            <p>Now it's building our web component and it's putting it in the dist folder, and now notice that we just
              have a JavaScript file:</p>
            <figure> <img src="images/Fig05-112.png" />
              <figcaption>Fig 05-112</figcaption>
            </figure>
            <p>A minified version and a non-minified version. And there it is:</p>
            <figure> <img src="images/Fig05-113.png" />
              <figcaption>Fig 05-113</figcaption>
            </figure>
            <p>If we look inside our demo:</p>
            <figure> <img src="images/Fig05-114.png" />
              <figcaption>Fig 05-114</figcaption>
            </figure>
            <p>We can see that we can pull in our JavaScript file, and we should simply be able to use vue-hello-lib-wc.
              Also notice that we're pulling in Vue in this case:</p>
            <figure> <img src="images/Fig05-115.png" />
              <figcaption>Fig 05-115</figcaption>
            </figure>
            <p>in the demo from a CDN, for one package. But we could pull it into any Vue app we want by simply dropping
              this script tag on line 4 into a page:</p>
            <figure> <img src="images/Fig05-116.png" />
              <figcaption>Fig 05-116</figcaption>
            </figure>
            <p>and then using it like we did right here on line 7:</p>
            <figure> <img src="images/Fig05-117.png" />
              <figcaption>Fig 05-117</figcaption>
            </figure>
            <p>Let's use npx to open up an HTTP server:</p>
            <figure>
              <pre><code class="language-command-line">npx http-server ./dist</code></pre>
              <figcaption>Fig 05-118</figcaption>
            </figure>
            <p>It'll pull that down and we're going to serve the dist folder. Now once we do that, we'll open this up
              inside of a browser, and now let's browse to demo.html. Why? Before we browse to it, we're looking over
              here:</p>
            <figure> <img src="images/Fig05-119.png" />
              <figcaption>Fig 05-119</figcaption>
            </figure>
            <p>That is the name of the HTML file we're going to run. So let's run to that, and there is our Hello
              component:</p>
            <figure> <img src="images/Fig05-120.png" />
              <figcaption>Fig 05-120</figcaption>
            </figure>
            <p>If we look inside of our component itself:</p>
            <figure> <img src="images/Fig05-121.png" />
              <figcaption>Fig 05-121</figcaption>
            </figure>
            <p>We can see that it has a prop called message that it's going to print out. So let's go back to our HTML
              here, now let's type messages=John:</p>
            <figure> <img src="images/Fig05-122.png" />
              <figcaption>Fig 05-122</figcaption>
            </figure>
            <p>Let's go back to the browser and refresh, and now it says Hello John:</p>
            <figure> <img src="images/Fig05-123.png" />
              <figcaption>Fig 05-123</figcaption>
            </figure>
            <p>And we just built our first web component with Vue. </p>
          </div>
          <div>
            <h3>Using the Vue UI to Build</h3>
            <p>We've been using the terminal to build our applications, but we can also use the Vue UI from the Vue CLI.
              So let's stop the running application if you have one, and let's go back to our HelloWorld app. And we can
              reopen code. So here's our basic HelloWorld app we created earlier in the course:</p>
            <figure> <img src="images/Fig05-124.png" />
              <figcaption>Fig 05-124</figcaption>
            </figure>
            <p>Now, of course, we can build from here, but instead of building from here, let's just open up the Vue UI:
            </p>
            <figure> <img src="images/Fig05-125.png" />
              <figcaption>Fig 05-125</figcaption>
            </figure>
            <p>We don't have to be in the same folder as the project we want to build. It just opens up the Vue UI, and
              then if you hit the home button on the bottom left:</p>
            <figure> <img src="images/Fig05-126.png" />
              <figcaption>Fig 05-126</figcaption>
            </figure>
            <p>you'll see a list where you can look at your projects you've already looked at:</p>
            <figure> <img src="images/Fig05-127.png" />
              <figcaption>Fig 05-127</figcaption>
            </figure>
            <p>or you can create a new one, or you can import one from a folder. Let's use HelloWorld since we looked at
              that earlier:</p>
            <figure> <img src="images/Fig05-128.png" />
              <figcaption>Fig 05-128</figcaption>
            </figure>
            <p>Then we'll click on our clipboard over here:</p>
            <figure> <img src="images/Fig05-129.png" />
              <figcaption>Fig 05-129</figcaption>
            </figure>
            <p>those are our tasks. We can click on build:</p>
            <figure> <img src="images/Fig05-130.png" />
              <figcaption>Fig 05-130</figcaption>
            </figure>
            <p>and before we click on run, notice the parameters:</p>
            <figure> <img src="images/Fig05-131.png" />
              <figcaption>Fig 05-131</figcaption>
            </figure>
            <figure> <img src="images/Fig05-132.png" />
              <figcaption>Fig 05-132</figcaption>
            </figure>
            <p>By default it's production. We can also set our output, our build target for Web app, Library, Web
              component, or Asynchronous web component, and set other options down here. Let's run this build:</p>
            <figure> <img src="images/Fig05-133.png" />
              <figcaption>Fig 05-133</figcaption>
            </figure>
            <p>At the bottom you see a status that it's running. And then here, it's actually building and we saw the
              animations as it happened:</p>
            <figure> <img src="images/Fig05-134.png" />
              <figcaption>Fig 05-134</figcaption>
            </figure>
            <p>Now it gives us some speed stats for how long it would take to load over these different connections:</p>
            <figure> <img src="images/Fig05-135.png" />
              <figcaption>Fig 05-135</figcaption>
            </figure>
            <p>and then the file sizes are parsed:</p>
            <figure> <img src="images/Fig05-136.png" />
              <figcaption>Fig 05-136</figcaption>
            </figure>
            <p>then of course what the different speeds would be. What I find more interesting sometimes is the output:
            </p>
            <figure> <img src="images/Fig05-137.png" />
              <figcaption>Fig 05-137</figcaption>
            </figure>
            <p>because that shows you exactly which command ran. This is a great way to learn the CLI commands by
              watching the Vue UI run them. So here it said it ran build with mode production:</p>
            <figure> <img src="images/Fig05-138.png" />
              <figcaption>Fig 05-138</figcaption>
            </figure>
            <p>It put it in the dist folder, and it's targeting the application. If you need to clear this output, you
              just click the little trashcan over here:</p>
            <figure> <img src="images/Fig05-139.png" />
              <figcaption>Fig 05-139</figcaption>
            </figure>
            <p>Clear console. Dashboard is what we looked at, and then Analyzer:</p>
            <figure> <img src="images/Fig05-140.png" />
              <figcaption>Fig 05-140</figcaption>
            </figure>
            <p>is what's going to show us what's inside of the files. Here we can see the main. js, the assets, App.
              vue, and so on and so forth. And HelloWorld should be over here:</p>
            <figure> <img src="images/Fig05-141.png" />
              <figcaption>Fig 05-141</figcaption>
            </figure>
            <p>Now this is a very tiny app, but it shows you how we can use the Vue UI to run the same commands as a
              CLI. </p>
          </div>
          <div>
            <h3>Wrap up and What's Next?</h3>
            <p>In this module we learned how to build and serve our Vue applications using the Vue CLI and the Vue UI:
            </p>
            <figure> <img src="images/Fig05-142.png" />
              <figcaption>Fig 05-142</figcaption>
            </figure>
            <p>At the heart of this is the Vue CLI Service, which we can then run with the npx command to run the
              binaries or we can use npm scripts to do those with serve or build. Those npm scripts can be nice little
              shortcuts so we don't have to type out the long commands of the Vue CLI Service with our special options
              that we want to add in. And if we want to optimize our builds, we can use production mode to get them as
              small as possible, and of course we can build applications, which is the default target, or libraries or
              web components.</p>
            <p>And at the end of the day, you can use the Vue CLI commands directly from the terminal or you can go back
              to the Vue UI and run the commands interactively in a visual way so you can analyze your bundles. Now that
              we've learned how to build and serve our applications, let's move on to learning how we can test our
              applications with the Vue CLI. </p>
          </div>
        </div>
      </div>
    </div>
  </div>
  </div>
</body>

</html>