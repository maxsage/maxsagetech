<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

<head>
  <meta charset="UTF-8">
  <title>MVVM Light Toolkit Fundamentals</title>
  <script src="https://unpkg.com/vue"></script>
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
    integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
  </style>
</head>

<body>
  <div class="container" id="app">
    <div class="panel-group">
      <div class="panel panel-primary">
        <div class="panel-heading">
          <h2>MVVM Light Toolkit Fundamentals</h2>
        </div>
        <div class="panel-body">
          <div>
            <h2>Refactoring the App to MVVM</h2>
            <div>
<h3>Introduction</h3>
<p>In the previous module, we built a Windows Phone Application without using the Model-View-ViewModel Pattern. We saw some of the disadvantages of this tightly coupled approach using quite a lot of events and code behind. All those principles apply to all XAML-based frameworks, not just Windows Phone Apps. And similarly, what we will do in this module applies to all XAML-based frameworks as well. In this module, we will refactor the application to use a Model-View-ViewModel Pattern. This is going to solve the disadvantages that we saw in the previous module. First of all, we will start by making the model, the Friend object, observable, so that we can apply DataBindings directly to those properties. We are going to create a ViewModel for the main View, and we are going to create some View services that the ViewModel can call in an abstracting manner, in order to execute operations on the View, such as showing dialogs or doing some navigation. Then we will bind the ViewModel to the View in order to create a One-to-One relationship between those two items. We will add some design time data and that will give us the opportunity to use Blend to do some visual design. Finally, we will add a unit test to your application and we will see how we can mock the services in order to simulate test conditions.</p>
<h3>Refactor the Model Object</h3>
<p>Let's start the refactoring with a Friend class inside the Model folder. In order to make this class observable, we wanted to implement the INotifyPropertyChanged interface. This interface is probably the most important when it comes to data binding. It's going to allow the data bindings to be updated whenever a property changes on the Model object. To implement this interface, we need just one event, the PropertyChanged event. But in addition, we add a Utility method, RaisePropertyChanged, which is going to raise the PropertyChanged event if necessary, meaning if somebody subscribed to this event, for example a XAML DataBinding. Now we can modify the properties which are going to be observable. So let's remove here FirstName and LastName, and instead we are going to add some observable properties, the FirstName property, which is going to raise the PropertyChanged event if necessary. And we do the same for LastName. So now this Friend class is observable. From a XAML standpoint, we can data bind to those observable properties, and the data bindings are going to be updated whenever those properties change.</p>
<h3>MainViewModel Part 1: Properties</h3>
<p>Then we are going to add a new class, and this is going to be the ViewModel. So let's add, first, a New Folder. And inside this folder, I add a new class, which I name MainViewModel. Now just like there is a MainPage, we will have a MainViewModel. If we had a SettingsPage, we would have a SettingsViewModel, etc. There is normally a One-to-One correspondence between the pages and the ViewModel, but this rule has quite a lot of exceptions, like we will see in the rest of the course when we do some more advanced topics. This MainViewModel, just like before, is going to implement INotifyPropertyChanged, because we're also going to have some DataBindings to that. So let's add the same code as before. And here we see something which is quite frequent in MVVM Applications. There is quite a lot of repetition inside those applications. We have to implement INotifyPropertyChanged quite often, we have to declare observable properties quite often, and eventually it would be nice to have something which breaks the monotony of MVVM, like, for example, the MVVM Light Toolkit is doing. Let's add a collection to hold all the friends, and for this we are going to use an ObservableCollection of Friends. In this small example, I'm using the Friend, which is the data object, model object, directly inside the MainViewModel. And I made this Friends class observable, which is okay because it's going to make our life quite a lot easier. But it's very possible in more complex application that we want to wrap this Friend data object inside something else, called, for example, the FriendViewModel. Then I'm going to add the constructor for this class, and notice that I inject an IFriendsService, which is, if you remember, the abstraction of the FriendService inside the MainViewModel constructor. And I am going to save here, this _dataService, as a field of type IFriendsService. So from the standpoint of this constructor, we don't know how the FriendService is implemented, but we know that we can use it because the methods of this _dataService are known through the IFriendsService abstraction. Another property I want to add to the MainViewModel is a SelectedFriend. And here, just like before in the Friend model object, I'm going to raise the PropertyChanged event whenever the SelectedFriend changes, which is going to force all the DataBindings that are using this SelectedFriend to update themselves and to update the user interface.</p>
<h3>MainViewModel Part 2: Commands and Services</h3>
<p>At this point, I will need to actuate some methods on the ViewModel from the View. And for this we are going to use something called Commands. Now don't fret at this point; we are not going to explain how commands are working in details right now, but we are going to have a dedicated section a little bit later in this course. For the moment, it is enough to know that the command can be executed and that it can receive a parameter, which can be of any type. Now in order to use commands more easily, I'm going to add a small Helper class, (Typing) and this is something called RelayCommand. This is a class which is directly taken from MVVM Light. And I know I said I didn't want to use some Helper classes here, but this is the only exception that I'm doing because RelayCommand is going to make our life so much easier, even in this small application. So now that I have RelayCommand added to the application, I can add a RefreshCommand of type RelayCommand. And remember that this is going to be executed. So when the RefreshCommand is actuated, this lambda expression is going to be called, and the Refresh method, which is not declared yet, we are going to do that right now, this Refresh method is going to be executed. Let's add the implementation of the Refresh method, and here we go that essentially we do what we did before in the RefreshClick event. We are calling the Refresh method on the _dataService, which is await table, which is why the Refresh method is async, and then, with all those Friends, we are going to add them to the ObservableCollection that we had earlier inside the MainViewModel as a property. Another thing we need to do is save the modified Friend. So for this I'm going to use the SaveCommand, and this time the SaveCommand is taking a parameter of type Friend. And here we see the declaration. I'm going to have my RelayCommand, which is going to take, again, an asynchronous lambda as parameter for the Execute method, and then here I have the parameter, which is the friend. What the SaveCommand has to do is essentially the same thing as the SaveClick Event Handler was doing earlier inside the DetailsPage. So let's go and copy that block of code, and we can take here the whole SaveClick Event Handler content, I'm going to cut that out, and then I'm going to paste this inside the SaveCommand instead. Of course there are a few things that we need to change. Notably, we are not going to use the SelectedFriend, which is a static property inside the global application object. Instead what the service has to save is the friend which has passed this parameter. So we are more decoupled, we don't use a global object anymore. Let's replace that code here. Same thing here, with App. SelectedFriend, we are going to set the id on the friend that has passed this parameter. In order to add a little bit more abstraction, we are going to use the _dataService that was injected inside the constructor, instead of using the actual Runtime Friend service. This way, the MainViewModel doesn't have to know where the _dataService comes from; it is just going to use whatever implementation is passed to the MainViewModel constructor. Another thing, which is not very elegant, is using a MessageBox within a ViewModel. Those MessageBoxes are going to complicate the unit tests quite a lot, because a unit test cannot react to a MessageBox; it doesn't know how to verify that the MessageBox has been displayed or it doesn't know how to dismiss a MessageBox. So instead, we are going to remove those two lines of code and we are going to use an abstraction of a dialogService, which we are going to call the IDialogService. Let's go and add the corresponding interface inside the Helpers folder. And this interface is going to be very simple; it's going to have here a ShowMessage method taking a message of type string. The MainViewModel doesn't know how this interface is implemented, and in fact, it shouldn't have to know, there should be no dependency from the ViewModel to the View. But it knows that somewhere inside the application there is an object, which implements a method called ShowMessage. So we can use that abstraction inside the MainViewModel. We are going to inject the dialogService inside the ViewModel constructor, we are going to save this as a field, and then we are going to use that inside the application at this location, and again, inside the catch a little bit lower. Let's here name this exception, so that we can use the Message inside the _dialogService. Then last, but not least, we have another command, which is going to be used to do the navigation to the DetailsPage, and we are going to call that the ShowDetailsCommand. Let's add this command. This command is also taking a friend and we are going to set the SelectedFriend property, which we added earlier inside the ViewModel. Remember that the SelectedFriend property is an observable property, so the PropertyChanged event is going to be raised and all the bindings are going to be updated automatically. But in addition, we want to do some navigation to the DetailsPage. So again, the MainViewModel shouldn't know how the navigation is done, so that we have a clean abstraction. And again, we are going to use the same mechanism, we are going to go to the Helpers folder, add an interface called INavigationService, and the content of this interface is going to be quite simple. We are going to have a GoBack method and a NavigateTo method, which is taking a uri. Again, the MainViewModel doesn't know how INavigationService is implemented, and in fact it shouldn't have to know, so we are going to inject an INavigationService inside the ViewModel constructor, we are going to save the field of this type, and then, when the _showDetailsCommand is called, we are going to use this _navigationService abstraction to navigate to the DetailsPage. Of course those two interfaces need to be implemented, and here in this simple application we are going to keep things very simple. Let's add a new class, called DialogService. This is going to be public and implement IDialogService. And here for the ShowMessage method, we are going to simply use the MessageBox to show the corresponding message. So it's not very elegant, in a production application we would use a custom MessageBox here inside the Windows Phone application, but here to keep things simple, I'm simply going to use the MessageBox at this location. And for the NavigationService, let's do the same thing again; Helpers folder, Add New Class. (Typing) This implementation is going to be public. And for the implementation itself, what I'm going to do is get the PhoneApplicationFrame, which is the global frame where all the navigation is happening into a Windows Phone App. I'm going to call here _mainFrame. GoBack, _mainFrame. Navigate, and in order to get the frame, what we do is Application. Current. RootVisual, which can be casted to a PhoneApplicationFrame.</p>
<h3>Pairing the View and ViewModel, XAML</h3>
<p>So now at this point we have all the pieces of our puzzle, and we can compose the ViewModel with a View. To do that, I'm going to go into App. xaml, and I'm going to declare a new resource, which I'm going to call "Main", and this is of type, MainViewModel. I'm going to use this resource as the source of my DataBindings, but in order to create a resource like that in XAML, we need to have a default constructor. And for the moment, this is missing in the MainViewModel class. So let's go, again, inside MainViewModel, and I'm going to add the default constructor, which is going to take care of creating FriendService, DialogService, and NavigationService. What I'm doing here is not very usual in an MVVM application, but again this is a very simple sample. So what I'm doing here is saying, when the MainViewModel is created from XAML, I want to use, here, the FriendService, the DialogService, and the NavigationService. But later when we do unit tests, we are going to use this constructor directly, and we are going to provide some custom implementations of those services. Let's do a little bit more UI. We are going to go inside MainPage. xaml, and here I'm going to declare the DataContext of this page, which is set through a Binding to the Main StaticResource that I created earlier in App. xaml. So from now on, everything which happens inside this page will be in reference to the DataContext implicitly, except of course if you specified otherwise in an explicit manner. This allows me to go down to the LongListSelector. I'm going to remove the Name of that List, because we are not going to use that anymore, and instead I'm going to add here ItemsSource= in a decoupled manner from the markup, through a binding, to the Friends ObservableCollection that we declared earlier on the MainViewModel. Next thing I can do is take care of the RefreshClick inside MainPage. xaml. cs. Now here, because I am inside a Windows Phone Application, I'm not going to call the command directly from the XAML, because this is not possible inside an ApplicationBar. Instead I'm going to continue using RefreshClick, and here what I will do is get the DataContext of the page, which is a MainViewModel, and then I'm going to call the RefreshCommand directly on that MainViewModel. Later, when we do some Windows 8, we will see that we can use commands directly from the XAML of the ApplicationBar without having to go through the code behind. For the DetailsPage, we will do something very similar. Let's go and open DetailsPage. xaml, and I'm going to point the DataContext to the exact same StaticResource called "Main". Of course I need to change how those TextBoxes are assigned, and the first thing I can do is remove those TextChanged Event Handlers, we are not going to use that anymore. And why don't we do the DataBinding in Expression Blend? Like this, we can see how Expression Blend works together with MVVM. I'm going to build the application in order to have all the objects ready. Let's open DetailsPage. xaml, select here the FirstNameTextBox, and here for the TextProperty I'm going to create a DataBinding. And here notice that Blend knows that the data context of this page is MainViewModel, and so I can take the SelectedFriend. FirstName and do a TwoWay DataBinding on this property; TwoWay meaning that when the user is typing something in the textbox and then the textbox loses a focus, the DataBinding is going to be updated automatically and the property is going to be set on the Friend object. Let's do the same thing here for my LastName, SelectedFriend. LastName. So we selected very convenient because we don't have to know in advance how the object is built. We can visually go and select the right property. Of course we don't have design time data yet. We are going to worry about that in just a moment. Let's save everything, go back to Visual Studio. Studio tells me something changed, which is okay. And here we see the XAML, which has been created, and notably this TextProperty is set now through a TwoWay binding to SelectedFriend. LastName, and respectively to SelectedFriend. FirstName. For the Preview, we are going to do the same thing, so I'm going to copy here this Binding, I'm going to remove the Name because we don't need that anymore, and then I'm going to paste here the FirstName Binding, but I'm going to make that OneWay because this is a TextBlock. Same thing for the LastName DataBinding. Let's remove this Name, and use the LastName DataBinding instead. So you see that with Bindings, this is a very decoupled mechanism, and I can modify my UI without having to worry about code. I can do that either in Expression Blend or directly in XAML. Inside the code behind of the DetailsPage, we can remove quite a lot of things. Let's get rid of OnNavigatedTo of the TextChanged Event Handlers, we don't need that anymore. And when we Save, what we are going to do is pretty much the same thing as before. I'm going to get the DataContext, cast it to MainViewModel, and Execute the SaveCommand, using for that, the SelectedFriend as a parameter. Before we do that, we are going to have a method called UpdateBinding, and this method is just to take care of a small issue in Windows Phone, which is that when you click on an ApplicationBar button when a TextBox has a focus, the Binding is not automatically updated. The ApplicationBar in Windows Phone is a component which is a little bit annoying and you have to take care of a few things manually. So here we are going to use this code, let's just say that it is going to update the binding and make sure that the ViewModel is up-to-date whenever I click on the Save button.</p>
<h3>Adding ShowDetailsCommand and Testing the App</h3>
<p>Last, but not least, we need to take care of the navigation to a Friend's detail. For the moment, we use this Tap Event Handler to do the navigation, but if we want to clean the XAML and copy this DataTemplate to a ResourceDictionary in order to keep the XAML a little bit cleaner and more organized, so let's do that. I'm going to cut the DataTemplate from the MainPage. xaml. And then I'm going to move it to Styles, Styles. xaml. This is a global ResourceDictionary, which means that everything I add to this ResourceDictionary here will be available throughout the application automatically through a StaticResource. Because this is a global ResourceDictionary, the FriendTemplate will be found by the XAML parser and the StaticResource will be working just fine, but we will have a problem here with the Tap Event Handler. The XAML parser is not going to be able to find this FriendTap Event Handler. And in fact, if we try to run the application now, we will see that when we try to use this DataTemplate, we will get a crash and the application exits. What we need to do now is to remove the tight coupling between this StackPanel and the code behind in MainPage. xaml. cs. So I'm going to remove, here, the FriendTap Event Handler. I can also go into MainPage. xaml and I'm going to remove the FriendTap here. And instead, we are going to use a loose way of executing a command using a behavior. We have talked about behavior in the first module in the theory part. Behaviors can be used in XAML directly without using Blend, but they are a little bit easier to apply if we use Expression Blend. So let's do that and we will talk a lot more about behaviors a little bit later. Jumping into Expression Blend, I'm going to select here the LongListSelector, and I'm going to go into ‘Edit Additional Templates', ‘Edit ItemTemplate', ‘Edit Current'. Now notice that I'm jumping into the Styles. xaml ResourceDictionary, which is normal, because this is where I copied the DataTemplate earlier. Now I want to add a Behavior to this StackPanel. And to do this, I'm going to go into the Assets library, in the Behaviors category, and I'm going to select a built-in behavior called InvokeCommandAction. Let's Drag & Drop this on the StackPanel. In the Properties I want to make sure that I have selected an EventTrigger, and I'm going to select the Tap Event. And now we'll see what's going to happen. Every time that the user taps on the StackPanel, I want to invoke a command, so let's create a DataBinding. And I'm going to invoke the command, not on the Friend, which is a current data context, but instead I'm going to select here the StaticResource, Main, which is a MainViewModel, and I'm going to take the ShowDetailsCommand. Now remember that ShowDetailsCommand is using a Friend as parameter, so I'm going to have to add the CommandParameter to this Command call, and I'm going to select, again, ‘Create Data Binding'. Remember that the Friend is the current data context, and this is, in fact, exactly what I want to use. So I'm going to select here a Custom Data Binding and leave the Path empty. What it means is that the CommandParameter will be set through the Binding to the current data context of the StackPanel, which is a current Friend. This is exactly what we want to pass to the ShowDetailsCommand. Let's click OK, and now we are ready to test the application. Testing the application can be done in Visual Studio or directly in Blend. I'm going to run the application in the Emulator. If I press the Refresh button, the command will be actuated, and we get the list of friends. If I select a friend, the ShowDetailsCommand will be called on Tap, and I see that I can go and edit the details of the friend and call the SaveCommand to save the modified friend. If I go back into the MainPage and Refresh, we see that the change has been saved correctly to the server. After refactoring, we have an application which has the same functionality, but it has a cleaner architecture and it's going to be easier to test, to design, and to maintain later.</p>
<h3>Adding Design Time Data and Designing in Blend</h3>
<p>After refactoring the application, we now have a Model-View-ViewModel architecture, which we are going to leverage. The first thing we want to do is add some design time data to the application to facilitate the work in the Visual Designer. When we open the application in Expression Blend, we notice that the list controls are empty. We have some static UI elements on the screen, but everything which is dynamic is not loaded. However, Expression Blend is not only displaying a static user interface, but it is also executing some parts of the code. So we are going to use this fact and force Expression Blend to generate some design time data. In Visual Studio, let's make things a little bit more interesting by adding a new property to the Friend Model class. We are going to use the PictureUri to show the Friend's picture in the application. Then we are going to create a design time implementation of the IFriendsService interface. Remember that the FriendService is implementing this interface, and we are going to use this abstraction to create a version of the class, which is used only at design time. To do this, we are going to create a new folder. Let's call that Design, and then inside this folder I'm going to Add the New Class, and I call this the DesignFriendsService. We want this class to be public and to implement IFriendsService. (Typing) Let's implement the interface. The Save method is not going to be used at design time, but we want to take care of the Refresh method. And what we are going to do here is create some simulation of the Friends; we are going to create 10 items with a simulated FirstName, LastName, and a Picture coming from the web. Now we need to tell the MainViewModel which version of the IFriendsService it needs to use. Let's go into the MainViewModel class, let's select the constructor, and remember that the default constructor is used when the MainViewModel is instantiated from XAML, and here we are using the default FriendsService. But instead, because the constructor expects an IFriendsService, we can actually change this definition here, and instead we are going to use an expression, saying that if we are in DesignTool, we are going to use DesignFriendsService; and otherwise, if we are at Runtime, we are going to use a standard FriendsService implementation. The last thing we need to do is, for the MainViewModel to execute the Refresh method, of course, at design time the Refresh method will be executed on the DesignFriendsService. And finally, when the 10 design time Friends have been created, we select the first one and assign it to the SelectedFriend. We are going to use that later in the design of the DetailsPage. Let's build the application now. And if we change into Expression Blend, we notice that some design time data is up here in the LongListSelector, which will make the design time work much easier. For example, let's edit the DataTemplate of this LongListSelector. Here we are inside the Styles. xaml ResourceDictionary. I'm going to take this StackPanel, group it into a grid. I'm going to add the column to this grid and set the width of this column to 100 pixels. Then I'm going to take the StackPanel here and I'm going to move it to the second column, and in the first column I'm going to take an Image control. And since I have some design time data available, I can create a DataBinding here to the PictureUri of the Friend. And now we see that we have an Image, which is loaded from the web by Expression Blend, which allows me to do some Visual Design here; for example, let's set the Height of the Image to 100 px. And now we can do a few things visually; for example, let's change the orientation of the StackPanel to Vertical, we can select here the LastName and increase the Font Size to 36 password. And then we probably want to change here the margins to make things a little bit more compact and maybe just add a little bit margin on the FirstName here. So you see that you have the possibility to create your design visually in Blend, which of course, gives us a lot of creative freedom. If I change into the MainPage, I see the result of my work. And for example, here it is easy to see that I need a little bit more margins, so let's add some margins to the left, to the right, and finally a bit margin at the bottom as well. And here we go; we have something which is nicer. Now I can run the application directly from Expression Blend, Let's Refresh the page. And here we see the actual Runtime data showing, including the new designs that we just created. Obviously the application needs a lot more design love at this point, but the point is that you can do this design visually in Expression Blend or in the Visual Studio Designer, and this is going to make your life as a designer much easier.</p>
<h3>Unit Testing the Application</h3>
<p>In the next section, we are going to see how we can unit test our application and how we can implement some test version of our services in order to create some well-known conditions for the unit test. I will create the unit test project in Visual Studio and use the MSTest framework. You probably have your own favorite unit test framework, it's absolutely up to you, and in fact all the principles that I'm showing now apply to any unit test framework in an MVVM application. So I'm going to Add a New Project, and under Windows Phone, I'm going to select a Windows Phone Unit Test Application. I'm going to name that WhyMvvm. Test. And then I'm going to remove here the generated method. Let's add our own test method, and understand what it is doing. This test method is going to create a new MainViewModel, so obviously the test application needs a reference to the WhyMvvm Project. Now we can use the MainViewModel class and the Friend class, and we notice that we are using the constructor, which is taking some services as parameter. If you remember, there are two constructors in the MainViewModel, the default constructor, which is used directly from the XAML, and this default constructor is going to use the runtime implementation of the services. There is, however, a second constructor, which we call directly here, and we are going to create some test implementations of the services. We have a TestDialogService, a TestFriendsService, and a TestNavigationService. Let's implement those services. First, the TestFriendsService is going to implement the IFriendsService interface. (Typing) But instead of calling a web service, it's going to have a well-known implementation. And this implementation, when the Save method is called, is going to throw an Exception using an ErrorMessage, which is defined here as a constant. Then, we have a TestDialogService, and here too, we are going to create an implementation for IDialogService, and we are going to use a well-known implementation, which instead of showing an actual MessageBox, is simply going to Save the message that must be shown into a property. Finally, the last service is a TestNavigationService. And this one is going to be even simpler. (Typing) It is simply going to declare the method, but it's not going to do anything to avoid some navigation during the unit test. So now in our test method, we are using those well-known implementation of services. We are going to start the test by asserting that the MessageShown property is null. Then we are going to execute the SaveCommand on the MainViewModel, but we know that this SaveCommand is going to call the Save method of our well-known TestFriendsService. This is going to throw an exception and we want to verify that the corresponding ErrorMessage is passed to the DialogService, which is what we do here in this Assert. Now we can run the test and see if everything works fine. So let's go to Test, Run, All Tests. The project is building, so tests are starting, and here we see that the test is green, which is a good sign for the rest of our development process.</p>
<h3>Summary</h3>
<p>In this section, we have taken our non-MVVM application and we have refactored it to a Model-View-ViewModel architecture. We started by making the Model observable. We implemented the INotifyPropertyChanged interface and raised the PropertyChanged event. We created a MainViewModel to drag the Views. We moved some of the View functionality in some abstracted View services and we injected those View services inside the ViewModel. Then we bound the View to the ViewModel in XAML. Then we saw how to add design time data in order to make the work in Blend or in the Visual Studio Designer much easier. Finally, we added a unit test project to the application and we showed how we can mock services in order to create some well-known test conditions. In the next module, we are going to get familiar with some of the components of the MVVM Light Toolkit, and we will see how those components can simplify the creation of Model-View-ViewModel applications.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>

</html>