<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

<head>
  <meta charset="UTF-8">
  <title>MVVM Light Toolkit Fundamentals</title>
  <script src="https://unpkg.com/vue"></script>
  <link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
    integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" rel="stylesheet">
  <link href="prism.css" rel="stylesheet">
  <script src="prism.js"></script>
  <style>
    img {
      max-width: 100%;
    }
  </style>
</head>

<body>
  <div class="container" id="app">
    <div class="panel-group">
      <div class="panel panel-primary">
        <div class="panel-heading">
          <h2>MVVM Light Toolkit Fundamentals</h2>
        </div>
        <div class="panel-body">
          <div>
            <h2>Advanced Examples With MVVM Light</h2>
            <div>
<h3>Introduction; Plug-Ins: Introducing the Interfaces</h3>
<p>The last module of this MVVM Light reference course will show a lot of samples. It will be code, code, code, and almost no slides. The goal here is to show some specific usage of the MVVM Light components, which are not totally usual, while in the rest of the course we showed samples that are rather common when using the Model-View-ViewModel Pattern in the MVVM Light Toolkit. First, we will show a large sample about building a plugin-based application. Building a plugin framework and adding functionality to an application in the form of plugins is a very popular approach, especially in Windows Presentation Foundation. This is quite typical for larger kinds of applications. It can be very convenient when working with multiple teams, where the need to define a common interface is crucial. In this sample, we will see how to build a plugin definition interface, then a Bootstrapper to load plugins from a folder, and how we can access the MVVM functionalities through Data Binding, Commands, the SimpleIoc, the Messenger, and more. We will also build two different plugins. Then we will see a practical usage of the MVVM Light Messenger, in order to build an expandable list for a Windows Phone Application. This is a very frequent UX Pattern in Windows Phone Apps, where elements in a list can be selected by tapping on the far-left of the item. This expands the list to reveal checkboxes. However, when the list is representing ItemViewModels, the interaction can be a little bit tricky to figure out without using a component, such as a Messenger. In the sample here, we will see how to build such an experience from scratch. Finally, we will talk about unit testing. One of the big selling points of the Model-View-ViewModel Pattern is that it can dramatically increase the testability of your applications. However, it is still relatively rare to see consistent unit testing of apps. With the samples shown here, we will show some techniques and tips to unit test a ViewModelLayer in MVVM Light Applications, and hopefully to promote the creation of unit tests for those apps. The first sample we will see is about â€˜Using MVVM Light in a Plug-in based Application'. MVVM Light's components are very useful to build decoupled applications. So far in this course, we saw how applications can be divided in layers that are loosely coupled. Of course, there are other kinds of decoupled applications. One very interesting example is a Plug-in based application. This is quite frequent in WPF to build extensible applications, where plug-ins are built after the MainApplication, the plug-in host is complete. Or, when the project is split in multiple teams and these teams want to work in an independent manner, with a minimal level of interaction in order to reuse the friction. Plug-ins are very decoupled, and in this case, too, MVVM Light can help you. In this sample, we will see how the RelayCommand, the Messenger, and the SimpleIoc components can help in a plug-in scenario. Here, we see the code for the MainApplication, which is also called the Host. Typically, a plug-in based application is separated in three types of components. The first one is where the definition of the plugin is hosted. For example, here, this is an interface called IPlugIn. It has one property and one method. The property is just for information, and returns a name of the plugin. Of course, this probably should be a unique name. The GetElement method returns a FrameworkElement, which can be anything that will be placed into the PlugInHost. In addition to these members, a PlugIn interface could host other information; for example, the desired position for the plugin inside the host, etc. The next interface is called IPlugInHost. It defines what the host needs to do in order to receive a new plugin. In our case, the host will be the WPF Application's MainWindow, but we could have other scenarios or multiple hosts, etc. Here we have two methods, clearing all the plugins, for example before we reload, and placing the PlugIn into the host. This method gets an instance of the IPlugIn interface that we saw just before and the second parameter is a plugIn's dataContext. In true Model-View-ViewModel form, the dataContext will host functionality and information that the plugin will use. Note that these interfaces are hosted in a separate assembly. This assembly must be implemented early, and must be quite stable during the lifetime of the project. Any change to this assembly will have an impact on every plugin and on the MainApplication, so this should be modified as seldom as possible.</p>
<h3>Plug-Ins: Preparing the View</h3>
<p>In the MainApplication, the Host, we have a reference to the Contracts assembly. Then, we have an important class, the Bootstrapper. This class will be responsible for inspecting and loading plugins, so let's check it out. First, the Path of the PlugInFolder is read from the Settings. This allows the path to change, even after the application is compiled, which is convenient. Then, we go further down, and we will use this foreach loop to load each DLL inside the folder. We will load all the assembly's types and check if one or more of these types are implementing the IPlugIn interface from the Contracts assembly. If that is the case, we use some Reflection to get the default constructor of the IPlugIn implementation and we invoke it to create a new instance of the plugin. Then, this instance is kept in the list. After the plugins have been loaded, the Host can call the GetElement method. Remember that the IPlugIn's GetElement method is returning a FrameworkElement, which can be placed into the user interface. Here, too, we are going to use some Reflection to invoke the PlugIn's GetElement method and to return the result casted to a Framework Element. Now let's discover more about the MainApplication's UI. First, we can open the ViewModelLocator. It is a pretty standard MVVM Light object, as we saw before many times in the course. Here, we register the Bootstrapper into the SimpleIoc in order to make it easily available to the application's objects that need it. Now let's see the object that will host the plugins. In this application, we use a MainWindow for that. Here is how it looks like in Blend. The orange and green borders will be where the plugins are placed. The button below will reload the plugins for the PlugInFolder. In the code behind, we see that the MainWindow implements the IPlugInHost interface. We already saw these kinds of things before; for example, when we implemented the IDialogService interface in order to show messages to the user. Here, the MainWindow registers itself in the IOC container when it is loaded. To keep things clean, the MainWindow also unregisters itself in the closing event handler. The Clear method is required by the IPlugInHost interface. We will first send a message to whomever is concerned, warning that it is time for cleanup. Typically, all the plugins are going to be interested in this message. Here, we use a standard NotificationMessage, which is an MVVM Light element. Then, we clear the UI by setting the orange and green borders' Child property to null. The PlacePlugIn method is also required by the IPlugInHost interface. It uses the IOC container to get the Bootstrapper. Then, it gets a FrameworkElement that is defined in the plugIn assembly using the Bootstrapper's GetElement method that we just saw. It sets the element's DataContext as required here. Then, it uses an algorithm to find out where to place a plugin into the UI. Here, this algorithm is very basic, but it could be much more complex; for example, the plugin might require to be placed in a specific location, for example a sidebar, a footer, a header, etc. Now let's open the MainViewModel. This will be the ViewModel for the application's MainWindow. It has an ObservableCollection of the IPlugIns. We will use this collection to show the PlugIn names into the window. Then we have the RelayCommand, which is going to be used to reload all the plugins from the PlugInFolder. To do this, we will get the PlugInHost from the IOC container and, of course, the MainViewModel doesn't know that this IPlugInHost is actually the MainWindow. Again, this is similar to what we did before with the IDialogService. The MainViewModel instructs the PlugInHost to Clear the PlugIns. Then it calls a Refresh method on the Bootstrapper and saves the PlugIns in the ObservableCollection. And finally, it instructs the PlugInHost to place the PlugIn elements in the user interface. Note that in this simple demo, the PlugIn's ViewModel is a MainViewModel itself. In a production application, we would have multiple ViewModels with various functionality. Later we will see that the PlugIn itself can also specify a separate ViewModel, etc.</p>
<h3>Plug-Ins: Databinding and Commanding</h3>
<p>Now that we saw how the PlugIn infrastructure works, let's add some functionality and see how the PlugIns can get access to that. First, I will add a Counter property in the MainViewModel. Let's use the MVVM Light's inpc snippet to do that; for example, inpcsetlambda, that we saw just before. I'm going to type the name of the property, Counter, and let's make that a string and the name of the field is also going to be _counter. And then I'm going to type the initial value, which I set to Initializing. So this is a simple string property, which raises a PropertyChanged event when it changes. Then I'm going to add a Command. This Command will be used to increment the Counter. I will use the mvvmrelay snippet that we saw before, so here we go, Tab. And then I'm going to call that _incrementCommand, and the name of the property itself, IncrementCommand, too. The implementation is going to be very simple; I'm simply going to take this value here and increment it, and then format the string. So far, this is just standard MVVM code. However, because the MainViewModel will be set as the PlugIn's DataContext when it is loaded, it means that the PlugIn has access to the Counter property and even to the IncrementCommand through Databinding. Here, in the MainWindow, I added a button to increment the Counter. So let's use a Binding Editor to bind the button's Command to the IncrementCommand that we just added before. Now it is time to work on the PlugIn itself. I have the project defined in another instance of Visual Studio. This is to show that we can work on the PlugIns in a totally separate manner. In the References folder, we will see a reference to the Contracts assembly that was precompiled before. We also added the MvvmLight assemblies. Here is the implementation of the IPlugIn interface. This is a PlugInManager, which is going to handle loading the PlugIn UserControl. The name is defined here, we simple return a string, and then we have the GetElement method. This creates a new instance of the PlugInControl, again in a very simple manner. In the UserControl. xaml, we see that the DataContext is not explicitly set. This will be the task of the Bootstrapper in the MainApplication. Remember that the MainViewModel will be used as a PlugIn's ViewModel as well, so in the real-life application, we would probably use another class. Here, we rely on some knowledge of the ViewModel, notably that there is a Counter property, which is used here in the Databinding. If we open this UserControl in Blend, we see that there is no design time data; however, this can be easily changed. Remember that we saw in earlier modules how we can use a design-time DataContext attribute to create design time data. In the real-life project, the design time data can be created by the team who is in charge of the MainViewModel and sent to all the PlugIn developers. This is also a contract between the MainApplication and the PlugIns, just like the IPlugIn interface. Let's add the design-time ViewModel class here, and of course we can do that either in Visual Studio or in Blend. And here, the DesignMainViewModel was sent to the PlugIn Team by the MainApplication's Team, so let's just add it. If we take a look at the code, we see the two properties that we decided to expose to the PlugIns. There is a Counter property, which in the real-life MainViewModel is an observable property, but here it just returns a string purely for design time purpose. There is also the IncrementCommand, which is defined here as an ICommand. Note that in this case, the Command is never even created, it doesn't matter because it is purely for design time purpose. So now we can instruct Blend to use this object at design time. First, let's build the application. And then I'm going to change into Expression Blend and go here to the Data panel. I'm going to set the design-time DataContext, and here I can select DesignInstance. This is going to show me all the objects in the application and, for example, I can look for DesignMainViewModel, which is here. We will also set the IsDesignTimeCreatable property to true, as we saw in earlier modules. Let's click OK, and immediately we saw that design time data appears on the screen, and if needed, we can easily make changes in Blend, for example, change the FontSize, change the Foreground, etc. In XAML, here is how the design-time DataContext looks like. Again, this is just like we demonstrated in earlier modules as one of the ways to set design time data in Blend. Then we are going to take advantage of the IncrementCommand. So I'm going to take a Button, add it here, and let's do just a little bit of design, Reset the Layout, and maybe add a little bit of margin. Now I'm going to bind the Button's Command property to the IncrementCommand itself. And again, I'm going to use a Binding Editor. And here, too, because we have design time data, we can simple select IncrementCommand and click OK. Now we are going to use this PlugIn in the application. So first I'm going to build the PlugIn assembly, and then I'm going to go into the Debug folder. Let's copy this DLL, and I'm going to place it in the PlugIns folder, which is located here. Now remember that the location of this PlugIns folder is set in the application Settings. So I can change the location of the folder at any time and then simply restart the application without recompiling. Now I can run the application, and let's reload the plug-ins. And here we go, we see that one plug-in was found in the Plug-ins folder and was successfully loaded. Now I can increment the Counter directly from the application, and here we see that the plug-in, through the Databinding, reacts to the PropertyChanged event. And finally, we can also invoke the Command directly from the Plug-in and we see that the Counter is also incremented.</p>
<h3>Plug-Ins: Sending a Message to the Plug-Ins</h3>
<p>The PlugIns can also define their own ViewModels. For example, here I added a PartialViewModel inside the PlugIn1. When the PartialViewModel is constructed, I'm going to register to the MVVM Light's Messenger. Remember earlier, we saw that when the PlugIns are unloaded by the PlugInHost, a NotificationMessage is sent through the Messenger. So here in the PlugIn's PartialViewModel, we can listen to that message. Then I can add the method that is going to handle the NotificationMessage. And here, if this is a CleanupNotification, we are going to Unregister this PlugIn from the Messenger in order to avoid memory leaks. Of course, in a real-life scenario, it is very useful for the PlugIn to be notified so, for example, files can be closed or database connections, maybe some logs can be recorded, etc. The Messenger can obviously be used for other purposes as well, such as sending a value to the PlugIns. The advantage of the Messenger is quite obvious here, since the sender does not have to know how many PlugIns, if any, are loaded. The Messenger can also be used to send values and objects; for example, a SelectedUser, etc. Let's add this feature to the MainViewModel and to the MainWindow, and then we will communicate this information to the interested PlugIns. Now I am back into the MainApplication's Window, into the Host, and we will use a Messenger in order to send an object to all the PlugIns. We will call that object, the User. So let's add this object into the Contracts assembly. Of course, this is important to add it to the contract, because everybody in the application must know about this user. Let's open the User class, and we see that it is quite simple; it just has two Observable properties, the FirstName and the LastName. Then I will use this object into the MainViewModel inside the MainApplication. First, I'm going to add an Observable property called CurrentUser and, of course, here, we could use the mvvminpc snippet that we saw before. Then a little bit further down, I'm going to add a Command, which is going to be used to send the CurrentUser to all the interested PlugIns. So let's check the code. What I'm going to do is send a new NotificationMessage<User>, so this is a special message type, which carries a notification and also a payload, in this case the CurrentUser. For example, this could be a notification when a new user looks into the application, etc. Now let's prepare the PlugIn to receive the message. First, I add a property, which will display the UserFullName, according to a specific format. Then, inside the constructor, I will add another registration to the MVVM Light Messenger. We will check if the Notification is a NewUserNotification, and if that is the case, we will use a message. Content to create the UserFullName according to a specific format. Now that the PartialViewModel is ready, let's use it in the XAML. I will add a snippet of XAML here, this is a Grid containing a few elements. There is a TextBlock here, which is data bound to the UserFullName property that we added to the PartialViewModel. So now we need to set the DataContext of this Grid to the PartialViewModel, which we can do in code behind. In the PlugInControl1. xaml. cs, I will use this line of code in the constructor to set the PartialPanel's DataContext to a new PartialViewModel. Of course, because the DataContext is set in the code behind, it means that we need a design-time DataContext for the Visual Designer, in case we need it for design time data. This is easy to set up. So here in the PartialViewModel, inside the constructor, I'm going to add some design time code, which is going to detect the DesignMode, and in case the DesignMode is active, we are going to set the UserFullName to a known value. Now I can build the application at this point. And if we take a quick look in Blend, we can see that the design time data is working, and now we could use a Visual Designer to polish the design of this PlugIn. Now I can test the feature in the MainApplication. I have copied the updated version of PlugIn1 into the Plugins folder, so now I can reload the plug-ins, here we go, and we see that the user has not been set yet. I also added this UI to the MainWindow, which is going to allow me to send a message to the plugins using the Messenger, just like we saw before. Here I can go in and enter any name, for example Albert Einstein. And then I can send this name to the plugins, and here we see that the first plugin has actually received the name.</p>
<h3>Plug-Ins: Using a Dataservice Inside the Plug-In</h3>
<p>Now I would like to show how the PlugIns can get access to services, which are defined inside the Main assembly, or any other assembly for this matter. So first I'm going to add some objects to the Contracts assembly. Everything we want to share with the PlugIns must be added inside the Contracts assembly, which is referenced everywhere. And here I'm going to add an IDataService interface and the TestObject. Let's take a look at IDataService. This is a very simple interface, which has just one method, and this method is going to be used asynchronously to retrieve a TestObject. The TestObject itself has two properties. We already saw something like that in the previous module, when we were demonstrating NuGet and the Json. NET assemblies. Now we are going to implement the DataService inside the Main assembly, so let's add a New Class. I'm going to name that DataService. Let's make it public. And I'm going to implement IDataService, which is defined inside the Contracts assembly. And now I can add the implementation of the GetTestObject method, which is going to retrieve the json file from the web server and use Json. NET to deserialize this into a TestObject. Now I can register the DataService inside the ViewModelLocator, like we did multiple times during this course. And I'm going to do this, here, inside the constructor. And, of course, just like before, I could also go ahead and define a DesignDataService used at design time, but here for the purpose of the demo, I'm not going to do that. Now let's go back to the PlugIn assembly. Here, I'm going to start by adding a property to retrieve the DataService from the IOC container. This is the same DataService that we just registered into the MainApplication's ViewModelLocator. Of course, because we are using the IDataService abstraction, it could be any implementation; we don't need to know about it. Now I can go ahead and add a RelayCommand here, so I'm going to use mvvmr, like before, and I will call this, _callServiceCommand, here we go. And here, too, CallServiceCommand. Let's implement this command now, so I'm going to drag the code here. And what we will do here is call the DataService in order to get the TestObject. Of course, this is an asynchronous method so we need to await that, and because this is awaited, I need to set this lambda expression to async. Once a TestObject is retrieved, we are simply going to show a MessageBox for the demo, but of course in a production application, we would actually use those values. In the user interface, I added a Button, which is data bound to the Command that we just added. Now we are ready to test again. What I did before is that I built the plugin and then I made sure to copy the latest version from the Bin, Debug folder inside the Plugins folder so that the application can find the latest version. Now I'm going to reload the plug-in. Here we see the new UI that we just created, and if I go ahead and call the DataService, this will call the GetObject method and trigger the MessageBox to be shown. So even though the DataService was implemented in the Main assembly, our plugin was able to use it thanks to the IDataService interface, and of course through the IOC container.</p>
<h3>Plug-Ins: Building a Second Plug-In</h3>
<p>In this whole demo so far, we have used only one PlugIn, but of course it is very easy to build a second one. So here is a new class library, in which I added a new user control. In the References folder, I added a reference to the Contracts assembly, like just before. And here, I also implemented the PlugInManager with a Name and, of course, a GetElement method. And I also added the DesignMainViewModel, just like before. So let's go in Blend and do a little bit of design. First of all, I'm going to set the design-time DataContext, just like before, let's select here DesignInstance. I'm going to look for DesignMainViewModel, and set IsDesignTimeCreatable to true. Then I'm going to take this Grid, and let's make it another color, for example green. I'm going to take a TextBlock and then I'm going to put it in the middle. And, of course, we can do a little bit of design here. First of all, let's do that quite a lot bigger and maybe white is nicer. Then I'm going to do some Databinding, so let's take here, the Data Binding Editor, and I'm going to bind this to the Counter property on the MainViewModel. Finally, we can be a little bit creative; this is the beauty of Blend. Let's create, here, a new Storyboard, and what I'm going to say is that after 1 second, I want this element here to be rotated by 360 degrees. I'm going to select to stop here and choose an Easing function; for example, Cubic. We can go ahead and test that directly to Blend. Ok. And then finally, what I'm going to do is, select here the Storyboard, and set AutoReverse to true, and set the RepeatBehavior to Forever, which means that the animation will go and then come back. And this will continue forever during the lifetime of the application. So now we have our PlugIn ready. I can build it, and now I'm going to copy the DLL into the Plugins folder. So let's go here into the Explorer, bin, Debug. I'm going to take here just the PlugIn2 DLL, let's copy that. And then I'm going to go into the Plugins folder, where I already have the PlugIn1, Paste this. And now if we run the application without any modification to the Host, we can reload the plugin and we see that now we have two plugins, and the functionality is still there. For example, if I increment the Counter, we see that all the values change, just like it was expected. This complex demo shows the power of the Model-View-ViewModel Pattern and, of course, of the MVVM Light Toolkit in the context of a very, very decoupled application using Plug-ins. Now to be clear, not all applications need Plug-ins and, in fact, in the context of WPF, this is probably best for relatively large applications, but even for smaller apps, Plug-ins can be useful; for example, think about a Windows Phone Application where you can have in-application purchase of new functionality implemented as Plug-ins. Because of the high level of abstraction between the application's components, MVVM Light's elements are very well suited to help you build the functionalities that you need in a much easier manner.</p>
<h3>Expandable List: Preparing the Infrastructure</h3>
<p>In this second sample, we will see an application of the Messenger component of MVVM Light. This is especially useful when you don't know in advance how many recipients will subscribe to a message, from 0 to a large number. This can also be useful in the user interface layer, as we will see here. In Windows Phone, there is a well-known user experience pattern, where List elements can be expanded by tapping on the left-most side of the screen. They will slide to reveal a checkbox, which can be used to select the items on which certain operations must be performed; for example, we see that behavior in the Email Application in the Emulator. Here, we see the messages. In order to select them, for example, for deletion, we can tap on the side of the screen here. Notice that the item that we tapped is immediately selected. Also, we see that the sliding is done with an animation. We can select multiple items like that. And now if I deselect them, we notice that when we deselect the last item, the list will collapse back into place. In our application, we want to use MVVM, and so the List is actually representing an ItemViewModel. So ViewModel will expose an IsSelected Boolean property, as well as an IsExpanded property, which is also a Boolean. In order to manage these properties and all the interaction, we can create a BaseViewModel that these items will _____; we will name that the SelectableViewModel. Let's check the SelectableViewModel's code. First we see the two properties that I just mentioned, IsExpanded and IsSelected. IsExpanded is a standard observable property, which works because a SelectableViewModel inherits the MVVM Light ViewModelBase. The IsSelected property is a little bit more complex; we'll come to that in a moment. Let's scroll down for now. Here, we expose a Command, which is called ExpandCommand. This is what will be actuated by the small button on the far left of the screen. What happened when this command is actuated is this; first, the IsExpanded property is set to true, then the IsSelected value is also set to true, because when the button is tapped, we want the corresponding item to be selected, just like we saw in the Email Application. Then comes the important part, we use a Messenger to send an ExpandMessage. This is because the other items in the list must also expand when one item gets expanded. The ExpandMessage is here, and we see that it is a simple GenericMessage<bool>. It means that it is sent carrying a simple Boolean value as payload. Because it has a specific type, however, there can be no confusion as of the intent of the message. Back to SelectableViewModel, the next interesting method is a constructor. Here, we register each item for two different message types. The first one is the ExpandMessage that we just saw. First, we will check if the Sender is the item itself. This is necessary, because the item can both send and receive ExpandMessages. In order to avoid unwanted effects, we need to prevent the item from doing anything if the Message received was sent by the item itself. The next message type that we'll register for is a little bit more tricky. We use that to gather some information from all the items. What we want to know is if an item is currently selected or not. If all items are unselected, we want the whole list to collapse. In order to do this, we will use a different type of message, called IsItemSelectedMessage. Let's take a look at the code. Here is a code of IsItemSelectedMessage. This message has an Action as payload, which is a _callback. The _callback should immediately be executed when the message is received, in order to inform the sender about the state of the item. To allow this, the message has an Execute method, which is just a friendly way to execute the _callback. So here, back into the SelectableViewModel, how do we use this message? First, in the item constructor, we register for this message type. When it is received, the Execute method is called on the message. What it does is very simple; it just returns a value of the IsSelected property to the sender. This way, the sender will know the state of all the items in the list. Let's see who sent the IsSelected message. This happened here, all the way up into the IsSelected property. Because this property will be data bound to the item's checkbox in the user interface, we know when the user deselects one item. If the value is false, we need to check all the other items, in order to know if the list should be collapsed. So we will ask all the items by sending the IsItemSelectedMessage here. When an item executes a callback, we check the result and we use this to compute the global value of all the items. Then, if all the items replied that they are already unselected, we can collapse the list by sending an ExpandMessage with the value of false. Now let's see how we can use this SelectableViewModel inside an application. So here I create an ItemViewModel, which derives from SelectableViewModel. For the demo, it is very simple and has just one Text property. Inside the MainViewModel here, I added an ObservableCollection of ItemViewModel, and here inside the constructor, I create two initial items, which I add to the collection. I also added a RelayCommand here, which is going to be used to add new items to the list on the go. When an item is created and added to the list, I set the IsExpanded property according to the state of the other items. Know that I could also use the IsItemSelectedMessage here if I wanted to, but it is easy enough to use a query against the items in the Observable Collection instead.</p>
<h3>Expandable List: Creating the UI and Testing</h3>
<p>Let's look at the User Interface in Blend now. Right now it is not really what we want. We have a Button, a checkbox, and the item's title. We see the two items created and available as design time data. We already saw how to create design time data for an MVVM Light Application, so I don't go further for now. Let's Edit the Template for the first item. (Typing) Let's hide everything except the Expand button for now. We want this button to look very narrow and to be placed at the far left of the screen. To do that, I created a Styling Blend that I'm going to apply to the button. (Typing) In the normal state, the button is invisible, but let's see what happens in the Template. (Typing) Here I have the States, and if I go to the Pressed State, we set the background color to the phone's accent brush. In the Emulator it is set to red by default, but depending on your User Settings, it can be a different color. Let's go back to the ItemTemplate now. The next element we want to handle is a SelectionCheckBox. In the default state of the item, it should be collapsed, which means that the width should be set to 0 pixels. Note that by default it is set to 68 pixels; remember this value because we will use it later. For now, let's set that to 0 pixels, and in order to get a nicer transition, I will also set the Opacity to 0%. Now I will define the transition, and for this I will need the State Panel, which is selected here, and I'm going to define two states. So, here, let's create a StateGroup and I'm going to call that ExpandStates. Then I create a new state, which I'm going to call Expanded, and then another state, which I'm going to call Collapsed. The Collapsed state is a default state for this item, so here I don't need to do anything. Let's record the Expanded state. Notice that Blend is in recording mode, so everything I do now will be valid just for the Expanded state. What we want to do is set the Opacity to 100%, and then I'm going to restore the Width of the item to 68 pixels, like we had before. Of course, we want this transition to be animated, so I'm going to set the transition time here to 0. 3 seconds, and I'm also going to set the acceleration here to a nice Cubic Transition, like so. Now we need to trigger the transition to happen. Because we use MVVM, we can do that using a DataTrigger behavior, and a GoToStateAction. So first of all, let's stop the recording here. Then I'm going to go to the Assets Library inside the Behaviors and I'm going to take a GoToStateAction and drag it on the Grid here. Actually, I need two GoToStateActions, one for the Expanded State and one for the Collapsed State. Let's take the first one here. I'm going to change the TriggerType to a DataTrigger. And then I'm going to do a Databinding using the Data Binding Editor here. And I'm going to trigger the GoToStateAction when the value of IsExpanded changes. When the value is false, I want to go into the Collapsed State. And for the other GoToStateAction, I will do the same; replace the EventTrigger by a DataTrigger, and here, the Binding to the IsExpanded property. When the value is true, I want to go into the Expanded State. I need to assert GoToStateAction for the initial value of the item. When a new item is added, it needs to go to the correct state depending on the value of its IsExpanded property. This time, instead of using a DataTrigger, I will use a default EventTrigger. I will handle the Loaded Event of the item, and here I will add a Condition. What I will do here is Create a new Data Binding to the IsExpanded property, and I will say that if the Condition is true, then I want to go into the Expanded State without any transition, because this is an initial value, so I don't want the animation to happen. Now that the States and Animations are defined, I just have to bind the UI elements to the ItemViewModel's property. We already took care of the Title. For the checkbox, I'm going to bind the IsChecked property to the IsSelected (Boolean) property here, with a TwoWay DataBinding. And for the Button here, I will go and find the Command property and I will data bind this to the ExpandCommand in the ItemViewModel. Now we can test the application, so here are the two initial items. I can expand them by selecting the first one. Let's select the second item, unselect the first one, and unselect the second one. And now if I expand the items and add a new item, we see that it shows up in the correct state already. If I collapse everything, all three items are collapsing, and I can expand all three items again. This user experience is very common in Windows Phone and it can be tricky to realize if we don't use a decoupled tool, like the MVVM Light Messenger. In that case, however, the Messenger makes it easy to get an undefined number of ViewModels to communicate with each other.</p>
<h3>Unit Test: Testing the SelectableViewModel's Expansion</h3>
<p>For the next sample, we will see how we can unit test a ViewModelLayer of an MVVM Application. The MVVM Light components can easily be used in Unit Test Scenarios, which allows the ViewModels to be thoroughly tested automatically. There are multiple unit test frameworks available for. NET, each with a crowd of followers. It is not the purpose here to show which unit test framework is the best or the worst, but just to show some techniques used to unit test ViewModels with MVVM Light. For the purpose of this course, we will use a unit test framework, which is integrated in Visual Studio. For a starter, let's see how we can test the behavior of the SelectableViewModel that we implemented in the previous sample. We can verify the following features. The first feature is that when one item gets expanded, it must be selected too. In addition, all the items must be expanded. The second feature of the ViewModel is that if the last item of the list gets unselected, then all the items should collapse. To do this, we will create a new UnitTest Application in Windows Phone. Let's do Add, New Project, and here on the Windows Phone, I will select a UnitTest Application. This creates a special type of Windows Phone Application that gets integrated in the unit test framework that Visual Studio offers. Now I can click OK. And now I know that to test our SelectableViewModel, we need to add two references. The first one is a reference to MVVM Light, because SelectableViewModel is a ViewModelBase. So we can do that using NuGet, like before. Here we go, and I'm going to select here the â€˜libraries only'. (Typing) Then, of course, I need to reference from TestApp1 to SelectableList, because this is the assembly in which the ViewModel that we want to test is included. So let's do References, Add Reference. And then I'm going to take Solution, SelectableList, and OK. Now let's see what was created in the project. When we created this unit test project, the first test class was added automatically. In fact, it is a totally standard class, which is decorated with a test class attribute. We also have one TestMethod also decorated with an attribute, this time called TestMethod. You can have as many test classes and TestMethods as you need. Let's just rename this one to TestExpansion. Then we can write the code for this method. First, we will create a List of 5 SelectableViewModels. Then we will call the ExpandCommand on the first item of the list. This simulates the interactions that the user has when he taps the small Expand button on the far-left of the screen. Then we can Assert the result of the test. First, we know that each item in the list should be expanded. Then, we also test that the first item, the one that was tapped, IsSelected. Let's run that test using the Test Explorer. First I need to build the application, and then I can click on Run All. And here we go, the test passed.</p>
<h3>Unit Test: Testing the SelectableViewModel's Collapsing</h3>
<p>The second test I want to write is to test what happens when all the items get unselected. Let's call it TestCollapse. Here I will get the code, and here again, we create a list of 5 SelectableViewModels. Then I'm going to expand the list using the first item, just like before. After that, though, we also select the second item in the list. So now we have two items, which are selected. Now, let's unselect the first item. We can now Assert that all the items should still be expanded because the second item is still selected and so the list may not collapse yet. Then I unselect the second item in the list, and now I can Assert that all the items in the list should collapse. After I build the application, let's run the second test. Here we see that the second test passed as well, which is great. Now, however, let's write something else. If I run both tests together, we see that the first one passes, but the second one fails. This is weird, because we know that the second test passes when it is executed individually. So what happened here? Well the problem is that the Messenger object is used in the implementation, and it has a state, it has kept track of the previous operation. We had the list of SelectableViewModels created in the first test and this had registered with the Messenger. When we register the second list too, in the second test, the first list is still there, it is still registered, and it will respond to the query to know if some items are still selected. This can be a little bit confusing, and this is why you should always reset the Messenger before you create a unit test using it. To do this, we have a static method called Messenger. Reset, that we should call in the beginning of each TestMethod. Let's do that. And I'm going to add the same thing here in the first method as well. Now I can go back, build the application, and run all the tests again. And this time, both tests pass, which is correct. What we learned here are two things; first, we learned that when we use a Messenger, it is better to unregister once you are done with an object. We saw earlier that the Messenger attempts to keep only a weak reference to all the objects that register with it. This is a good protection, but it is not totally foolproof. In case of doubt, you should always unregister the objects to avoid unwanted behavior. In the case of the SelectableList, when the user navigates away from the Windows Phone page, the developer should really unregister the items on the list in the OnNavigatingFrom method. The second thing we learned is that when the unit test is using the Messenger, even behind the cover, you should preventatively call the ResetMethod beforehand. Note that there is also a ResetMethod available on the SimpleIoc component and the same rule applies. Make sure that you call the ResetMethod before you test a piece of code that uses this component.</p>
<h3>Unit Test: Creating and Using Test Services</h3>
<p>For this next sample, we will see how we can use a SimpleIoc component of MVVM Light to mock a DataService and to simulate a web service access in a unit test. Here I am starting with an MVVM Light Application for Windows 8. 1. The exact same thing can be done for WPF, Silverlight, Windows 8, or Windows Phone, so it doesn't really matter which framework you use. The exact same principles will work just fine. Let's review the application. I just created a new MVVM Light Windows Store Application and then I changed a few things. First, I modified the DataItem and I added those two properties, called Property1 and Property2. Then, in the DataService implementation, I added code that we already saw before. It is getting the json file from my web server, deserializes it into a DataItem, and returns it. Note that this code is asynchronous, like every web service code in Windows Store, Windows Phone, etc. Let's open the MainViewModel now. Here in the MainViewModel, I barely modified the default code that we studied in the previous module. So here we have the NavigateCommand, which is going to navigate to the second page, and down here we have the WelcomeTitle property, just like before. Here in the constructor, I call the Initialize method, which is defined further below, and here I modify the default Initialize method slightly in order to get the DataItem from the DataService, and then to set the WelcomeTitle based on this value. If we want to test this MainViewModel with a unit test, we have a couple of challenges. First, the asynchronous operation, which fetches a json file and turns it into an object, is hard to test. When we test the MainViewModel, we don't really need to test the service operation itself. That can be left to the team who implements a DataService class. For us, we can use a simulation of the DataService, since the focus of our test is really on the ViewModel itself. The second challenge is testing the navigation. The application's NavigationService will perform an actual navigation to a different page, which we cannot, of course, use in a unit test. So here, too, we will need to use a simulation. This will allow us to test this thing, which is critical to us, which is that the RelayCommand is correctly implemented and does indeed call the NavigationService with the correct arguments. So how do we do that? Well first I created a new UnitTest Application up here. Like before, I added a reference to MVVM Light, which I did using NuGet. Then I also added another reference, this time to the application that we want to test. This will give us access to the MainViewModel, which is a TestObject. Let's open the UnitTest class here, and I'm going to implement the first TestMethod. In order to create a new MainViewModel, if we check the constructor here, we see that the MainViewModel requires an instance of IDataService and also an instance of INavigationService, but we said we want to simulate those objects, so let's create two Test classes here. Let's create the first class, the TestNavigationService. Here, I will implement the INavigationService interface using ReSharper. Notice that I have, here, the CurrentPageType, which exposes a property. And if I go down here, I have the Navigate method. I can test that the Navigate method has been called correctly, by saving the new page type inside the CurrentPageType. Now I can create the second test service class, which is a TestDataService. Here, too, I need to implement the methods. There is only one method here. This TestDataService needs a little bit of infrastructure, let's add this. And then I can easily implement the GetData method, like this. So what is happening here? Well first I will call the Initialize method, which is going to allow me to Save the value of Property1 and Property2. And then when I call GetData, I'm going to return a new DataItem with those well-known properties, and then I'm going to be able to Assert that the correct values are passed back to me. Now with those two Test services, I can implement my TestMethod, so let's go back to the UnitTest class and I'm going to implement the TestMethod1 here. First, I'm going to create a TestNavigationService and a TestDataService. Then I'm going to Initialize the TestDataService with some known values. And finally, I'm going to create a new MainViewModel with those two well-known DataServices. And then I'm going to Assert that the WelcomeTitle property has been set, according to the format that we want to use. So here this is quite a simple test, but nonetheless it is using the TestNavigationService and the TestDataService, which are needed in order to build the MainViewModel.</p>
<h3>Unit Test: Testing the Navigation and the PropertyChanged</h3>
<p>Let's create a new UnitTest, this time to test a NavigateCommand. So first, just like before, I add a new UnitTest method, and here I create a new TestNavigationService and a new TestDataService. Then, using those two objects, I'm going to create a new MainViewModel, which is my TestObject. Now I'm going to execute the NavigateCommand. Here, I call Execute with a null parameter. And then I can Assert that inside the TestNavigationService, the CurrentPageType is now set to the type of second page. What we test here is that the NavigateCommand has been executed properly and that it calls the NavigationService. Of course, the MainViewModel doesn't know that the Navigation has not actually been executed; it doesn't matter, because the MainViewModel is just using an INavigationService. The last test I will implement here is showing how you can test if an event was raised. For MVVM, we typically want the PropertyChanged event to be raised when an observable property changes. So let's test that for the WelcomeTitle property of the MainViewModel. First I'm going to create the new TestMethod here; let's call that TestWelcomeTitle. Just like before, I create a new TestNavigationService, a new TestDataService, and then I create the new MainViewModel, which is a TestObject. What we will do then is handle the PropertyChanged event of the TestObject. We can do that with a local event handler here defined as a lambda expression. When the event is raised, the code will be executed and set the local variable accordingly. Then we can test the values with Asserts. First, we Assert that the value is false, before the property is changed. Then we assign a new string value to the WelcomeTitle property. And finally here, we test that the event has been raised properly by asserting that the local value is set to true. Now we can run all the tests from the Test Explorer window. Like before, we need to build the application first, and then let's select here â€˜Run All'. And after a short delay, we see that the three tests are successful. If at a later time the team was to modify the MainViewModel and to break these features, the unit test would immediately show this, which is very valuable for the team. Unit tests are typically small and each TestMethod tests one specific aspect of the code. Here, we succeeded in testing three separate features of the MainViewModel by creating some known test implementations of the services. Because of the INavigation and IDataService interfaces, the MainViewModel does not know or care how these services are implemented, but it only knows what they do. Thanks to the Dependency Injection provided by SimpleIoc, the RelayCommand, the PropertyChanged implementation, and all the decoupled techniques that we saw in this course, we can also quite easily improve the testability of our application, and by the same process, we improve its stability and its maintainability over time.</p>
<h3>Summary and Conclusion</h3>
<p>This last module of the MVVM Light reference course was rich in samples. We started by building a plug-in based application in Windows Presentation Foundation. We saw how such an application is typically constructed, with a Contracts assembly that has the interfaces needed for the plug-ins to be located and built, and a Bootstrapper that loads the DLLs from a known folder and explores them to find the plug-ins that will be placed in the UI. Then we saw how various components of MVVM Light can be used to breach the decoupled elements. For example, the Messenger can send messages to all the loaded plugins, whatever the number. The SimpleIoc can make services accessible, even though they are not implemented in the same assembly. Databinding can be used from a plugin to a MainViewModel for data and commands, etc. Plugins are the most decoupled way to build an application. Many of the principles we saw in the Model-View-ViewModel Pattern apply to plugin-based applications even more. And MVVM Light's components help to build these application too. In a second sample, we built a well-known user experience in Windows Phone, where a list's items get expanded when they are tapped on the side. This allows multiple selection of these items with checkboxes. If all items get unselected, the list collapses back into place. If the list is based on MVVM and made of ItemViewModels, the experience can be a little bit tricky to realize in the UI layer, unless we take advantage of components, such as the Messenger. In this sample, we saw how to build this experience from scratch. Finally, we saw a few examples and tips on building unit tests for your ViewModels. We saw that some of the MVVM Light's objects can have a state from previous unit tests, and that you should reset them. We also saw techniques to create test services, such as a DataService or a NavigationService, with well-known behaviors that can be asserted, or to attach to the PropertyChanged event to test if a property changes as expected. Hopefully, these examples, combined with all the other samples that we saw throughout the course, will give you a good idea of how you can take advantage of the MVVM Light Toolkit, to build applications of all sizes and purposes. MVVM Light is relatively easy to get started with if you already know XAML, because it promotes the core techniques that the XAML teams imagined. I want to finish this course by giving you a few resources that can be useful as you continue your learning. First, here is MVVM Light's homepage. This is a starting point for any exploration. Here is a place where you can see the code, get new versions of the installers, see discussions and known issues; it's all there on codeplex. Then, my blog with the MVVM category, where I write articles and give news about the MVVM Light Toolkit's development. If you want to learn more about the specific components, this is probably a good place to check. In case you are not totally up-to-date with the Model-View-ViewModel Pattern yet, or if you want a refresher, these videos should help. They present MVVM techniques from the ground up. Also, make sure to check Pluralsight's own videos talking about MVVM. For technical support, I recommend checking Stackoverflow, where many questions have been answered already. Make sure to tag your question with the mvvm-light's tag. There is a great team there, very eager to answer more questions. And finally, you are welcome to chat with me on Twitter. I am always happy to get messages from MVVM Light users, and I try my best to answer questions if I can. The MVVM Light community is full of very constructive people and it is a great, great pleasure to engage with all of you guys. MVVM Light got an incredible success in the past few years, with more than 300, 000 downloads. And I am convinced that it is in great part because it is not too ambitious, but it tries to stick to the basics. It actively promotes the same techniques and tools that the XAML teams have imagined, so you don't have to learn everything from scratch again. It also allows you to use the same techniques and to reuse code between the XAML platforms, which gives you a head start. This all contributes to its incredible success, with a large number of applications based on it in WPF, Windows Phone, Windows Store, and even Xbox. And hopefully for you, too, in the future. I tried to show examples in all the popular XAML platforms, but in the end the techniques used are the same, and if you get started in one of them, you will be able to pick up another platform very easily. Because of its affinity with XAML, MVVM Light gives you a great design time experience, which is a huge advantage in today's world, where the user experience is so important for your apps. And it also improves the testability of your applications for more consistency and a better maintainability. In conclusion, I hope that this course has been helpful for you all. It was a huge undertaking and I am proud to finally have a great platform at Pluralsight to help all MVVM Light users to learn how to use this Toolkit. I am also very eager to hear your feedback and to create more courses showing advanced techniques with the MVVM Light Toolkit. Thank you, and happy coding!</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>

</html>